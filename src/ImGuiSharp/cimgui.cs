// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

namespace ImGuiSharp
{
    public enum ImGuiInputEventType
    {
        ImGuiInputEventTypeNone = 0,
        ImGuiInputEventTypeMousePos = 1,
        ImGuiInputEventTypeMouseWheel = 2,
        ImGuiInputEventTypeMouseButton = 3,
        ImGuiInputEventTypeKey = 4,
        ImGuiInputEventTypeChar = 5,
        ImGuiInputEventTypeFocus = 6,
        ImGuiInputEventTypeCOUNT = 7
    }

    public enum ImGuiInputSource
    {
        ImGuiInputSourceNone = 0,
        ImGuiInputSourceMouse = 1,
        ImGuiInputSourceKeyboard = 2,
        ImGuiInputSourceGamepad = 3,
        ImGuiInputSourceClipboard = 4,
        ImGuiInputSourceNav = 5,
        ImGuiInputSourceCOUNT = 6
    }

    public enum ImGuiNavLayer
    {
        ImGuiNavLayerMain = 0,
        ImGuiNavLayerMenu = 1,
        ImGuiNavLayerCOUNT = 2
    }

    public enum ImGuiContextHookType
    {
        ImGuiContextHookTypeNewFramePre = 0,
        ImGuiContextHookTypeNewFramePost = 1,
        ImGuiContextHookTypeEndFramePre = 2,
        ImGuiContextHookTypeEndFramePost = 3,
        ImGuiContextHookTypeRenderPre = 4,
        ImGuiContextHookTypeRenderPost = 5,
        ImGuiContextHookTypeShutdown = 6,
        ImGuiContextHookTypePendingRemoval = 7
    }

    public enum ImGuiLogType
    {
        ImGuiLogTypeNone = 0,
        ImGuiLogTypeTTY = 1,
        ImGuiLogTypeFile = 2,
        ImGuiLogTypeBuffer = 3,
        ImGuiLogTypeClipboard = 4
    }

    public enum ImGuiWindowFlags
    {
        ImGuiWindowFlagsNone = 0,
        ImGuiWindowFlagsNoTitleBar = 1,
        ImGuiWindowFlagsNoResize = 2,
        ImGuiWindowFlagsNoMove = 4,
        ImGuiWindowFlagsNoScrollbar = 8,
        ImGuiWindowFlagsNoScrollWithMouse = 16,
        ImGuiWindowFlagsNoCollapse = 32,
        ImGuiWindowFlagsAlwaysAutoResize = 64,
        ImGuiWindowFlagsNoBackground = 128,
        ImGuiWindowFlagsNoSavedSettings = 256,
        ImGuiWindowFlagsNoMouseInputs = 512,
        ImGuiWindowFlagsMenuBar = 1024,
        ImGuiWindowFlagsHorizontalScrollbar = 2048,
        ImGuiWindowFlagsNoFocusOnAppearing = 4096,
        ImGuiWindowFlagsNoBringToFrontOnFocus = 8192,
        ImGuiWindowFlagsAlwaysVerticalScrollbar = 16384,
        ImGuiWindowFlagsAlwaysHorizontalScrollbar = 32768,
        ImGuiWindowFlagsAlwaysUseWindowPadding = 65536,
        ImGuiWindowFlagsNoNavInputs = 262144,
        ImGuiWindowFlagsNoNavFocus = 524288,
        ImGuiWindowFlagsUnsavedDocument = 1048576,
        ImGuiWindowFlagsNoNav = 786432,
        ImGuiWindowFlagsNoDecoration = 43,
        ImGuiWindowFlagsNoInputs = 786944,
        ImGuiWindowFlagsNavFlattened = 8388608,
        ImGuiWindowFlagsChildWindow = 16777216,
        ImGuiWindowFlagsTooltip = 33554432,
        ImGuiWindowFlagsPopup = 67108864,
        ImGuiWindowFlagsModal = 134217728,
        ImGuiWindowFlagsChildMenu = 268435456
    }

    [Flags]
    public enum ImGuiInputTextFlags
    {
        ImGuiInputTextFlagsNone = 0,
        ImGuiInputTextFlagsCharsDecimal = 1,
        ImGuiInputTextFlagsCharsHexadecimal = 2,
        ImGuiInputTextFlagsCharsUppercase = 4,
        ImGuiInputTextFlagsCharsNoBlank = 8,
        ImGuiInputTextFlagsAutoSelectAll = 16,
        ImGuiInputTextFlagsEnterReturnsTrue = 32,
        ImGuiInputTextFlagsCallbackCompletion = 64,
        ImGuiInputTextFlagsCallbackHistory = 128,
        ImGuiInputTextFlagsCallbackAlways = 256,
        ImGuiInputTextFlagsCallbackCharFilter = 512,
        ImGuiInputTextFlagsAllowTabInput = 1024,
        ImGuiInputTextFlagsCtrlEnterForNewLine = 2048,
        ImGuiInputTextFlagsNoHorizontalScroll = 4096,
        ImGuiInputTextFlagsAlwaysOverwrite = 8192,
        ImGuiInputTextFlagsReadOnly = 16384,
        ImGuiInputTextFlagsPassword = 32768,
        ImGuiInputTextFlagsNoUndoRedo = 65536,
        ImGuiInputTextFlagsCharsScientific = 131072,
        ImGuiInputTextFlagsCallbackResize = 262144,
        ImGuiInputTextFlagsCallbackEdit = 524288
    }

    public enum ImGuiTreeNodeFlags
    {
        ImGuiTreeNodeFlagsNone = 0,
        ImGuiTreeNodeFlagsSelected = 1,
        ImGuiTreeNodeFlagsFramed = 2,
        ImGuiTreeNodeFlagsAllowItemOverlap = 4,
        ImGuiTreeNodeFlagsNoTreePushOnOpen = 8,
        ImGuiTreeNodeFlagsNoAutoOpenOnLog = 16,
        ImGuiTreeNodeFlagsDefaultOpen = 32,
        ImGuiTreeNodeFlagsOpenOnDoubleClick = 64,
        ImGuiTreeNodeFlagsOpenOnArrow = 128,
        ImGuiTreeNodeFlagsLeaf = 256,
        ImGuiTreeNodeFlagsBullet = 512,
        ImGuiTreeNodeFlagsFramePadding = 1024,
        ImGuiTreeNodeFlagsSpanAvailWidth = 2048,
        ImGuiTreeNodeFlagsSpanFullWidth = 4096,
        ImGuiTreeNodeFlagsNavLeftJumpsBackHere = 8192,
        ImGuiTreeNodeFlagsCollapsingHeader = 26
    }

    public enum ImGuiPopupFlags
    {
        ImGuiPopupFlagsNone = 0,
        ImGuiPopupFlagsMouseButtonLeft = 0,
        ImGuiPopupFlagsMouseButtonRight = 1,
        ImGuiPopupFlagsMouseButtonMiddle = 2,
        ImGuiPopupFlagsMouseButtonMask = 31,
        ImGuiPopupFlagsMouseButtonDefault = 1,
        ImGuiPopupFlagsNoOpenOverExistingPopup = 32,
        ImGuiPopupFlagsNoOpenOverItems = 64,
        ImGuiPopupFlagsAnyPopupId = 128,
        ImGuiPopupFlagsAnyPopupLevel = 256,
        ImGuiPopupFlagsAnyPopup = 384
    }

    [Flags]
    public enum ImGuiSelectableFlags
    {
        ImGuiSelectableFlagsNone = 0,
        ImGuiSelectableFlagsDontClosePopups = 1,
        ImGuiSelectableFlagsSpanAllColumns = 2,
        ImGuiSelectableFlagsAllowDoubleClick = 4,
        ImGuiSelectableFlagsDisabled = 8,
        ImGuiSelectableFlagsAllowItemOverlap = 16
    }

    public enum ImGuiComboFlags
    {
        ImGuiComboFlagsNone = 0,
        ImGuiComboFlagsPopupAlignLeft = 1,
        ImGuiComboFlagsHeightSmall = 2,
        ImGuiComboFlagsHeightRegular = 4,
        ImGuiComboFlagsHeightLarge = 8,
        ImGuiComboFlagsHeightLargest = 16,
        ImGuiComboFlagsNoArrowButton = 32,
        ImGuiComboFlagsNoPreview = 64,
        ImGuiComboFlagsHeightMask = 30
    }

    public enum ImGuiTabBarFlags
    {
        ImGuiTabBarFlagsNone = 0,
        ImGuiTabBarFlagsReorderable = 1,
        ImGuiTabBarFlagsAutoSelectNewTabs = 2,
        ImGuiTabBarFlagsTabListPopupButton = 4,
        ImGuiTabBarFlagsNoCloseWithMiddleMouseButton = 8,
        ImGuiTabBarFlagsNoTabListScrollingButtons = 16,
        ImGuiTabBarFlagsNoTooltip = 32,
        ImGuiTabBarFlagsFittingPolicyResizeDown = 64,
        ImGuiTabBarFlagsFittingPolicyScroll = 128,
        ImGuiTabBarFlagsFittingPolicyMask = 192,
        ImGuiTabBarFlagsFittingPolicyDefault = 64
    }

    [Flags]
    public enum ImGuiTabItemFlags
    {
        ImGuiTabItemFlagsNone = 0,
        ImGuiTabItemFlagsUnsavedDocument = 1,
        ImGuiTabItemFlagsSetSelected = 2,
        ImGuiTabItemFlagsNoCloseWithMiddleMouseButton = 4,
        ImGuiTabItemFlagsNoPushId = 8,
        ImGuiTabItemFlagsNoTooltip = 16,
        ImGuiTabItemFlagsNoReorder = 32,
        ImGuiTabItemFlagsLeading = 64,
        ImGuiTabItemFlagsTrailing = 128
    }

    public enum ImGuiTableFlags
    {
        ImGuiTableFlagsNone = 0,
        ImGuiTableFlagsResizable = 1,
        ImGuiTableFlagsReorderable = 2,
        ImGuiTableFlagsHideable = 4,
        ImGuiTableFlagsSortable = 8,
        ImGuiTableFlagsNoSavedSettings = 16,
        ImGuiTableFlagsContextMenuInBody = 32,
        ImGuiTableFlagsRowBg = 64,
        ImGuiTableFlagsBordersInnerH = 128,
        ImGuiTableFlagsBordersOuterH = 256,
        ImGuiTableFlagsBordersInnerV = 512,
        ImGuiTableFlagsBordersOuterV = 1024,
        ImGuiTableFlagsBordersH = 384,
        ImGuiTableFlagsBordersV = 1536,
        ImGuiTableFlagsBordersInner = 640,
        ImGuiTableFlagsBordersOuter = 1280,
        ImGuiTableFlagsBorders = 1920,
        ImGuiTableFlagsNoBordersInBody = 2048,
        ImGuiTableFlagsNoBordersInBodyUntilResize = 4096,
        ImGuiTableFlagsSizingFixedFit = 8192,
        ImGuiTableFlagsSizingFixedSame = 16384,
        ImGuiTableFlagsSizingStretchProp = 24576,
        ImGuiTableFlagsSizingStretchSame = 32768,
        ImGuiTableFlagsNoHostExtendX = 65536,
        ImGuiTableFlagsNoHostExtendY = 131072,
        ImGuiTableFlagsNoKeepColumnsVisible = 262144,
        ImGuiTableFlagsPreciseWidths = 524288,
        ImGuiTableFlagsNoClip = 1048576,
        ImGuiTableFlagsPadOuterX = 2097152,
        ImGuiTableFlagsNoPadOuterX = 4194304,
        ImGuiTableFlagsNoPadInnerX = 8388608,
        ImGuiTableFlagsScrollX = 16777216,
        ImGuiTableFlagsScrollY = 33554432,
        ImGuiTableFlagsSortMulti = 67108864,
        ImGuiTableFlagsSortTristate = 134217728,
        ImGuiTableFlagsSizingMask = 57344
    }

    public enum ImGuiTableColumnFlags
    {
        ImGuiTableColumnFlagsNone = 0,
        ImGuiTableColumnFlagsDisabled = 1,
        ImGuiTableColumnFlagsDefaultHide = 2,
        ImGuiTableColumnFlagsDefaultSort = 4,
        ImGuiTableColumnFlagsWidthStretch = 8,
        ImGuiTableColumnFlagsWidthFixed = 16,
        ImGuiTableColumnFlagsNoResize = 32,
        ImGuiTableColumnFlagsNoReorder = 64,
        ImGuiTableColumnFlagsNoHide = 128,
        ImGuiTableColumnFlagsNoClip = 256,
        ImGuiTableColumnFlagsNoSort = 512,
        ImGuiTableColumnFlagsNoSortAscending = 1024,
        ImGuiTableColumnFlagsNoSortDescending = 2048,
        ImGuiTableColumnFlagsNoHeaderLabel = 4096,
        ImGuiTableColumnFlagsNoHeaderWidth = 8192,
        ImGuiTableColumnFlagsPreferSortAscending = 16384,
        ImGuiTableColumnFlagsPreferSortDescending = 32768,
        ImGuiTableColumnFlagsIndentEnable = 65536,
        ImGuiTableColumnFlagsIndentDisable = 131072,
        ImGuiTableColumnFlagsIsEnabled = 16777216,
        ImGuiTableColumnFlagsIsVisible = 33554432,
        ImGuiTableColumnFlagsIsSorted = 67108864,
        ImGuiTableColumnFlagsIsHovered = 134217728,
        ImGuiTableColumnFlagsWidthMask = 24,
        ImGuiTableColumnFlagsIndentMask = 196608,
        ImGuiTableColumnFlagsStatusMask = 251658240,
        ImGuiTableColumnFlagsNoDirectResize = 1073741824
    }

    public enum ImGuiTableRowFlags
    {
        ImGuiTableRowFlagsNone = 0,
        ImGuiTableRowFlagsHeaders = 1
    }

    public enum ImGuiTableBgTarget
    {
        ImGuiTableBgTargetNone = 0,
        ImGuiTableBgTargetRowBg0 = 1,
        ImGuiTableBgTargetRowBg1 = 2,
        ImGuiTableBgTargetCellBg = 3
    }

    public enum ImGuiFocusedFlags
    {
        ImGuiFocusedFlagsNone = 0,
        ImGuiFocusedFlagsChildWindows = 1,
        ImGuiFocusedFlagsRootWindow = 2,
        ImGuiFocusedFlagsAnyWindow = 4,
        ImGuiFocusedFlagsNoPopupHierarchy = 8,
        ImGuiFocusedFlagsRootAndChildWindows = 3
    }

    public enum ImGuiHoveredFlags
    {
        ImGuiHoveredFlagsNone = 0,
        ImGuiHoveredFlagsChildWindows = 1,
        ImGuiHoveredFlagsRootWindow = 2,
        ImGuiHoveredFlagsAnyWindow = 4,
        ImGuiHoveredFlagsNoPopupHierarchy = 8,
        ImGuiHoveredFlagsAllowWhenBlockedByPopup = 32,
        ImGuiHoveredFlagsAllowWhenBlockedByActiveItem = 128,
        ImGuiHoveredFlagsAllowWhenOverlapped = 256,
        ImGuiHoveredFlagsAllowWhenDisabled = 512,
        ImGuiHoveredFlagsRectOnly = 416,
        ImGuiHoveredFlagsRootAndChildWindows = 3
    }

    public enum ImGuiDragDropFlags
    {
        ImGuiDragDropFlagsNone = 0,
        ImGuiDragDropFlagsSourceNoPreviewTooltip = 1,
        ImGuiDragDropFlagsSourceNoDisableHover = 2,
        ImGuiDragDropFlagsSourceNoHoldToOpenOthers = 4,
        ImGuiDragDropFlagsSourceAllowNullID = 8,
        ImGuiDragDropFlagsSourceExtern = 16,
        ImGuiDragDropFlagsSourceAutoExpirePayload = 32,
        ImGuiDragDropFlagsAcceptBeforeDelivery = 1024,
        ImGuiDragDropFlagsAcceptNoDrawDefaultRect = 2048,
        ImGuiDragDropFlagsAcceptNoPreviewTooltip = 4096,
        ImGuiDragDropFlagsAcceptPeekOnly = 3072
    }

    public enum ImGuiDataType
    {
        ImGuiDataTypeS8 = 0,
        ImGuiDataTypeU8 = 1,
        ImGuiDataTypeS16 = 2,
        ImGuiDataTypeU16 = 3,
        ImGuiDataTypeS32 = 4,
        ImGuiDataTypeU32 = 5,
        ImGuiDataTypeS64 = 6,
        ImGuiDataTypeU64 = 7,
        ImGuiDataTypeFloat = 8,
        ImGuiDataTypeDouble = 9,
        ImGuiDataTypeCOUNT = 10
    }

    public enum ImGuiDir
    {
        ImGuiDirNone = -1,
        ImGuiDirLeft = 0,
        ImGuiDirRight = 1,
        ImGuiDirUp = 2,
        ImGuiDirDown = 3,
        ImGuiDirCOUNT = 4
    }

    public enum ImGuiSortDirection
    {
        ImGuiSortDirectionNone = 0,
        ImGuiSortDirectionAscending = 1,
        ImGuiSortDirectionDescending = 2
    }

    public enum ImGuiKey
    {
        ImGuiKeyNone = 0,
        ImGuiKeyTab = 512,
        ImGuiKeyLeftArrow = 513,
        ImGuiKeyRightArrow = 514,
        ImGuiKeyUpArrow = 515,
        ImGuiKeyDownArrow = 516,
        ImGuiKeyPageUp = 517,
        ImGuiKeyPageDown = 518,
        ImGuiKeyHome = 519,
        ImGuiKeyEnd = 520,
        ImGuiKeyInsert = 521,
        ImGuiKeyDelete = 522,
        ImGuiKeyBackspace = 523,
        ImGuiKeySpace = 524,
        ImGuiKeyEnter = 525,
        ImGuiKeyEscape = 526,
        ImGuiKeyLeftCtrl = 527,
        ImGuiKeyLeftShift = 528,
        ImGuiKeyLeftAlt = 529,
        ImGuiKeyLeftSuper = 530,
        ImGuiKeyRightCtrl = 531,
        ImGuiKeyRightShift = 532,
        ImGuiKeyRightAlt = 533,
        ImGuiKeyRightSuper = 534,
        ImGuiKeyMenu = 535,
        ImGuiKey0 = 536,
        ImGuiKey1 = 537,
        ImGuiKey2 = 538,
        ImGuiKey3 = 539,
        ImGuiKey4 = 540,
        ImGuiKey5 = 541,
        ImGuiKey6 = 542,
        ImGuiKey7 = 543,
        ImGuiKey8 = 544,
        ImGuiKey9 = 545,
        ImGuiKeyA = 546,
        ImGuiKeyB = 547,
        ImGuiKeyC = 548,
        ImGuiKeyD = 549,
        ImGuiKeyE = 550,
        ImGuiKeyF = 551,
        ImGuiKeyG = 552,
        ImGuiKeyH = 553,
        ImGuiKeyI = 554,
        ImGuiKeyJ = 555,
        ImGuiKeyK = 556,
        ImGuiKeyL = 557,
        ImGuiKeyM = 558,
        ImGuiKeyN = 559,
        ImGuiKeyO = 560,
        ImGuiKeyP = 561,
        ImGuiKeyQ = 562,
        ImGuiKeyR = 563,
        ImGuiKeyS = 564,
        ImGuiKeyT = 565,
        ImGuiKeyU = 566,
        ImGuiKeyV = 567,
        ImGuiKeyW = 568,
        ImGuiKeyX = 569,
        ImGuiKeyY = 570,
        ImGuiKeyZ = 571,
        ImGuiKeyF1 = 572,
        ImGuiKeyF2 = 573,
        ImGuiKeyF3 = 574,
        ImGuiKeyF4 = 575,
        ImGuiKeyF5 = 576,
        ImGuiKeyF6 = 577,
        ImGuiKeyF7 = 578,
        ImGuiKeyF8 = 579,
        ImGuiKeyF9 = 580,
        ImGuiKeyF10 = 581,
        ImGuiKeyF11 = 582,
        ImGuiKeyF12 = 583,
        ImGuiKeyApostrophe = 584,
        ImGuiKeyComma = 585,
        ImGuiKeyMinus = 586,
        ImGuiKeyPeriod = 587,
        ImGuiKeySlash = 588,
        ImGuiKeySemicolon = 589,
        ImGuiKeyEqual = 590,
        ImGuiKeyLeftBracket = 591,
        ImGuiKeyBackslash = 592,
        ImGuiKeyRightBracket = 593,
        ImGuiKeyGraveAccent = 594,
        ImGuiKeyCapsLock = 595,
        ImGuiKeyScrollLock = 596,
        ImGuiKeyNumLock = 597,
        ImGuiKeyPrintScreen = 598,
        ImGuiKeyPause = 599,
        ImGuiKeyKeypad0 = 600,
        ImGuiKeyKeypad1 = 601,
        ImGuiKeyKeypad2 = 602,
        ImGuiKeyKeypad3 = 603,
        ImGuiKeyKeypad4 = 604,
        ImGuiKeyKeypad5 = 605,
        ImGuiKeyKeypad6 = 606,
        ImGuiKeyKeypad7 = 607,
        ImGuiKeyKeypad8 = 608,
        ImGuiKeyKeypad9 = 609,
        ImGuiKeyKeypadDecimal = 610,
        ImGuiKeyKeypadDivide = 611,
        ImGuiKeyKeypadMultiply = 612,
        ImGuiKeyKeypadSubtract = 613,
        ImGuiKeyKeypadAdd = 614,
        ImGuiKeyKeypadEnter = 615,
        ImGuiKeyKeypadEqual = 616,
        ImGuiKeyGamepadStart = 617,
        ImGuiKeyGamepadBack = 618,
        ImGuiKeyGamepadFaceUp = 619,
        ImGuiKeyGamepadFaceDown = 620,
        ImGuiKeyGamepadFaceLeft = 621,
        ImGuiKeyGamepadFaceRight = 622,
        ImGuiKeyGamepadDpadUp = 623,
        ImGuiKeyGamepadDpadDown = 624,
        ImGuiKeyGamepadDpadLeft = 625,
        ImGuiKeyGamepadDpadRight = 626,
        ImGuiKeyGamepadL1 = 627,
        ImGuiKeyGamepadR1 = 628,
        ImGuiKeyGamepadL2 = 629,
        ImGuiKeyGamepadR2 = 630,
        ImGuiKeyGamepadL3 = 631,
        ImGuiKeyGamepadR3 = 632,
        ImGuiKeyGamepadLStickUp = 633,
        ImGuiKeyGamepadLStickDown = 634,
        ImGuiKeyGamepadLStickLeft = 635,
        ImGuiKeyGamepadLStickRight = 636,
        ImGuiKeyGamepadRStickUp = 637,
        ImGuiKeyGamepadRStickDown = 638,
        ImGuiKeyGamepadRStickLeft = 639,
        ImGuiKeyGamepadRStickRight = 640,
        ImGuiKeyModCtrl = 641,
        ImGuiKeyModShift = 642,
        ImGuiKeyModAlt = 643,
        ImGuiKeyModSuper = 644,
        ImGuiKeyCOUNT = 645,
        ImGuiKeyNamedKeyBEGIN = 512,
        ImGuiKeyNamedKeyEND = 645,
        ImGuiKeyNamedKeyCOUNT = 133,
        ImGuiKeyKeysDataSIZE = 645,
        ImGuiKeyKeysDataOFFSET = 0
    }

    [Flags]
    public enum ImGuiKeyModFlags
    {
        ImGuiKeyModFlagsNone = 0,
        ImGuiKeyModFlagsCtrl = 1,
        ImGuiKeyModFlagsShift = 2,
        ImGuiKeyModFlagsAlt = 4,
        ImGuiKeyModFlagsSuper = 8
    }

    public enum ImGuiNavInput
    {
        ImGuiNavInputActivate = 0,
        ImGuiNavInputCancel = 1,
        ImGuiNavInputInput = 2,
        ImGuiNavInputMenu = 3,
        ImGuiNavInputDpadLeft = 4,
        ImGuiNavInputDpadRight = 5,
        ImGuiNavInputDpadUp = 6,
        ImGuiNavInputDpadDown = 7,
        ImGuiNavInputLStickLeft = 8,
        ImGuiNavInputLStickRight = 9,
        ImGuiNavInputLStickUp = 10,
        ImGuiNavInputLStickDown = 11,
        ImGuiNavInputFocusPrev = 12,
        ImGuiNavInputFocusNext = 13,
        ImGuiNavInputTweakSlow = 14,
        ImGuiNavInputTweakFast = 15,
        ImGuiNavInputKeyLeft = 16,
        ImGuiNavInputKeyRight = 17,
        ImGuiNavInputKeyUp = 18,
        ImGuiNavInputKeyDown = 19,
        ImGuiNavInputCOUNT = 20
    }

    [Flags]
    public enum ImGuiConfigFlags
    {
        ImGuiConfigFlagsNone = 0,
        ImGuiConfigFlagsNavEnableKeyboard = 1,
        ImGuiConfigFlagsNavEnableGamepad = 2,
        ImGuiConfigFlagsNavEnableSetMousePos = 4,
        ImGuiConfigFlagsNavNoCaptureKeyboard = 8,
        ImGuiConfigFlagsNoMouse = 16,
        ImGuiConfigFlagsNoMouseCursorChange = 32,
        ImGuiConfigFlagsIsSRGB = 1048576,
        ImGuiConfigFlagsIsTouchScreen = 2097152
    }

    [Flags]
    public enum ImGuiBackendFlags
    {
        ImGuiBackendFlagsNone = 0,
        ImGuiBackendFlagsHasGamepad = 1,
        ImGuiBackendFlagsHasMouseCursors = 2,
        ImGuiBackendFlagsHasSetMousePos = 4,
        ImGuiBackendFlagsRendererHasVtxOffset = 8
    }

    public enum ImGuiCol
    {
        ImGuiColText = 0,
        ImGuiColTextDisabled = 1,
        ImGuiColWindowBg = 2,
        ImGuiColChildBg = 3,
        ImGuiColPopupBg = 4,
        ImGuiColBorder = 5,
        ImGuiColBorderShadow = 6,
        ImGuiColFrameBg = 7,
        ImGuiColFrameBgHovered = 8,
        ImGuiColFrameBgActive = 9,
        ImGuiColTitleBg = 10,
        ImGuiColTitleBgActive = 11,
        ImGuiColTitleBgCollapsed = 12,
        ImGuiColMenuBarBg = 13,
        ImGuiColScrollbarBg = 14,
        ImGuiColScrollbarGrab = 15,
        ImGuiColScrollbarGrabHovered = 16,
        ImGuiColScrollbarGrabActive = 17,
        ImGuiColCheckMark = 18,
        ImGuiColSliderGrab = 19,
        ImGuiColSliderGrabActive = 20,
        ImGuiColButton = 21,
        ImGuiColButtonHovered = 22,
        ImGuiColButtonActive = 23,
        ImGuiColHeader = 24,
        ImGuiColHeaderHovered = 25,
        ImGuiColHeaderActive = 26,
        ImGuiColSeparator = 27,
        ImGuiColSeparatorHovered = 28,
        ImGuiColSeparatorActive = 29,
        ImGuiColResizeGrip = 30,
        ImGuiColResizeGripHovered = 31,
        ImGuiColResizeGripActive = 32,
        ImGuiColTab = 33,
        ImGuiColTabHovered = 34,
        ImGuiColTabActive = 35,
        ImGuiColTabUnfocused = 36,
        ImGuiColTabUnfocusedActive = 37,
        ImGuiColPlotLines = 38,
        ImGuiColPlotLinesHovered = 39,
        ImGuiColPlotHistogram = 40,
        ImGuiColPlotHistogramHovered = 41,
        ImGuiColTableHeaderBg = 42,
        ImGuiColTableBorderStrong = 43,
        ImGuiColTableBorderLight = 44,
        ImGuiColTableRowBg = 45,
        ImGuiColTableRowBgAlt = 46,
        ImGuiColTextSelectedBg = 47,
        ImGuiColDragDropTarget = 48,
        ImGuiColNavHighlight = 49,
        ImGuiColNavWindowingHighlight = 50,
        ImGuiColNavWindowingDimBg = 51,
        ImGuiColModalWindowDimBg = 52,
        ImGuiColCOUNT = 53
    }

    public enum ImGuiStyleVar
    {
        ImGuiStyleVarAlpha = 0,
        ImGuiStyleVarDisabledAlpha = 1,
        ImGuiStyleVarWindowPadding = 2,
        ImGuiStyleVarWindowRounding = 3,
        ImGuiStyleVarWindowBorderSize = 4,
        ImGuiStyleVarWindowMinSize = 5,
        ImGuiStyleVarWindowTitleAlign = 6,
        ImGuiStyleVarChildRounding = 7,
        ImGuiStyleVarChildBorderSize = 8,
        ImGuiStyleVarPopupRounding = 9,
        ImGuiStyleVarPopupBorderSize = 10,
        ImGuiStyleVarFramePadding = 11,
        ImGuiStyleVarFrameRounding = 12,
        ImGuiStyleVarFrameBorderSize = 13,
        ImGuiStyleVarItemSpacing = 14,
        ImGuiStyleVarItemInnerSpacing = 15,
        ImGuiStyleVarIndentSpacing = 16,
        ImGuiStyleVarCellPadding = 17,
        ImGuiStyleVarScrollbarSize = 18,
        ImGuiStyleVarScrollbarRounding = 19,
        ImGuiStyleVarGrabMinSize = 20,
        ImGuiStyleVarGrabRounding = 21,
        ImGuiStyleVarTabRounding = 22,
        ImGuiStyleVarButtonTextAlign = 23,
        ImGuiStyleVarSelectableTextAlign = 24,
        ImGuiStyleVarCOUNT = 25
    }

    public enum ImGuiButtonFlags
    {
        ImGuiButtonFlagsNone = 0,
        ImGuiButtonFlagsMouseButtonLeft = 1,
        ImGuiButtonFlagsMouseButtonRight = 2,
        ImGuiButtonFlagsMouseButtonMiddle = 4,
        ImGuiButtonFlagsMouseButtonMask = 7,
        ImGuiButtonFlagsMouseButtonDefault = 1
    }

    public enum ImGuiColorEditFlags
    {
        ImGuiColorEditFlagsNone = 0,
        ImGuiColorEditFlagsNoAlpha = 2,
        ImGuiColorEditFlagsNoPicker = 4,
        ImGuiColorEditFlagsNoOptions = 8,
        ImGuiColorEditFlagsNoSmallPreview = 16,
        ImGuiColorEditFlagsNoInputs = 32,
        ImGuiColorEditFlagsNoTooltip = 64,
        ImGuiColorEditFlagsNoLabel = 128,
        ImGuiColorEditFlagsNoSidePreview = 256,
        ImGuiColorEditFlagsNoDragDrop = 512,
        ImGuiColorEditFlagsNoBorder = 1024,
        ImGuiColorEditFlagsAlphaBar = 65536,
        ImGuiColorEditFlagsAlphaPreview = 131072,
        ImGuiColorEditFlagsAlphaPreviewHalf = 262144,
        ImGuiColorEditFlagsHDR = 524288,
        ImGuiColorEditFlagsDisplayRGB = 1048576,
        ImGuiColorEditFlagsDisplayHSV = 2097152,
        ImGuiColorEditFlagsDisplayHex = 4194304,
        ImGuiColorEditFlagsUint8 = 8388608,
        ImGuiColorEditFlagsFloat = 16777216,
        ImGuiColorEditFlagsPickerHueBar = 33554432,
        ImGuiColorEditFlagsPickerHueWheel = 67108864,
        ImGuiColorEditFlagsInputRGB = 134217728,
        ImGuiColorEditFlagsInputHSV = 268435456,
        ImGuiColorEditFlagsDefaultOptions = 177209344,
        ImGuiColorEditFlagsDisplayMask = 7340032,
        ImGuiColorEditFlagsDataTypeMask = 25165824,
        ImGuiColorEditFlagsPickerMask = 100663296,
        ImGuiColorEditFlagsInputMask = 402653184
    }

    public enum ImGuiSliderFlags
    {
        ImGuiSliderFlagsNone = 0,
        ImGuiSliderFlagsAlwaysClamp = 16,
        ImGuiSliderFlagsLogarithmic = 32,
        ImGuiSliderFlagsNoRoundToFormat = 64,
        ImGuiSliderFlagsNoInput = 128,
        ImGuiSliderFlagsInvalidMask = 1879048207
    }

    public enum ImGuiMouseButton
    {
        ImGuiMouseButtonLeft = 0,
        ImGuiMouseButtonRight = 1,
        ImGuiMouseButtonMiddle = 2,
        ImGuiMouseButtonCOUNT = 5
    }

    public enum ImGuiMouseCursor
    {
        ImGuiMouseCursorNone = -1,
        ImGuiMouseCursorArrow = 0,
        ImGuiMouseCursorTextInput = 1,
        ImGuiMouseCursorResizeAll = 2,
        ImGuiMouseCursorResizeNS = 3,
        ImGuiMouseCursorResizeEW = 4,
        ImGuiMouseCursorResizeNESW = 5,
        ImGuiMouseCursorResizeNWSE = 6,
        ImGuiMouseCursorHand = 7,
        ImGuiMouseCursorNotAllowed = 8,
        ImGuiMouseCursorCOUNT = 9
    }

    [Flags]
    public enum ImGuiCond
    {
        ImGuiCondNone = 0,
        ImGuiCondAlways = 1,
        ImGuiCondOnce = 2,
        ImGuiCondFirstUseEver = 4,
        ImGuiCondAppearing = 8
    }

    public enum ImDrawFlags
    {
        ImDrawFlagsNone = 0,
        ImDrawFlagsClosed = 1,
        ImDrawFlagsRoundCornersTopLeft = 16,
        ImDrawFlagsRoundCornersTopRight = 32,
        ImDrawFlagsRoundCornersBottomLeft = 64,
        ImDrawFlagsRoundCornersBottomRight = 128,
        ImDrawFlagsRoundCornersNone = 256,
        ImDrawFlagsRoundCornersTop = 48,
        ImDrawFlagsRoundCornersBottom = 192,
        ImDrawFlagsRoundCornersLeft = 80,
        ImDrawFlagsRoundCornersRight = 160,
        ImDrawFlagsRoundCornersAll = 240,
        ImDrawFlagsRoundCornersDefault = 240,
        ImDrawFlagsRoundCornersMask = 496
    }

    [Flags]
    public enum ImDrawListFlags
    {
        ImDrawListFlagsNone = 0,
        ImDrawListFlagsAntiAliasedLines = 1,
        ImDrawListFlagsAntiAliasedLinesUseTex = 2,
        ImDrawListFlagsAntiAliasedFill = 4,
        ImDrawListFlagsAllowVtxOffset = 8
    }

    [Flags]
    public enum ImFontAtlasFlags
    {
        ImFontAtlasFlagsNone = 0,
        ImFontAtlasFlagsNoPowerOfTwoHeight = 1,
        ImFontAtlasFlagsNoMouseCursors = 2,
        ImFontAtlasFlagsNoBakedLines = 4
    }

    [Flags]
    public enum ImGuiViewportFlags
    {
        ImGuiViewportFlagsNone = 0,
        ImGuiViewportFlagsIsPlatformWindow = 1,
        ImGuiViewportFlagsIsPlatformMonitor = 2,
        ImGuiViewportFlagsOwnedByApp = 4
    }

    [Flags]
    public enum ImGuiItemFlags
    {
        ImGuiItemFlagsNone = 0,
        ImGuiItemFlagsNoTabStop = 1,
        ImGuiItemFlagsButtonRepeat = 2,
        ImGuiItemFlagsDisabled = 4,
        ImGuiItemFlagsNoNav = 8,
        ImGuiItemFlagsNoNavDefaultFocus = 16,
        ImGuiItemFlagsSelectableDontClosePopup = 32,
        ImGuiItemFlagsMixedValue = 64,
        ImGuiItemFlagsReadOnly = 128,
        ImGuiItemFlagsInputable = 256
    }

    [Flags]
    public enum ImGuiItemStatusFlags
    {
        ImGuiItemStatusFlagsNone = 0,
        ImGuiItemStatusFlagsHoveredRect = 1,
        ImGuiItemStatusFlagsHasDisplayRect = 2,
        ImGuiItemStatusFlagsEdited = 4,
        ImGuiItemStatusFlagsToggledSelection = 8,
        ImGuiItemStatusFlagsToggledOpen = 16,
        ImGuiItemStatusFlagsHasDeactivated = 32,
        ImGuiItemStatusFlagsDeactivated = 64,
        ImGuiItemStatusFlagsHoveredWindow = 128,
        ImGuiItemStatusFlagsFocusedByTabbing = 256
    }

    [Flags]
    public enum ImGuiInputTextFlagsPrivate
    {
        ImGuiInputTextFlagsMultiline = 67108864,
        ImGuiInputTextFlagsNoMarkEdited = 134217728,
        ImGuiInputTextFlagsMergedItem = 268435456
    }

    public enum ImGuiButtonFlagsPrivate
    {
        ImGuiButtonFlagsPressedOnClick = 16,
        ImGuiButtonFlagsPressedOnClickRelease = 32,
        ImGuiButtonFlagsPressedOnClickReleaseAnywhere = 64,
        ImGuiButtonFlagsPressedOnRelease = 128,
        ImGuiButtonFlagsPressedOnDoubleClick = 256,
        ImGuiButtonFlagsPressedOnDragDropHold = 512,
        ImGuiButtonFlagsRepeat = 1024,
        ImGuiButtonFlagsFlattenChildren = 2048,
        ImGuiButtonFlagsAllowItemOverlap = 4096,
        ImGuiButtonFlagsDontClosePopups = 8192,
        ImGuiButtonFlagsAlignTextBaseLine = 32768,
        ImGuiButtonFlagsNoKeyModifiers = 65536,
        ImGuiButtonFlagsNoHoldingActiveId = 131072,
        ImGuiButtonFlagsNoNavFocus = 262144,
        ImGuiButtonFlagsNoHoveredOnFocus = 524288,
        ImGuiButtonFlagsPressedOnMask = 1008,
        ImGuiButtonFlagsPressedOnDefault = 32
    }

    [Flags]
    public enum ImGuiComboFlagsPrivate
    {
        ImGuiComboFlagsCustomPreview = 1048576
    }

    [Flags]
    public enum ImGuiSliderFlagsPrivate
    {
        ImGuiSliderFlagsVertical = 1048576,
        ImGuiSliderFlagsReadOnly = 2097152
    }

    [Flags]
    public enum ImGuiSelectableFlagsPrivate
    {
        ImGuiSelectableFlagsNoHoldingActiveID = 1048576,
        ImGuiSelectableFlagsSelectOnNav = 2097152,
        ImGuiSelectableFlagsSelectOnClick = 4194304,
        ImGuiSelectableFlagsSelectOnRelease = 8388608,
        ImGuiSelectableFlagsSpanAvailWidth = 16777216,
        ImGuiSelectableFlagsDrawHoveredWhenHeld = 33554432,
        ImGuiSelectableFlagsSetNavIdOnHover = 67108864,
        ImGuiSelectableFlagsNoPadWithHalfSpacing = 134217728
    }

    [Flags]
    public enum ImGuiTreeNodeFlagsPrivate
    {
        ImGuiTreeNodeFlagsClipLabelForTrailingButton = 1048576
    }

    [Flags]
    public enum ImGuiSeparatorFlags
    {
        ImGuiSeparatorFlagsNone = 0,
        ImGuiSeparatorFlagsHorizontal = 1,
        ImGuiSeparatorFlagsVertical = 2,
        ImGuiSeparatorFlagsSpanAllColumns = 4
    }

    public enum ImGuiTextFlags
    {
        ImGuiTextFlagsNone = 0,
        ImGuiTextFlagsNoWidthForLargeClippedText = 1
    }

    public enum ImGuiTooltipFlags
    {
        ImGuiTooltipFlagsNone = 0,
        ImGuiTooltipFlagsOverridePreviousTooltip = 1
    }

    public enum ImGuiLayoutType
    {
        ImGuiLayoutTypeHorizontal = 0,
        ImGuiLayoutTypeVertical = 1
    }

    public enum ImGuiAxis
    {
        ImGuiAxisNone = -1,
        ImGuiAxisX = 0,
        ImGuiAxisY = 1
    }

    public enum ImGuiPlotType
    {
        ImGuiPlotTypeLines = 0,
        ImGuiPlotTypeHistogram = 1
    }

    public enum ImGuiPopupPositionPolicy
    {
        ImGuiPopupPositionPolicyDefault = 0,
        ImGuiPopupPositionPolicyComboBox = 1,
        ImGuiPopupPositionPolicyTooltip = 2
    }

    public enum ImGuiDataTypePrivate
    {
        ImGuiDataTypeString = 11,
        ImGuiDataTypePointer = 12,
        ImGuiDataTypeID = 13
    }

    [Flags]
    public enum ImGuiNextWindowDataFlags
    {
        ImGuiNextWindowDataFlagsNone = 0,
        ImGuiNextWindowDataFlagsHasPos = 1,
        ImGuiNextWindowDataFlagsHasSize = 2,
        ImGuiNextWindowDataFlagsHasContentSize = 4,
        ImGuiNextWindowDataFlagsHasCollapsed = 8,
        ImGuiNextWindowDataFlagsHasSizeConstraint = 16,
        ImGuiNextWindowDataFlagsHasFocus = 32,
        ImGuiNextWindowDataFlagsHasBgAlpha = 64,
        ImGuiNextWindowDataFlagsHasScroll = 128
    }

    public enum ImGuiNextItemDataFlags
    {
        ImGuiNextItemDataFlagsNone = 0,
        ImGuiNextItemDataFlagsHasWidth = 1,
        ImGuiNextItemDataFlagsHasOpen = 2
    }

    public enum ImGuiKeyPrivate
    {
        ImGuiKeyLegacyNativeKeyBEGIN = 0,
        ImGuiKeyLegacyNativeKeyEND = 512,
        ImGuiKeyGamepadBEGIN = 617,
        ImGuiKeyGamepadEND = 641
    }

    public enum ImGuiInputReadMode
    {
        ImGuiInputReadModeDown = 0,
        ImGuiInputReadModePressed = 1,
        ImGuiInputReadModeReleased = 2,
        ImGuiInputReadModeRepeat = 3,
        ImGuiInputReadModeRepeatSlow = 4,
        ImGuiInputReadModeRepeatFast = 5
    }

    [Flags]
    public enum ImGuiActivateFlags
    {
        ImGuiActivateFlagsNone = 0,
        ImGuiActivateFlagsPreferInput = 1,
        ImGuiActivateFlagsPreferTweak = 2,
        ImGuiActivateFlagsTryToPreserveState = 4
    }

    public enum ImGuiScrollFlags
    {
        ImGuiScrollFlagsNone = 0,
        ImGuiScrollFlagsKeepVisibleEdgeX = 1,
        ImGuiScrollFlagsKeepVisibleEdgeY = 2,
        ImGuiScrollFlagsKeepVisibleCenterX = 4,
        ImGuiScrollFlagsKeepVisibleCenterY = 8,
        ImGuiScrollFlagsAlwaysCenterX = 16,
        ImGuiScrollFlagsAlwaysCenterY = 32,
        ImGuiScrollFlagsNoScrollParent = 64,
        ImGuiScrollFlagsMaskX_ = 21,
        ImGuiScrollFlagsMaskY_ = 42
    }

    [Flags]
    public enum ImGuiNavHighlightFlags
    {
        ImGuiNavHighlightFlagsNone = 0,
        ImGuiNavHighlightFlagsTypeDefault = 1,
        ImGuiNavHighlightFlagsTypeThin = 2,
        ImGuiNavHighlightFlagsAlwaysDraw = 4,
        ImGuiNavHighlightFlagsNoRounding = 8
    }

    [Flags]
    public enum ImGuiNavDirSourceFlags
    {
        ImGuiNavDirSourceFlagsNone = 0,
        ImGuiNavDirSourceFlagsRawKeyboard = 1,
        ImGuiNavDirSourceFlagsKeyboard = 2,
        ImGuiNavDirSourceFlagsPadDPad = 4,
        ImGuiNavDirSourceFlagsPadLStick = 8
    }

    [Flags]
    public enum ImGuiNavMoveFlags
    {
        ImGuiNavMoveFlagsNone = 0,
        ImGuiNavMoveFlagsLoopX = 1,
        ImGuiNavMoveFlagsLoopY = 2,
        ImGuiNavMoveFlagsWrapX = 4,
        ImGuiNavMoveFlagsWrapY = 8,
        ImGuiNavMoveFlagsAllowCurrentNavId = 16,
        ImGuiNavMoveFlagsAlsoScoreVisibleSet = 32,
        ImGuiNavMoveFlagsScrollToEdgeY = 64,
        ImGuiNavMoveFlagsForwarded = 128,
        ImGuiNavMoveFlagsDebugNoResult = 256,
        ImGuiNavMoveFlagsFocusApi = 512,
        ImGuiNavMoveFlagsTabbing = 1024,
        ImGuiNavMoveFlagsActivate = 2048,
        ImGuiNavMoveFlagsDontSetNavHighlight = 4096
    }

    [Flags]
    public enum ImGuiOldColumnFlags
    {
        ImGuiOldColumnFlagsNone = 0,
        ImGuiOldColumnFlagsNoBorder = 1,
        ImGuiOldColumnFlagsNoResize = 2,
        ImGuiOldColumnFlagsNoPreserveWidths = 4,
        ImGuiOldColumnFlagsNoForceWithinWindow = 8,
        ImGuiOldColumnFlagsGrowParentContentsSize = 16
    }

    [Flags]
    public enum ImGuiTabBarFlagsPrivate
    {
        ImGuiTabBarFlagsDockNode = 1048576,
        ImGuiTabBarFlagsIsFocused = 2097152,
        ImGuiTabBarFlagsSaveSettings = 4194304
    }

    public enum ImGuiTabItemFlagsPrivate
    {
        ImGuiTabItemFlagsSectionMask = 192,
        ImGuiTabItemFlagsNoCloseButton = 1048576,
        ImGuiTabItemFlagsButton = 2097152
    }

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void ImDrawCallback(__IntPtr parent_list, __IntPtr cmd);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void ImGuiSizeCallback(__IntPtr data);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void ImGuiContextHookCallback(__IntPtr ctx, __IntPtr hook);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate int ImGuiInputTextCallback(__IntPtr data);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate __IntPtr ImGuiMemAllocFunc(IntPtr sz, __IntPtr user_data);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void ImGuiMemFreeFunc(__IntPtr ptr, __IntPtr user_data);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void ImGuiErrorLogCallback(__IntPtr user_data, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

    public unsafe partial class ImVec2 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            public float x;
            public float y;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVec2@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVec2ih_ImVec2ih_Vec2", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr IhImVec2ihVec2(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVec2> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVec2>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVec2 managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVec2 managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVec2 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVec2(native.ToPointer(), skipVTables);
        }

        internal static ImVec2 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVec2)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVec2 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVec2(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVec2(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVec2(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVec2()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVec2.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVec2(global::ImGuiSharp.ImVec2 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVec2.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVec2.__Internal*) __Instance) = *((global::ImGuiSharp.ImVec2.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        public float Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }

        public global::ImGuiSharp.ImVec2ih IhImVec2ihVec2
        {
            get
            {
                var __ret = __Internal.IhImVec2ihVec2(__Instance);
                var __result0 = global::ImGuiSharp.ImVec2ih.__GetOrCreateInstance(__ret, false);
                return __result0;
            }
        }
    }

    public unsafe partial class ImGuiTableColumnsSettings
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiTableColumnsSettings> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiTableColumnsSettings>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiTableColumnsSettings managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiTableColumnsSettings managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiTableColumnsSettings __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTableColumnsSettings(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTableColumnsSettings __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiTableColumnsSettings)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiTableColumnsSettings __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTableColumnsSettings(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTableColumnsSettings(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTableColumnsSettings(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class ImVec4 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public float x;
            public float y;
            public float z;
            public float w;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVec4@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVec4> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVec4>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVec4 managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVec4 managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVec4 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVec4(native.ToPointer(), skipVTables);
        }

        internal static ImVec4 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVec4)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVec4 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVec4(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVec4(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVec4(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVec4()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVec4.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVec4(global::ImGuiSharp.ImVec4 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVec4.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVec4.__Internal*) __Instance) = *((global::ImGuiSharp.ImVec4.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        public float Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }

        public float Z
        {
            get
            {
                return ((__Internal*)__Instance)->z;
            }

            set
            {
                ((__Internal*)__Instance)->z = value;
            }
        }

        public float W
        {
            get
            {
                return ((__Internal*)__Instance)->w;
            }

            set
            {
                ((__Internal*)__Instance)->w = value;
            }
        }
    }

    public unsafe partial class ImGuiStyle : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1048)]
        public partial struct __Internal
        {
            public float Alpha;
            public float DisabledAlpha;
            public global::ImGuiSharp.ImVec2.__Internal WindowPadding;
            public float WindowRounding;
            public float WindowBorderSize;
            public global::ImGuiSharp.ImVec2.__Internal WindowMinSize;
            public global::ImGuiSharp.ImVec2.__Internal WindowTitleAlign;
            public int WindowMenuButtonPosition;
            public float ChildRounding;
            public float ChildBorderSize;
            public float PopupRounding;
            public float PopupBorderSize;
            public global::ImGuiSharp.ImVec2.__Internal FramePadding;
            public float FrameRounding;
            public float FrameBorderSize;
            public global::ImGuiSharp.ImVec2.__Internal ItemSpacing;
            public global::ImGuiSharp.ImVec2.__Internal ItemInnerSpacing;
            public global::ImGuiSharp.ImVec2.__Internal CellPadding;
            public global::ImGuiSharp.ImVec2.__Internal TouchExtraPadding;
            public float IndentSpacing;
            public float ColumnsMinSpacing;
            public float ScrollbarSize;
            public float ScrollbarRounding;
            public float GrabMinSize;
            public float GrabRounding;
            public float LogSliderDeadzone;
            public float TabRounding;
            public float TabBorderSize;
            public float TabMinWidthForCloseButton;
            public int ColorButtonPosition;
            public global::ImGuiSharp.ImVec2.__Internal ButtonTextAlign;
            public global::ImGuiSharp.ImVec2.__Internal SelectableTextAlign;
            public global::ImGuiSharp.ImVec2.__Internal DisplayWindowPadding;
            public global::ImGuiSharp.ImVec2.__Internal DisplaySafeAreaPadding;
            public float MouseCursorScale;
            public byte AntiAliasedLines;
            public byte AntiAliasedLinesUseTex;
            public byte AntiAliasedFill;
            public float CurveTessellationTol;
            public float CircleTessellationMaxError;
            public fixed byte Colors[848];

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiStyle@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiStyle> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiStyle>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiStyle managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiStyle managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiStyle __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiStyle(native.ToPointer(), skipVTables);
        }

        internal static ImGuiStyle __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiStyle)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiStyle __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiStyle(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiStyle(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiStyle(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiStyle()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiStyle.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiStyle(global::ImGuiSharp.ImGuiStyle _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiStyle.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiStyle.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiStyle.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float Alpha
        {
            get
            {
                return ((__Internal*)__Instance)->Alpha;
            }

            set
            {
                ((__Internal*)__Instance)->Alpha = value;
            }
        }

        public float DisabledAlpha
        {
            get
            {
                return ((__Internal*)__Instance)->DisabledAlpha;
            }

            set
            {
                ((__Internal*)__Instance)->DisabledAlpha = value;
            }
        }

        public global::ImGuiSharp.ImVec2 WindowPadding
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WindowPadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WindowPadding = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float WindowRounding
        {
            get
            {
                return ((__Internal*)__Instance)->WindowRounding;
            }

            set
            {
                ((__Internal*)__Instance)->WindowRounding = value;
            }
        }

        public float WindowBorderSize
        {
            get
            {
                return ((__Internal*)__Instance)->WindowBorderSize;
            }

            set
            {
                ((__Internal*)__Instance)->WindowBorderSize = value;
            }
        }

        public global::ImGuiSharp.ImVec2 WindowMinSize
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WindowMinSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WindowMinSize = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 WindowTitleAlign
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WindowTitleAlign));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WindowTitleAlign = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public int WindowMenuButtonPosition
        {
            get
            {
                return ((__Internal*)__Instance)->WindowMenuButtonPosition;
            }

            set
            {
                ((__Internal*)__Instance)->WindowMenuButtonPosition = value;
            }
        }

        public float ChildRounding
        {
            get
            {
                return ((__Internal*)__Instance)->ChildRounding;
            }

            set
            {
                ((__Internal*)__Instance)->ChildRounding = value;
            }
        }

        public float ChildBorderSize
        {
            get
            {
                return ((__Internal*)__Instance)->ChildBorderSize;
            }

            set
            {
                ((__Internal*)__Instance)->ChildBorderSize = value;
            }
        }

        public float PopupRounding
        {
            get
            {
                return ((__Internal*)__Instance)->PopupRounding;
            }

            set
            {
                ((__Internal*)__Instance)->PopupRounding = value;
            }
        }

        public float PopupBorderSize
        {
            get
            {
                return ((__Internal*)__Instance)->PopupBorderSize;
            }

            set
            {
                ((__Internal*)__Instance)->PopupBorderSize = value;
            }
        }

        public global::ImGuiSharp.ImVec2 FramePadding
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->FramePadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->FramePadding = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float FrameRounding
        {
            get
            {
                return ((__Internal*)__Instance)->FrameRounding;
            }

            set
            {
                ((__Internal*)__Instance)->FrameRounding = value;
            }
        }

        public float FrameBorderSize
        {
            get
            {
                return ((__Internal*)__Instance)->FrameBorderSize;
            }

            set
            {
                ((__Internal*)__Instance)->FrameBorderSize = value;
            }
        }

        public global::ImGuiSharp.ImVec2 ItemSpacing
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ItemSpacing));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ItemSpacing = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 ItemInnerSpacing
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ItemInnerSpacing));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ItemInnerSpacing = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 CellPadding
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->CellPadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->CellPadding = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 TouchExtraPadding
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->TouchExtraPadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->TouchExtraPadding = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float IndentSpacing
        {
            get
            {
                return ((__Internal*)__Instance)->IndentSpacing;
            }

            set
            {
                ((__Internal*)__Instance)->IndentSpacing = value;
            }
        }

        public float ColumnsMinSpacing
        {
            get
            {
                return ((__Internal*)__Instance)->ColumnsMinSpacing;
            }

            set
            {
                ((__Internal*)__Instance)->ColumnsMinSpacing = value;
            }
        }

        public float ScrollbarSize
        {
            get
            {
                return ((__Internal*)__Instance)->ScrollbarSize;
            }

            set
            {
                ((__Internal*)__Instance)->ScrollbarSize = value;
            }
        }

        public float ScrollbarRounding
        {
            get
            {
                return ((__Internal*)__Instance)->ScrollbarRounding;
            }

            set
            {
                ((__Internal*)__Instance)->ScrollbarRounding = value;
            }
        }

        public float GrabMinSize
        {
            get
            {
                return ((__Internal*)__Instance)->GrabMinSize;
            }

            set
            {
                ((__Internal*)__Instance)->GrabMinSize = value;
            }
        }

        public float GrabRounding
        {
            get
            {
                return ((__Internal*)__Instance)->GrabRounding;
            }

            set
            {
                ((__Internal*)__Instance)->GrabRounding = value;
            }
        }

        public float LogSliderDeadzone
        {
            get
            {
                return ((__Internal*)__Instance)->LogSliderDeadzone;
            }

            set
            {
                ((__Internal*)__Instance)->LogSliderDeadzone = value;
            }
        }

        public float TabRounding
        {
            get
            {
                return ((__Internal*)__Instance)->TabRounding;
            }

            set
            {
                ((__Internal*)__Instance)->TabRounding = value;
            }
        }

        public float TabBorderSize
        {
            get
            {
                return ((__Internal*)__Instance)->TabBorderSize;
            }

            set
            {
                ((__Internal*)__Instance)->TabBorderSize = value;
            }
        }

        public float TabMinWidthForCloseButton
        {
            get
            {
                return ((__Internal*)__Instance)->TabMinWidthForCloseButton;
            }

            set
            {
                ((__Internal*)__Instance)->TabMinWidthForCloseButton = value;
            }
        }

        public int ColorButtonPosition
        {
            get
            {
                return ((__Internal*)__Instance)->ColorButtonPosition;
            }

            set
            {
                ((__Internal*)__Instance)->ColorButtonPosition = value;
            }
        }

        public global::ImGuiSharp.ImVec2 ButtonTextAlign
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ButtonTextAlign));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ButtonTextAlign = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 SelectableTextAlign
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->SelectableTextAlign));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->SelectableTextAlign = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 DisplayWindowPadding
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DisplayWindowPadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DisplayWindowPadding = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 DisplaySafeAreaPadding
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DisplaySafeAreaPadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DisplaySafeAreaPadding = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float MouseCursorScale
        {
            get
            {
                return ((__Internal*)__Instance)->MouseCursorScale;
            }

            set
            {
                ((__Internal*)__Instance)->MouseCursorScale = value;
            }
        }

        public bool AntiAliasedLines
        {
            get
            {
                return ((__Internal*)__Instance)->AntiAliasedLines != 0;
            }

            set
            {
                ((__Internal*)__Instance)->AntiAliasedLines = (byte) (value ? 1 : 0);
            }
        }

        public bool AntiAliasedLinesUseTex
        {
            get
            {
                return ((__Internal*)__Instance)->AntiAliasedLinesUseTex != 0;
            }

            set
            {
                ((__Internal*)__Instance)->AntiAliasedLinesUseTex = (byte) (value ? 1 : 0);
            }
        }

        public bool AntiAliasedFill
        {
            get
            {
                return ((__Internal*)__Instance)->AntiAliasedFill != 0;
            }

            set
            {
                ((__Internal*)__Instance)->AntiAliasedFill = (byte) (value ? 1 : 0);
            }
        }

        public float CurveTessellationTol
        {
            get
            {
                return ((__Internal*)__Instance)->CurveTessellationTol;
            }

            set
            {
                ((__Internal*)__Instance)->CurveTessellationTol = value;
            }
        }

        public float CircleTessellationMaxError
        {
            get
            {
                return ((__Internal*)__Instance)->CircleTessellationMaxError;
            }

            set
            {
                ((__Internal*)__Instance)->CircleTessellationMaxError = value;
            }
        }

        public global::ImGuiSharp.ImVec4[] Colors
        {
            get
            {
                global::ImGuiSharp.ImVec4[] __value = null;
                if (((__Internal*)__Instance)->Colors != null)
                {
                    __value = new global::ImGuiSharp.ImVec4[53];
                    for (int i = 0; i < 53; i++)
                        __value[i] = global::ImGuiSharp.ImVec4.__GetOrCreateInstance((IntPtr)((global::ImGuiSharp.ImVec4.__Internal*)&(((__Internal*)__Instance)->Colors[i * sizeof(global::ImGuiSharp.ImVec4.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 53)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 53; i++)
                        *(global::ImGuiSharp.ImVec4.__Internal*) &((__Internal*)__Instance)->Colors[i * sizeof(global::ImGuiSharp.ImVec4.__Internal)] = *(global::ImGuiSharp.ImVec4.__Internal*)value[i].__Instance;
                }
            }
        }
    }

    public unsafe partial class ImGuiKeyData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public byte Down;
            public float DownDuration;
            public float DownDurationPrev;
            public float AnalogValue;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiKeyData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiKeyData> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiKeyData>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiKeyData managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiKeyData managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiKeyData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiKeyData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiKeyData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiKeyData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiKeyData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiKeyData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiKeyData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiKeyData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiKeyData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiKeyData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiKeyData(global::ImGuiSharp.ImGuiKeyData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiKeyData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiKeyData.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiKeyData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool Down
        {
            get
            {
                return ((__Internal*)__Instance)->Down != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Down = (byte) (value ? 1 : 0);
            }
        }

        public float DownDuration
        {
            get
            {
                return ((__Internal*)__Instance)->DownDuration;
            }

            set
            {
                ((__Internal*)__Instance)->DownDuration = value;
            }
        }

        public float DownDurationPrev
        {
            get
            {
                return ((__Internal*)__Instance)->DownDurationPrev;
            }

            set
            {
                ((__Internal*)__Instance)->DownDurationPrev = value;
            }
        }

        public float AnalogValue
        {
            get
            {
                return ((__Internal*)__Instance)->AnalogValue;
            }

            set
            {
                ((__Internal*)__Instance)->AnalogValue = value;
            }
        }
    }

    public unsafe partial class ImVectorImWchar : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImWchar@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImWchar> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImWchar>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImWchar managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImWchar managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImWchar __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImWchar(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImWchar __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImWchar)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImWchar __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImWchar(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImWchar(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImWchar(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImWchar()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImWchar.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImWchar(global::ImGuiSharp.ImVectorImWchar _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImWchar.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImWchar.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImWchar.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public ushort* Data
        {
            get
            {
                return (ushort*) ((__Internal*)__Instance)->Data;
            }

            set
            {
                ((__Internal*)__Instance)->Data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImGuiIO : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 14160)]
        public partial struct __Internal
        {
            public int ConfigFlags;
            public int BackendFlags;
            public global::ImGuiSharp.ImVec2.__Internal DisplaySize;
            public float DeltaTime;
            public float IniSavingRate;
            public __IntPtr IniFilename;
            public __IntPtr LogFilename;
            public float MouseDoubleClickTime;
            public float MouseDoubleClickMaxDist;
            public float MouseDragThreshold;
            public float KeyRepeatDelay;
            public float KeyRepeatRate;
            public __IntPtr UserData;
            public __IntPtr Fonts;
            public float FontGlobalScale;
            public byte FontAllowUserScaling;
            public __IntPtr FontDefault;
            public global::ImGuiSharp.ImVec2.__Internal DisplayFramebufferScale;
            public byte MouseDrawCursor;
            public byte ConfigMacOSXBehaviors;
            public byte ConfigInputTrickleEventQueue;
            public byte ConfigInputTextCursorBlink;
            public byte ConfigDragClickToInputText;
            public byte ConfigWindowsResizeFromEdges;
            public byte ConfigWindowsMoveFromTitleBarOnly;
            public float ConfigMemoryCompactTimer;
            public __IntPtr BackendPlatformName;
            public __IntPtr BackendRendererName;
            public __IntPtr BackendPlatformUserData;
            public __IntPtr BackendRendererUserData;
            public __IntPtr BackendLanguageUserData;
            public __IntPtr GetClipboardTextFn;
            public __IntPtr SetClipboardTextFn;
            public __IntPtr ClipboardUserData;
            public __IntPtr SetPlatformImeDataFn;
            public __IntPtr _UnusedPadding;
            public byte WantCaptureMouse;
            public byte WantCaptureKeyboard;
            public byte WantTextInput;
            public byte WantSetMousePos;
            public byte WantSaveIniSettings;
            public byte NavActive;
            public byte NavVisible;
            public float Framerate;
            public int MetricsRenderVertices;
            public int MetricsRenderIndices;
            public int MetricsRenderWindows;
            public int MetricsActiveWindows;
            public int MetricsActiveAllocations;
            public global::ImGuiSharp.ImVec2.__Internal MouseDelta;
            public fixed int KeyMap[645];
            public fixed byte KeysDown[512];
            public global::ImGuiSharp.ImVec2.__Internal MousePos;
            public fixed byte MouseDown[5];
            public float MouseWheel;
            public float MouseWheelH;
            public byte KeyCtrl;
            public byte KeyShift;
            public byte KeyAlt;
            public byte KeySuper;
            public fixed float NavInputs[20];
            public int KeyMods;
            public int KeyModsPrev;
            public fixed byte KeysData[10320];
            public byte WantCaptureMouseUnlessPopupClose;
            public global::ImGuiSharp.ImVec2.__Internal MousePosPrev;
            public fixed byte MouseClickedPos[40];
            public fixed double MouseClickedTime[5];
            public fixed byte MouseClicked[5];
            public fixed byte MouseDoubleClicked[5];
            public fixed ushort MouseClickedCount[5];
            public fixed ushort MouseClickedLastCount[5];
            public fixed byte MouseReleased[5];
            public fixed byte MouseDownOwned[5];
            public fixed byte MouseDownOwnedUnlessPopupClose[5];
            public fixed float MouseDownDuration[5];
            public fixed float MouseDownDurationPrev[5];
            public fixed float MouseDragMaxDistanceSqr[5];
            public fixed float NavInputsDownDuration[20];
            public fixed float NavInputsDownDurationPrev[20];
            public float PenPressure;
            public byte AppFocusLost;
            public sbyte BackendUsingLegacyKeyArrays;
            public byte BackendUsingLegacyNavInputArray;
            public ushort InputQueueSurrogate;
            public global::ImGuiSharp.ImVectorImWchar.__Internal InputQueueCharacters;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiIO@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiIO> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiIO>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiIO managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiIO managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        private bool __IniFilename_OwnsNativeMemory = false;
        private bool __LogFilename_OwnsNativeMemory = false;
        private bool __BackendPlatformName_OwnsNativeMemory = false;
        private bool __BackendRendererName_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static ImGuiIO __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiIO(native.ToPointer(), skipVTables);
        }

        internal static ImGuiIO __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiIO)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiIO __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiIO(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiIO(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiIO(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiIO()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiIO.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiIO(global::ImGuiSharp.ImGuiIO _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiIO.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiIO.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiIO.__Internal*) _0.__Instance);
            if (_0.__IniFilename_OwnsNativeMemory)
                this.IniFilename = _0.IniFilename;
            if (_0.__LogFilename_OwnsNativeMemory)
                this.LogFilename = _0.LogFilename;
            if (_0.__BackendPlatformName_OwnsNativeMemory)
                this.BackendPlatformName = _0.BackendPlatformName;
            if (_0.__BackendRendererName_OwnsNativeMemory)
                this.BackendRendererName = _0.BackendRendererName;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__IniFilename_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->IniFilename);
            if (__LogFilename_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->LogFilename);
            if (__BackendPlatformName_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->BackendPlatformName);
            if (__BackendRendererName_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->BackendRendererName);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int ConfigFlags
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigFlags;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigFlags = value;
            }
        }

        public int BackendFlags
        {
            get
            {
                return ((__Internal*)__Instance)->BackendFlags;
            }

            set
            {
                ((__Internal*)__Instance)->BackendFlags = value;
            }
        }

        public global::ImGuiSharp.ImVec2 DisplaySize
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DisplaySize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DisplaySize = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float DeltaTime
        {
            get
            {
                return ((__Internal*)__Instance)->DeltaTime;
            }

            set
            {
                ((__Internal*)__Instance)->DeltaTime = value;
            }
        }

        public float IniSavingRate
        {
            get
            {
                return ((__Internal*)__Instance)->IniSavingRate;
            }

            set
            {
                ((__Internal*)__Instance)->IniSavingRate = value;
            }
        }

        public string IniFilename
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->IniFilename);
            }

            set
            {
                if (__IniFilename_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->IniFilename);
                __IniFilename_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->IniFilename = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->IniFilename = (__IntPtr) __bytePtr0;
            }
        }

        public string LogFilename
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->LogFilename);
            }

            set
            {
                if (__LogFilename_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->LogFilename);
                __LogFilename_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->LogFilename = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->LogFilename = (__IntPtr) __bytePtr0;
            }
        }

        public float MouseDoubleClickTime
        {
            get
            {
                return ((__Internal*)__Instance)->MouseDoubleClickTime;
            }

            set
            {
                ((__Internal*)__Instance)->MouseDoubleClickTime = value;
            }
        }

        public float MouseDoubleClickMaxDist
        {
            get
            {
                return ((__Internal*)__Instance)->MouseDoubleClickMaxDist;
            }

            set
            {
                ((__Internal*)__Instance)->MouseDoubleClickMaxDist = value;
            }
        }

        public float MouseDragThreshold
        {
            get
            {
                return ((__Internal*)__Instance)->MouseDragThreshold;
            }

            set
            {
                ((__Internal*)__Instance)->MouseDragThreshold = value;
            }
        }

        public float KeyRepeatDelay
        {
            get
            {
                return ((__Internal*)__Instance)->KeyRepeatDelay;
            }

            set
            {
                ((__Internal*)__Instance)->KeyRepeatDelay = value;
            }
        }

        public float KeyRepeatRate
        {
            get
            {
                return ((__Internal*)__Instance)->KeyRepeatRate;
            }

            set
            {
                ((__Internal*)__Instance)->KeyRepeatRate = value;
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->UserData;
            }

            set
            {
                ((__Internal*)__Instance)->UserData = (__IntPtr) value;
            }
        }

        public global::ImGuiSharp.ImFontAtlas Fonts
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImFontAtlas.__GetOrCreateInstance(((__Internal*)__Instance)->Fonts, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Fonts = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public float FontGlobalScale
        {
            get
            {
                return ((__Internal*)__Instance)->FontGlobalScale;
            }

            set
            {
                ((__Internal*)__Instance)->FontGlobalScale = value;
            }
        }

        public bool FontAllowUserScaling
        {
            get
            {
                return ((__Internal*)__Instance)->FontAllowUserScaling != 0;
            }

            set
            {
                ((__Internal*)__Instance)->FontAllowUserScaling = (byte) (value ? 1 : 0);
            }
        }

        public global::ImGuiSharp.ImFont FontDefault
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImFont.__GetOrCreateInstance(((__Internal*)__Instance)->FontDefault, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->FontDefault = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 DisplayFramebufferScale
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DisplayFramebufferScale));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DisplayFramebufferScale = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public bool MouseDrawCursor
        {
            get
            {
                return ((__Internal*)__Instance)->MouseDrawCursor != 0;
            }

            set
            {
                ((__Internal*)__Instance)->MouseDrawCursor = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigMacOSXBehaviors
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigMacOSXBehaviors != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigMacOSXBehaviors = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigInputTrickleEventQueue
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigInputTrickleEventQueue != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigInputTrickleEventQueue = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigInputTextCursorBlink
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigInputTextCursorBlink != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigInputTextCursorBlink = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigDragClickToInputText
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigDragClickToInputText != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigDragClickToInputText = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigWindowsResizeFromEdges
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigWindowsResizeFromEdges != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigWindowsResizeFromEdges = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigWindowsMoveFromTitleBarOnly
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigWindowsMoveFromTitleBarOnly != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigWindowsMoveFromTitleBarOnly = (byte) (value ? 1 : 0);
            }
        }

        public float ConfigMemoryCompactTimer
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigMemoryCompactTimer;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigMemoryCompactTimer = value;
            }
        }

        public string BackendPlatformName
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->BackendPlatformName);
            }

            set
            {
                if (__BackendPlatformName_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->BackendPlatformName);
                __BackendPlatformName_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->BackendPlatformName = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->BackendPlatformName = (__IntPtr) __bytePtr0;
            }
        }

        public string BackendRendererName
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->BackendRendererName);
            }

            set
            {
                if (__BackendRendererName_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->BackendRendererName);
                __BackendRendererName_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->BackendRendererName = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->BackendRendererName = (__IntPtr) __bytePtr0;
            }
        }

        public __IntPtr BackendPlatformUserData
        {
            get
            {
                return ((__Internal*)__Instance)->BackendPlatformUserData;
            }

            set
            {
                ((__Internal*)__Instance)->BackendPlatformUserData = (__IntPtr) value;
            }
        }

        public __IntPtr BackendRendererUserData
        {
            get
            {
                return ((__Internal*)__Instance)->BackendRendererUserData;
            }

            set
            {
                ((__Internal*)__Instance)->BackendRendererUserData = (__IntPtr) value;
            }
        }

        public __IntPtr BackendLanguageUserData
        {
            get
            {
                return ((__Internal*)__Instance)->BackendLanguageUserData;
            }

            set
            {
                ((__Internal*)__Instance)->BackendLanguageUserData = (__IntPtr) value;
            }
        }

        public global::ImGuiSharp.Delegates.Func___IntPtr___IntPtr GetClipboardTextFn
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->GetClipboardTextFn;
                return __ptr0 == IntPtr.Zero? null : (global::ImGuiSharp.Delegates.Func___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ImGuiSharp.Delegates.Func___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->GetClipboardTextFn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::ImGuiSharp.Delegates.Action___IntPtr_string8 SetClipboardTextFn
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->SetClipboardTextFn;
                return __ptr0 == IntPtr.Zero? null : (global::ImGuiSharp.Delegates.Action___IntPtr_string8) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ImGuiSharp.Delegates.Action___IntPtr_string8));
            }

            set
            {
                ((__Internal*)__Instance)->SetClipboardTextFn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr ClipboardUserData
        {
            get
            {
                return ((__Internal*)__Instance)->ClipboardUserData;
            }

            set
            {
                ((__Internal*)__Instance)->ClipboardUserData = (__IntPtr) value;
            }
        }

        public global::ImGuiSharp.Delegates.Action___IntPtr___IntPtr SetPlatformImeDataFn
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->SetPlatformImeDataFn;
                return __ptr0 == IntPtr.Zero? null : (global::ImGuiSharp.Delegates.Action___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ImGuiSharp.Delegates.Action___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->SetPlatformImeDataFn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr UnusedPadding
        {
            get
            {
                return ((__Internal*)__Instance)->_UnusedPadding;
            }

            set
            {
                ((__Internal*)__Instance)->_UnusedPadding = (__IntPtr) value;
            }
        }

        public bool WantCaptureMouse
        {
            get
            {
                return ((__Internal*)__Instance)->WantCaptureMouse != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantCaptureMouse = (byte) (value ? 1 : 0);
            }
        }

        public bool WantCaptureKeyboard
        {
            get
            {
                return ((__Internal*)__Instance)->WantCaptureKeyboard != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantCaptureKeyboard = (byte) (value ? 1 : 0);
            }
        }

        public bool WantTextInput
        {
            get
            {
                return ((__Internal*)__Instance)->WantTextInput != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantTextInput = (byte) (value ? 1 : 0);
            }
        }

        public bool WantSetMousePos
        {
            get
            {
                return ((__Internal*)__Instance)->WantSetMousePos != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantSetMousePos = (byte) (value ? 1 : 0);
            }
        }

        public bool WantSaveIniSettings
        {
            get
            {
                return ((__Internal*)__Instance)->WantSaveIniSettings != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantSaveIniSettings = (byte) (value ? 1 : 0);
            }
        }

        public bool NavActive
        {
            get
            {
                return ((__Internal*)__Instance)->NavActive != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavActive = (byte) (value ? 1 : 0);
            }
        }

        public bool NavVisible
        {
            get
            {
                return ((__Internal*)__Instance)->NavVisible != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavVisible = (byte) (value ? 1 : 0);
            }
        }

        public float Framerate
        {
            get
            {
                return ((__Internal*)__Instance)->Framerate;
            }

            set
            {
                ((__Internal*)__Instance)->Framerate = value;
            }
        }

        public int MetricsRenderVertices
        {
            get
            {
                return ((__Internal*)__Instance)->MetricsRenderVertices;
            }

            set
            {
                ((__Internal*)__Instance)->MetricsRenderVertices = value;
            }
        }

        public int MetricsRenderIndices
        {
            get
            {
                return ((__Internal*)__Instance)->MetricsRenderIndices;
            }

            set
            {
                ((__Internal*)__Instance)->MetricsRenderIndices = value;
            }
        }

        public int MetricsRenderWindows
        {
            get
            {
                return ((__Internal*)__Instance)->MetricsRenderWindows;
            }

            set
            {
                ((__Internal*)__Instance)->MetricsRenderWindows = value;
            }
        }

        public int MetricsActiveWindows
        {
            get
            {
                return ((__Internal*)__Instance)->MetricsActiveWindows;
            }

            set
            {
                ((__Internal*)__Instance)->MetricsActiveWindows = value;
            }
        }

        public int MetricsActiveAllocations
        {
            get
            {
                return ((__Internal*)__Instance)->MetricsActiveAllocations;
            }

            set
            {
                ((__Internal*)__Instance)->MetricsActiveAllocations = value;
            }
        }

        public global::ImGuiSharp.ImVec2 MouseDelta
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->MouseDelta));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->MouseDelta = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public int[] KeyMap
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->KeyMap, 645);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 645; i++)
                        ((__Internal*)__Instance)->KeyMap[i] = value[i];
                }
            }
        }

        public bool[] KeysDown
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<bool>(((__Internal*)__Instance)->KeysDown, 512);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 512; i++)
                        ((__Internal*)__Instance)->KeysDown[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public global::ImGuiSharp.ImVec2 MousePos
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->MousePos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->MousePos = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public bool[] MouseDown
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<bool>(((__Internal*)__Instance)->MouseDown, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseDown[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public float MouseWheel
        {
            get
            {
                return ((__Internal*)__Instance)->MouseWheel;
            }

            set
            {
                ((__Internal*)__Instance)->MouseWheel = value;
            }
        }

        public float MouseWheelH
        {
            get
            {
                return ((__Internal*)__Instance)->MouseWheelH;
            }

            set
            {
                ((__Internal*)__Instance)->MouseWheelH = value;
            }
        }

        public bool KeyCtrl
        {
            get
            {
                return ((__Internal*)__Instance)->KeyCtrl != 0;
            }

            set
            {
                ((__Internal*)__Instance)->KeyCtrl = (byte) (value ? 1 : 0);
            }
        }

        public bool KeyShift
        {
            get
            {
                return ((__Internal*)__Instance)->KeyShift != 0;
            }

            set
            {
                ((__Internal*)__Instance)->KeyShift = (byte) (value ? 1 : 0);
            }
        }

        public bool KeyAlt
        {
            get
            {
                return ((__Internal*)__Instance)->KeyAlt != 0;
            }

            set
            {
                ((__Internal*)__Instance)->KeyAlt = (byte) (value ? 1 : 0);
            }
        }

        public bool KeySuper
        {
            get
            {
                return ((__Internal*)__Instance)->KeySuper != 0;
            }

            set
            {
                ((__Internal*)__Instance)->KeySuper = (byte) (value ? 1 : 0);
            }
        }

        public float[] NavInputs
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->NavInputs, 20);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 20; i++)
                        ((__Internal*)__Instance)->NavInputs[i] = value[i];
                }
            }
        }

        public int KeyMods
        {
            get
            {
                return ((__Internal*)__Instance)->KeyMods;
            }

            set
            {
                ((__Internal*)__Instance)->KeyMods = value;
            }
        }

        public int KeyModsPrev
        {
            get
            {
                return ((__Internal*)__Instance)->KeyModsPrev;
            }

            set
            {
                ((__Internal*)__Instance)->KeyModsPrev = value;
            }
        }

        public global::ImGuiSharp.ImGuiKeyData[] KeysData
        {
            get
            {
                global::ImGuiSharp.ImGuiKeyData[] __value = null;
                if (((__Internal*)__Instance)->KeysData != null)
                {
                    __value = new global::ImGuiSharp.ImGuiKeyData[645];
                    for (int i = 0; i < 645; i++)
                        __value[i] = global::ImGuiSharp.ImGuiKeyData.__GetOrCreateInstance((IntPtr)((global::ImGuiSharp.ImGuiKeyData.__Internal*)&(((__Internal*)__Instance)->KeysData[i * sizeof(global::ImGuiSharp.ImGuiKeyData.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 645)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 645; i++)
                        *(global::ImGuiSharp.ImGuiKeyData.__Internal*) &((__Internal*)__Instance)->KeysData[i * sizeof(global::ImGuiSharp.ImGuiKeyData.__Internal)] = *(global::ImGuiSharp.ImGuiKeyData.__Internal*)value[i].__Instance;
                }
            }
        }

        public bool WantCaptureMouseUnlessPopupClose
        {
            get
            {
                return ((__Internal*)__Instance)->WantCaptureMouseUnlessPopupClose != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantCaptureMouseUnlessPopupClose = (byte) (value ? 1 : 0);
            }
        }

        public global::ImGuiSharp.ImVec2 MousePosPrev
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->MousePosPrev));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->MousePosPrev = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2[] MouseClickedPos
        {
            get
            {
                global::ImGuiSharp.ImVec2[] __value = null;
                if (((__Internal*)__Instance)->MouseClickedPos != null)
                {
                    __value = new global::ImGuiSharp.ImVec2[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = global::ImGuiSharp.ImVec2.__GetOrCreateInstance((IntPtr)((global::ImGuiSharp.ImVec2.__Internal*)&(((__Internal*)__Instance)->MouseClickedPos[i * sizeof(global::ImGuiSharp.ImVec2.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 5)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 5; i++)
                        *(global::ImGuiSharp.ImVec2.__Internal*) &((__Internal*)__Instance)->MouseClickedPos[i * sizeof(global::ImGuiSharp.ImVec2.__Internal)] = *(global::ImGuiSharp.ImVec2.__Internal*)value[i].__Instance;
                }
            }
        }

        public double[] MouseClickedTime
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<double>(((__Internal*)__Instance)->MouseClickedTime, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseClickedTime[i] = value[i];
                }
            }
        }

        public bool[] MouseClicked
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<bool>(((__Internal*)__Instance)->MouseClicked, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseClicked[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public bool[] MouseDoubleClicked
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<bool>(((__Internal*)__Instance)->MouseDoubleClicked, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseDoubleClicked[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public ushort[] MouseClickedCount
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<ushort>(((__Internal*)__Instance)->MouseClickedCount, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseClickedCount[i] = value[i];
                }
            }
        }

        public ushort[] MouseClickedLastCount
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<ushort>(((__Internal*)__Instance)->MouseClickedLastCount, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseClickedLastCount[i] = value[i];
                }
            }
        }

        public bool[] MouseReleased
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<bool>(((__Internal*)__Instance)->MouseReleased, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseReleased[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public bool[] MouseDownOwned
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<bool>(((__Internal*)__Instance)->MouseDownOwned, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseDownOwned[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public bool[] MouseDownOwnedUnlessPopupClose
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<bool>(((__Internal*)__Instance)->MouseDownOwnedUnlessPopupClose, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseDownOwnedUnlessPopupClose[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public float[] MouseDownDuration
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->MouseDownDuration, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseDownDuration[i] = value[i];
                }
            }
        }

        public float[] MouseDownDurationPrev
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->MouseDownDurationPrev, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseDownDurationPrev[i] = value[i];
                }
            }
        }

        public float[] MouseDragMaxDistanceSqr
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->MouseDragMaxDistanceSqr, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseDragMaxDistanceSqr[i] = value[i];
                }
            }
        }

        public float[] NavInputsDownDuration
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->NavInputsDownDuration, 20);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 20; i++)
                        ((__Internal*)__Instance)->NavInputsDownDuration[i] = value[i];
                }
            }
        }

        public float[] NavInputsDownDurationPrev
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->NavInputsDownDurationPrev, 20);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 20; i++)
                        ((__Internal*)__Instance)->NavInputsDownDurationPrev[i] = value[i];
                }
            }
        }

        public float PenPressure
        {
            get
            {
                return ((__Internal*)__Instance)->PenPressure;
            }

            set
            {
                ((__Internal*)__Instance)->PenPressure = value;
            }
        }

        public bool AppFocusLost
        {
            get
            {
                return ((__Internal*)__Instance)->AppFocusLost != 0;
            }

            set
            {
                ((__Internal*)__Instance)->AppFocusLost = (byte) (value ? 1 : 0);
            }
        }

        public sbyte BackendUsingLegacyKeyArrays
        {
            get
            {
                return ((__Internal*)__Instance)->BackendUsingLegacyKeyArrays;
            }

            set
            {
                ((__Internal*)__Instance)->BackendUsingLegacyKeyArrays = value;
            }
        }

        public bool BackendUsingLegacyNavInputArray
        {
            get
            {
                return ((__Internal*)__Instance)->BackendUsingLegacyNavInputArray != 0;
            }

            set
            {
                ((__Internal*)__Instance)->BackendUsingLegacyNavInputArray = (byte) (value ? 1 : 0);
            }
        }

        public ushort InputQueueSurrogate
        {
            get
            {
                return ((__Internal*)__Instance)->InputQueueSurrogate;
            }

            set
            {
                ((__Internal*)__Instance)->InputQueueSurrogate = value;
            }
        }

        public global::ImGuiSharp.ImVectorImWchar InputQueueCharacters
        {
            get
            {
                return global::ImGuiSharp.ImVectorImWchar.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->InputQueueCharacters));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->InputQueueCharacters = *(global::ImGuiSharp.ImVectorImWchar.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiInputTextCallbackData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            public int EventFlag;
            public int Flags;
            public __IntPtr UserData;
            public ushort EventChar;
            public int EventKey;
            public __IntPtr Buf;
            public int BufTextLen;
            public int BufSize;
            public byte BufDirty;
            public int CursorPos;
            public int SelectionStart;
            public int SelectionEnd;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiInputTextCallbackData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiInputTextCallbackData> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiInputTextCallbackData>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiInputTextCallbackData managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiInputTextCallbackData managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiInputTextCallbackData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiInputTextCallbackData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiInputTextCallbackData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiInputTextCallbackData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiInputTextCallbackData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiInputTextCallbackData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiInputTextCallbackData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputTextCallbackData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiInputTextCallbackData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiInputTextCallbackData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputTextCallbackData(global::ImGuiSharp.ImGuiInputTextCallbackData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiInputTextCallbackData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiInputTextCallbackData.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiInputTextCallbackData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int EventFlag
        {
            get
            {
                return ((__Internal*)__Instance)->EventFlag;
            }

            set
            {
                ((__Internal*)__Instance)->EventFlag = value;
            }
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->UserData;
            }

            set
            {
                ((__Internal*)__Instance)->UserData = (__IntPtr) value;
            }
        }

        public ushort EventChar
        {
            get
            {
                return ((__Internal*)__Instance)->EventChar;
            }

            set
            {
                ((__Internal*)__Instance)->EventChar = value;
            }
        }

        public int EventKey
        {
            get
            {
                return ((__Internal*)__Instance)->EventKey;
            }

            set
            {
                ((__Internal*)__Instance)->EventKey = value;
            }
        }

        public sbyte* Buf
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->Buf;
            }

            set
            {
                ((__Internal*)__Instance)->Buf = (__IntPtr) value;
            }
        }

        public int BufTextLen
        {
            get
            {
                return ((__Internal*)__Instance)->BufTextLen;
            }

            set
            {
                ((__Internal*)__Instance)->BufTextLen = value;
            }
        }

        public int BufSize
        {
            get
            {
                return ((__Internal*)__Instance)->BufSize;
            }

            set
            {
                ((__Internal*)__Instance)->BufSize = value;
            }
        }

        public bool BufDirty
        {
            get
            {
                return ((__Internal*)__Instance)->BufDirty != 0;
            }

            set
            {
                ((__Internal*)__Instance)->BufDirty = (byte) (value ? 1 : 0);
            }
        }

        public int CursorPos
        {
            get
            {
                return ((__Internal*)__Instance)->CursorPos;
            }

            set
            {
                ((__Internal*)__Instance)->CursorPos = value;
            }
        }

        public int SelectionStart
        {
            get
            {
                return ((__Internal*)__Instance)->SelectionStart;
            }

            set
            {
                ((__Internal*)__Instance)->SelectionStart = value;
            }
        }

        public int SelectionEnd
        {
            get
            {
                return ((__Internal*)__Instance)->SelectionEnd;
            }

            set
            {
                ((__Internal*)__Instance)->SelectionEnd = value;
            }
        }
    }

    public unsafe partial class ImGuiSizeCallbackData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            public __IntPtr UserData;
            public global::ImGuiSharp.ImVec2.__Internal Pos;
            public global::ImGuiSharp.ImVec2.__Internal CurrentSize;
            public global::ImGuiSharp.ImVec2.__Internal DesiredSize;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiSizeCallbackData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiSizeCallbackData> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiSizeCallbackData>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiSizeCallbackData managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiSizeCallbackData managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiSizeCallbackData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiSizeCallbackData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiSizeCallbackData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiSizeCallbackData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiSizeCallbackData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiSizeCallbackData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiSizeCallbackData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiSizeCallbackData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiSizeCallbackData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiSizeCallbackData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiSizeCallbackData(global::ImGuiSharp.ImGuiSizeCallbackData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiSizeCallbackData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiSizeCallbackData.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiSizeCallbackData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->UserData;
            }

            set
            {
                ((__Internal*)__Instance)->UserData = (__IntPtr) value;
            }
        }

        public global::ImGuiSharp.ImVec2 Pos
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Pos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Pos = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 CurrentSize
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->CurrentSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->CurrentSize = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 DesiredSize
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DesiredSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DesiredSize = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiPayload : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            public __IntPtr Data;
            public int DataSize;
            public uint SourceId;
            public uint SourceParentId;
            public int DataFrameCount;
            public fixed sbyte DataType[33];
            public byte Preview;
            public byte Delivery;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiPayload@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiPayload> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiPayload>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiPayload managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiPayload managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiPayload __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiPayload(native.ToPointer(), skipVTables);
        }

        internal static ImGuiPayload __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiPayload)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiPayload __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiPayload(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiPayload(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiPayload(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiPayload()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiPayload.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiPayload(global::ImGuiSharp.ImGuiPayload _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiPayload.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiPayload.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiPayload.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr Data
        {
            get
            {
                return ((__Internal*)__Instance)->Data;
            }

            set
            {
                ((__Internal*)__Instance)->Data = (__IntPtr) value;
            }
        }

        public int DataSize
        {
            get
            {
                return ((__Internal*)__Instance)->DataSize;
            }

            set
            {
                ((__Internal*)__Instance)->DataSize = value;
            }
        }

        public uint SourceId
        {
            get
            {
                return ((__Internal*)__Instance)->SourceId;
            }

            set
            {
                ((__Internal*)__Instance)->SourceId = value;
            }
        }

        public uint SourceParentId
        {
            get
            {
                return ((__Internal*)__Instance)->SourceParentId;
            }

            set
            {
                ((__Internal*)__Instance)->SourceParentId = value;
            }
        }

        public int DataFrameCount
        {
            get
            {
                return ((__Internal*)__Instance)->DataFrameCount;
            }

            set
            {
                ((__Internal*)__Instance)->DataFrameCount = value;
            }
        }

        public sbyte[] DataType
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->DataType, 33);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 33; i++)
                        ((__Internal*)__Instance)->DataType[i] = value[i];
                }
            }
        }

        public bool Preview
        {
            get
            {
                return ((__Internal*)__Instance)->Preview != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Preview = (byte) (value ? 1 : 0);
            }
        }

        public bool Delivery
        {
            get
            {
                return ((__Internal*)__Instance)->Delivery != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Delivery = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImGuiTableColumnSortSpecs : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            public uint ColumnUserID;
            public short ColumnIndex;
            public short SortOrder;
            public int SortDirection;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiTableColumnSortSpecs@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiTableColumnSortSpecs> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiTableColumnSortSpecs>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiTableColumnSortSpecs managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiTableColumnSortSpecs managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiTableColumnSortSpecs __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTableColumnSortSpecs(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTableColumnSortSpecs __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiTableColumnSortSpecs)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiTableColumnSortSpecs __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTableColumnSortSpecs(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTableColumnSortSpecs(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTableColumnSortSpecs(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTableColumnSortSpecs()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiTableColumnSortSpecs.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTableColumnSortSpecs(global::ImGuiSharp.ImGuiTableColumnSortSpecs _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiTableColumnSortSpecs.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiTableColumnSortSpecs.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiTableColumnSortSpecs.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ColumnUserID
        {
            get
            {
                return ((__Internal*)__Instance)->ColumnUserID;
            }

            set
            {
                ((__Internal*)__Instance)->ColumnUserID = value;
            }
        }

        public short ColumnIndex
        {
            get
            {
                return ((__Internal*)__Instance)->ColumnIndex;
            }

            set
            {
                ((__Internal*)__Instance)->ColumnIndex = value;
            }
        }

        public short SortOrder
        {
            get
            {
                return ((__Internal*)__Instance)->SortOrder;
            }

            set
            {
                ((__Internal*)__Instance)->SortOrder = value;
            }
        }

        public int SortDirection
        {
            get
            {
                return ((__Internal*)__Instance)->SortDirection;
            }

            set
            {
                ((__Internal*)__Instance)->SortDirection = value;
            }
        }
    }

    public unsafe partial class ImGuiTableSortSpecs : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public __IntPtr Specs;
            public int SpecsCount;
            public byte SpecsDirty;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiTableSortSpecs@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiTableSortSpecs> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiTableSortSpecs>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiTableSortSpecs managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiTableSortSpecs managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiTableSortSpecs __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTableSortSpecs(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTableSortSpecs __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiTableSortSpecs)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiTableSortSpecs __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTableSortSpecs(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTableSortSpecs(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTableSortSpecs(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTableSortSpecs()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiTableSortSpecs.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTableSortSpecs(global::ImGuiSharp.ImGuiTableSortSpecs _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiTableSortSpecs.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiTableSortSpecs.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiTableSortSpecs.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGuiSharp.ImGuiTableColumnSortSpecs Specs
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiTableColumnSortSpecs.__GetOrCreateInstance(((__Internal*)__Instance)->Specs, false);
                return __result0;
            }
        }

        public int SpecsCount
        {
            get
            {
                return ((__Internal*)__Instance)->SpecsCount;
            }

            set
            {
                ((__Internal*)__Instance)->SpecsCount = value;
            }
        }

        public bool SpecsDirty
        {
            get
            {
                return ((__Internal*)__Instance)->SpecsDirty != 0;
            }

            set
            {
                ((__Internal*)__Instance)->SpecsDirty = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImGuiOnceUponAFrame : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            public int RefFrame;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiOnceUponAFrame@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiOnceUponAFrame> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiOnceUponAFrame>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiOnceUponAFrame managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiOnceUponAFrame managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiOnceUponAFrame __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiOnceUponAFrame(native.ToPointer(), skipVTables);
        }

        internal static ImGuiOnceUponAFrame __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiOnceUponAFrame)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiOnceUponAFrame __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiOnceUponAFrame(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiOnceUponAFrame(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiOnceUponAFrame(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiOnceUponAFrame()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiOnceUponAFrame.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiOnceUponAFrame(global::ImGuiSharp.ImGuiOnceUponAFrame _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiOnceUponAFrame.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiOnceUponAFrame.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiOnceUponAFrame.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int RefFrame
        {
            get
            {
                return ((__Internal*)__Instance)->RefFrame;
            }

            set
            {
                ((__Internal*)__Instance)->RefFrame = value;
            }
        }
    }

    public unsafe partial class ImGuiTextRange : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public __IntPtr b;
            public __IntPtr e;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiTextRange@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiTextRange> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiTextRange>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiTextRange managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiTextRange managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        private bool __b_OwnsNativeMemory = false;
        private bool __e_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static ImGuiTextRange __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTextRange(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTextRange __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiTextRange)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiTextRange __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTextRange(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTextRange(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTextRange(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTextRange()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiTextRange.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTextRange(global::ImGuiSharp.ImGuiTextRange _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiTextRange.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiTextRange.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiTextRange.__Internal*) _0.__Instance);
            if (_0.__b_OwnsNativeMemory)
                this.B = _0.B;
            if (_0.__e_OwnsNativeMemory)
                this.E = _0.E;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__b_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->b);
            if (__e_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->e);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string B
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->b);
            }

            set
            {
                if (__b_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->b);
                __b_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->b = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->b = (__IntPtr) __bytePtr0;
            }
        }

        public string E
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->e);
            }

            set
            {
                if (__e_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->e);
                __e_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->e = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->e = (__IntPtr) __bytePtr0;
            }
        }
    }

    public unsafe partial class ImVectorImGuiTextRange : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiTextRange@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiTextRange> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiTextRange>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImGuiTextRange managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImGuiTextRange managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiTextRange __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiTextRange(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiTextRange __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiTextRange)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiTextRange __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiTextRange(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiTextRange(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiTextRange(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiTextRange()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiTextRange.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiTextRange(global::ImGuiSharp.ImVectorImGuiTextRange _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiTextRange.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImGuiTextRange.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImGuiTextRange.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImGuiTextRange Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiTextRange.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiTextFilter : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 280)]
        public partial struct __Internal
        {
            public fixed sbyte InputBuf[256];
            public global::ImGuiSharp.ImVectorImGuiTextRange.__Internal Filters;
            public int CountGrep;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiTextFilter@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiTextFilter> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiTextFilter>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiTextFilter managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiTextFilter managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiTextFilter __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTextFilter(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTextFilter __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiTextFilter)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiTextFilter __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTextFilter(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTextFilter(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTextFilter(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTextFilter()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiTextFilter.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTextFilter(global::ImGuiSharp.ImGuiTextFilter _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiTextFilter.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiTextFilter.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiTextFilter.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte[] InputBuf
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->InputBuf, 256);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 256; i++)
                        ((__Internal*)__Instance)->InputBuf[i] = value[i];
                }
            }
        }

        public global::ImGuiSharp.ImVectorImGuiTextRange Filters
        {
            get
            {
                return global::ImGuiSharp.ImVectorImGuiTextRange.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Filters));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Filters = *(global::ImGuiSharp.ImVectorImGuiTextRange.__Internal*) value.__Instance;
            }
        }

        public int CountGrep
        {
            get
            {
                return ((__Internal*)__Instance)->CountGrep;
            }

            set
            {
                ((__Internal*)__Instance)->CountGrep = value;
            }
        }
    }

    public unsafe partial class ImVector_char : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_char@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVector_char> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVector_char>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVector_char managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVector_char managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVector_char __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVector_char(native.ToPointer(), skipVTables);
        }

        internal static ImVector_char __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVector_char)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVector_char __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVector_char(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVector_char(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVector_char(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVector_char()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVector_char.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVector_char(global::ImGuiSharp.ImVector_char _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVector_char.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVector_char.__Internal*) __Instance) = *((global::ImGuiSharp.ImVector_char.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public sbyte* Data
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->Data;
            }

            set
            {
                ((__Internal*)__Instance)->Data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImGuiTextBuffer : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public global::ImGuiSharp.ImVector_char.__Internal Buf;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiTextBuffer@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextBuffer_appendf", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Appendf(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiTextBuffer> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiTextBuffer>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiTextBuffer managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiTextBuffer managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiTextBuffer __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTextBuffer(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTextBuffer __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiTextBuffer)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiTextBuffer __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTextBuffer(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTextBuffer(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTextBuffer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTextBuffer()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiTextBuffer.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTextBuffer(global::ImGuiSharp.ImGuiTextBuffer _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiTextBuffer.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiTextBuffer.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiTextBuffer.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Appendf(string fmt)
        {
            __Internal.Appendf(__Instance, fmt);
        }

        public global::ImGuiSharp.ImVector_char Buf
        {
            get
            {
                return global::ImGuiSharp.ImVector_char.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Buf));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Buf = *(global::ImGuiSharp.ImVector_char.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiStoragePair : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public uint key;

            [FieldOffset(8)]
            public int val_i;

            [FieldOffset(8)]
            public float val_f;

            [FieldOffset(8)]
            public __IntPtr val_p;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiStoragePair@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiStoragePair> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiStoragePair>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiStoragePair managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiStoragePair managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiStoragePair __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiStoragePair(native.ToPointer(), skipVTables);
        }

        internal static ImGuiStoragePair __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiStoragePair)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiStoragePair __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiStoragePair(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiStoragePair(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiStoragePair(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiStoragePair()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiStoragePair.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiStoragePair(global::ImGuiSharp.ImGuiStoragePair _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiStoragePair.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiStoragePair.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiStoragePair.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Key
        {
            get
            {
                return ((__Internal*)__Instance)->key;
            }

            set
            {
                ((__Internal*)__Instance)->key = value;
            }
        }

        public int ValI
        {
            get
            {
                return ((__Internal*)__Instance)->val_i;
            }

            set
            {
                ((__Internal*)__Instance)->val_i = value;
            }
        }

        public float ValF
        {
            get
            {
                return ((__Internal*)__Instance)->val_f;
            }

            set
            {
                ((__Internal*)__Instance)->val_f = value;
            }
        }

        public __IntPtr ValP
        {
            get
            {
                return ((__Internal*)__Instance)->val_p;
            }

            set
            {
                ((__Internal*)__Instance)->val_p = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImVectorImGuiStoragePair : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiStoragePair@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiStoragePair> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiStoragePair>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImGuiStoragePair managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImGuiStoragePair managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiStoragePair __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiStoragePair(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiStoragePair __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiStoragePair)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiStoragePair __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiStoragePair(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiStoragePair(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiStoragePair(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiStoragePair()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiStoragePair.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiStoragePair(global::ImGuiSharp.ImVectorImGuiStoragePair _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiStoragePair.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImGuiStoragePair.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImGuiStoragePair.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImGuiStoragePair Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiStoragePair.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiStorage : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public global::ImGuiSharp.ImVectorImGuiStoragePair.__Internal Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiStorage@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiStorage> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiStorage>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiStorage managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiStorage managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiStorage __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiStorage(native.ToPointer(), skipVTables);
        }

        internal static ImGuiStorage __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiStorage)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiStorage __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiStorage(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiStorage(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiStorage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiStorage()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiStorage.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiStorage(global::ImGuiSharp.ImGuiStorage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiStorage.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiStorage.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiStorage.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGuiSharp.ImVectorImGuiStoragePair Data
        {
            get
            {
                return global::ImGuiSharp.ImVectorImGuiStoragePair.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Data));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Data = *(global::ImGuiSharp.ImVectorImGuiStoragePair.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiListClipper : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            public int DisplayStart;
            public int DisplayEnd;
            public int ItemsCount;
            public float ItemsHeight;
            public float StartPosY;
            public __IntPtr TempData;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiListClipper@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiListClipper> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiListClipper>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiListClipper managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiListClipper managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiListClipper __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiListClipper(native.ToPointer(), skipVTables);
        }

        internal static ImGuiListClipper __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiListClipper)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiListClipper __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiListClipper(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiListClipper(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiListClipper(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiListClipper()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiListClipper.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiListClipper(global::ImGuiSharp.ImGuiListClipper _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiListClipper.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiListClipper.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiListClipper.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int DisplayStart
        {
            get
            {
                return ((__Internal*)__Instance)->DisplayStart;
            }

            set
            {
                ((__Internal*)__Instance)->DisplayStart = value;
            }
        }

        public int DisplayEnd
        {
            get
            {
                return ((__Internal*)__Instance)->DisplayEnd;
            }

            set
            {
                ((__Internal*)__Instance)->DisplayEnd = value;
            }
        }

        public int ItemsCount
        {
            get
            {
                return ((__Internal*)__Instance)->ItemsCount;
            }

            set
            {
                ((__Internal*)__Instance)->ItemsCount = value;
            }
        }

        public float ItemsHeight
        {
            get
            {
                return ((__Internal*)__Instance)->ItemsHeight;
            }

            set
            {
                ((__Internal*)__Instance)->ItemsHeight = value;
            }
        }

        public float StartPosY
        {
            get
            {
                return ((__Internal*)__Instance)->StartPosY;
            }

            set
            {
                ((__Internal*)__Instance)->StartPosY = value;
            }
        }

        public __IntPtr TempData
        {
            get
            {
                return ((__Internal*)__Instance)->TempData;
            }

            set
            {
                ((__Internal*)__Instance)->TempData = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImColor : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public global::ImGuiSharp.ImVec4.__Internal Value;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImColor@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImColor> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImColor>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImColor managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImColor managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImColor __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImColor(native.ToPointer(), skipVTables);
        }

        internal static ImColor __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImColor)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImColor __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImColor(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImColor(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImColor(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImColor()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImColor.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImColor(global::ImGuiSharp.ImColor _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImColor.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImColor.__Internal*) __Instance) = *((global::ImGuiSharp.ImColor.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGuiSharp.ImVec4 Value
        {
            get
            {
                return global::ImGuiSharp.ImVec4.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Value));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Value = *(global::ImGuiSharp.ImVec4.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImDrawCmd : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            public global::ImGuiSharp.ImVec4.__Internal ClipRect;
            public __IntPtr TextureId;
            public uint VtxOffset;
            public uint IdxOffset;
            public uint ElemCount;
            public __IntPtr UserCallback;
            public __IntPtr UserCallbackData;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImDrawCmd@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImDrawCmd> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImDrawCmd>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImDrawCmd managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImDrawCmd managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImDrawCmd __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawCmd(native.ToPointer(), skipVTables);
        }

        internal static ImDrawCmd __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImDrawCmd)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImDrawCmd __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawCmd(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawCmd(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawCmd(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImDrawCmd()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImDrawCmd.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawCmd(global::ImGuiSharp.ImDrawCmd _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImDrawCmd.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImDrawCmd.__Internal*) __Instance) = *((global::ImGuiSharp.ImDrawCmd.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGuiSharp.ImVec4 ClipRect
        {
            get
            {
                return global::ImGuiSharp.ImVec4.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ClipRect = *(global::ImGuiSharp.ImVec4.__Internal*) value.__Instance;
            }
        }

        public __IntPtr TextureId
        {
            get
            {
                return ((__Internal*)__Instance)->TextureId;
            }

            set
            {
                ((__Internal*)__Instance)->TextureId = (__IntPtr) value;
            }
        }

        public uint VtxOffset
        {
            get
            {
                return ((__Internal*)__Instance)->VtxOffset;
            }

            set
            {
                ((__Internal*)__Instance)->VtxOffset = value;
            }
        }

        public uint IdxOffset
        {
            get
            {
                return ((__Internal*)__Instance)->IdxOffset;
            }

            set
            {
                ((__Internal*)__Instance)->IdxOffset = value;
            }
        }

        public uint ElemCount
        {
            get
            {
                return ((__Internal*)__Instance)->ElemCount;
            }

            set
            {
                ((__Internal*)__Instance)->ElemCount = value;
            }
        }

        public global::ImGuiSharp.ImDrawCallback UserCallback
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->UserCallback;
                return __ptr0 == IntPtr.Zero? null : (global::ImGuiSharp.ImDrawCallback) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ImGuiSharp.ImDrawCallback));
            }

            set
            {
                ((__Internal*)__Instance)->UserCallback = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr UserCallbackData
        {
            get
            {
                return ((__Internal*)__Instance)->UserCallbackData;
            }

            set
            {
                ((__Internal*)__Instance)->UserCallbackData = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImDrawVert : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 20)]
        public partial struct __Internal
        {
            public global::ImGuiSharp.ImVec2.__Internal pos;
            public global::ImGuiSharp.ImVec2.__Internal uv;
            public uint col;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImDrawVert@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImDrawVert> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImDrawVert>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImDrawVert managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImDrawVert managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImDrawVert __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawVert(native.ToPointer(), skipVTables);
        }

        internal static ImDrawVert __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImDrawVert)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImDrawVert __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawVert(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawVert(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawVert(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImDrawVert()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImDrawVert.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawVert(global::ImGuiSharp.ImDrawVert _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImDrawVert.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImDrawVert.__Internal*) __Instance) = *((global::ImGuiSharp.ImDrawVert.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGuiSharp.ImVec2 Pos
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->pos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->pos = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 Uv
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->uv));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->uv = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public uint Col
        {
            get
            {
                return ((__Internal*)__Instance)->col;
            }

            set
            {
                ((__Internal*)__Instance)->col = value;
            }
        }
    }

    public unsafe partial class ImDrawCmdHeader : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            public global::ImGuiSharp.ImVec4.__Internal ClipRect;
            public __IntPtr TextureId;
            public uint VtxOffset;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImDrawCmdHeader@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImDrawCmdHeader> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImDrawCmdHeader>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImDrawCmdHeader managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImDrawCmdHeader managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImDrawCmdHeader __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawCmdHeader(native.ToPointer(), skipVTables);
        }

        internal static ImDrawCmdHeader __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImDrawCmdHeader)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImDrawCmdHeader __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawCmdHeader(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawCmdHeader(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawCmdHeader(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImDrawCmdHeader()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImDrawCmdHeader.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawCmdHeader(global::ImGuiSharp.ImDrawCmdHeader _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImDrawCmdHeader.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImDrawCmdHeader.__Internal*) __Instance) = *((global::ImGuiSharp.ImDrawCmdHeader.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGuiSharp.ImVec4 ClipRect
        {
            get
            {
                return global::ImGuiSharp.ImVec4.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ClipRect = *(global::ImGuiSharp.ImVec4.__Internal*) value.__Instance;
            }
        }

        public __IntPtr TextureId
        {
            get
            {
                return ((__Internal*)__Instance)->TextureId;
            }

            set
            {
                ((__Internal*)__Instance)->TextureId = (__IntPtr) value;
            }
        }

        public uint VtxOffset
        {
            get
            {
                return ((__Internal*)__Instance)->VtxOffset;
            }

            set
            {
                ((__Internal*)__Instance)->VtxOffset = value;
            }
        }
    }

    public unsafe partial class ImVectorImDrawCmd : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImDrawCmd@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImDrawCmd> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImDrawCmd>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImDrawCmd managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImDrawCmd managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImDrawCmd __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImDrawCmd(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImDrawCmd __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImDrawCmd)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImDrawCmd __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImDrawCmd(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImDrawCmd(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImDrawCmd(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImDrawCmd()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImDrawCmd.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImDrawCmd(global::ImGuiSharp.ImVectorImDrawCmd _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImDrawCmd.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImDrawCmd.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImDrawCmd.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImDrawCmd Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImDrawCmd.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImDrawIdx : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImDrawIdx@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImDrawIdx> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImDrawIdx>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImDrawIdx managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImDrawIdx managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImDrawIdx __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImDrawIdx(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImDrawIdx __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImDrawIdx)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImDrawIdx __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImDrawIdx(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImDrawIdx(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImDrawIdx(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImDrawIdx()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImDrawIdx.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImDrawIdx(global::ImGuiSharp.ImVectorImDrawIdx _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImDrawIdx.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImDrawIdx.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImDrawIdx.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public ushort* Data
        {
            get
            {
                return (ushort*) ((__Internal*)__Instance)->Data;
            }

            set
            {
                ((__Internal*)__Instance)->Data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImDrawChannel : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            public global::ImGuiSharp.ImVectorImDrawCmd.__Internal _CmdBuffer;
            public global::ImGuiSharp.ImVectorImDrawIdx.__Internal _IdxBuffer;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImDrawChannel@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImDrawChannel> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImDrawChannel>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImDrawChannel managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImDrawChannel managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImDrawChannel __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawChannel(native.ToPointer(), skipVTables);
        }

        internal static ImDrawChannel __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImDrawChannel)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImDrawChannel __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawChannel(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawChannel(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawChannel(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImDrawChannel()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImDrawChannel.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawChannel(global::ImGuiSharp.ImDrawChannel _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImDrawChannel.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImDrawChannel.__Internal*) __Instance) = *((global::ImGuiSharp.ImDrawChannel.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGuiSharp.ImVectorImDrawCmd CmdBuffer
        {
            get
            {
                return global::ImGuiSharp.ImVectorImDrawCmd.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_CmdBuffer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_CmdBuffer = *(global::ImGuiSharp.ImVectorImDrawCmd.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVectorImDrawIdx IdxBuffer
        {
            get
            {
                return global::ImGuiSharp.ImVectorImDrawIdx.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_IdxBuffer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_IdxBuffer = *(global::ImGuiSharp.ImVectorImDrawIdx.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImDrawChannel : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImDrawChannel@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImDrawChannel> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImDrawChannel>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImDrawChannel managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImDrawChannel managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImDrawChannel __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImDrawChannel(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImDrawChannel __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImDrawChannel)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImDrawChannel __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImDrawChannel(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImDrawChannel(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImDrawChannel(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImDrawChannel()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImDrawChannel.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImDrawChannel(global::ImGuiSharp.ImVectorImDrawChannel _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImDrawChannel.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImDrawChannel.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImDrawChannel.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImDrawChannel Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImDrawChannel.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImDrawListSplitter : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            public int _Current;
            public int _Count;
            public global::ImGuiSharp.ImVectorImDrawChannel.__Internal _Channels;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImDrawListSplitter@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImDrawListSplitter> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImDrawListSplitter>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImDrawListSplitter managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImDrawListSplitter managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImDrawListSplitter __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawListSplitter(native.ToPointer(), skipVTables);
        }

        internal static ImDrawListSplitter __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImDrawListSplitter)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImDrawListSplitter __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawListSplitter(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawListSplitter(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawListSplitter(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImDrawListSplitter()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImDrawListSplitter.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawListSplitter(global::ImGuiSharp.ImDrawListSplitter _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImDrawListSplitter.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImDrawListSplitter.__Internal*) __Instance) = *((global::ImGuiSharp.ImDrawListSplitter.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Current
        {
            get
            {
                return ((__Internal*)__Instance)->_Current;
            }

            set
            {
                ((__Internal*)__Instance)->_Current = value;
            }
        }

        public int Count
        {
            get
            {
                return ((__Internal*)__Instance)->_Count;
            }

            set
            {
                ((__Internal*)__Instance)->_Count = value;
            }
        }

        public global::ImGuiSharp.ImVectorImDrawChannel Channels
        {
            get
            {
                return global::ImGuiSharp.ImVectorImDrawChannel.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_Channels));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_Channels = *(global::ImGuiSharp.ImVectorImDrawChannel.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImDrawVert : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImDrawVert@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImDrawVert> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImDrawVert>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImDrawVert managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImDrawVert managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImDrawVert __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImDrawVert(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImDrawVert __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImDrawVert)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImDrawVert __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImDrawVert(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImDrawVert(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImDrawVert(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImDrawVert()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImDrawVert.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImDrawVert(global::ImGuiSharp.ImVectorImDrawVert _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImDrawVert.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImDrawVert.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImDrawVert.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImDrawVert Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImDrawVert.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImVec4 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImVec4@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImVec4> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImVec4>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImVec4 managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImVec4 managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImVec4 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImVec4(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImVec4 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImVec4)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImVec4 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImVec4(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImVec4(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImVec4(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImVec4()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImVec4.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImVec4(global::ImGuiSharp.ImVectorImVec4 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImVec4.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImVec4.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImVec4.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImVec4 Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImVec4.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImTextureID : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImTextureID@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImTextureID> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImTextureID>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImTextureID managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImTextureID managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImTextureID __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImTextureID(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImTextureID __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImTextureID)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImTextureID __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImTextureID(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImTextureID(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImTextureID(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImTextureID()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImTextureID.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImTextureID(global::ImGuiSharp.ImVectorImTextureID _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImTextureID.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImTextureID.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImTextureID.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }
    }

    public unsafe partial class ImVectorImVec2 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImVec2@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImVec2> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImVec2>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImVec2 managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImVec2 managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImVec2 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImVec2(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImVec2 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImVec2)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImVec2 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImVec2(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImVec2(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImVec2(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImVec2()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImVec2.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImVec2(global::ImGuiSharp.ImVectorImVec2 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImVec2.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImVec2.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImVec2.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImVec2 Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImVec2.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImDrawList : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 200)]
        public partial struct __Internal
        {
            public global::ImGuiSharp.ImVectorImDrawCmd.__Internal CmdBuffer;
            public global::ImGuiSharp.ImVectorImDrawIdx.__Internal IdxBuffer;
            public global::ImGuiSharp.ImVectorImDrawVert.__Internal VtxBuffer;
            public int Flags;
            public uint _VtxCurrentIdx;
            public __IntPtr _Data;
            public __IntPtr _OwnerName;
            public __IntPtr _VtxWritePtr;
            public __IntPtr _IdxWritePtr;
            public global::ImGuiSharp.ImVectorImVec4.__Internal _ClipRectStack;
            public global::ImGuiSharp.ImVectorImTextureID.__Internal _TextureIdStack;
            public global::ImGuiSharp.ImVectorImVec2.__Internal _Path;
            public global::ImGuiSharp.ImDrawCmdHeader.__Internal _CmdHeader;
            public global::ImGuiSharp.ImDrawListSplitter.__Internal _Splitter;
            public float _FringeScale;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImDrawList@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImDrawList> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImDrawList>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImDrawList managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImDrawList managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        private bool ___OwnerName_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static ImDrawList __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawList(native.ToPointer(), skipVTables);
        }

        internal static ImDrawList __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImDrawList)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImDrawList __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawList(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawList(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawList(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImDrawList()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImDrawList.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawList(global::ImGuiSharp.ImDrawList _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImDrawList.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImDrawList.__Internal*) __Instance) = *((global::ImGuiSharp.ImDrawList.__Internal*) _0.__Instance);
            if (_0.___OwnerName_OwnsNativeMemory)
                this.OwnerName = _0.OwnerName;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (___OwnerName_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->_OwnerName);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGuiSharp.ImVectorImDrawCmd CmdBuffer
        {
            get
            {
                return global::ImGuiSharp.ImVectorImDrawCmd.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->CmdBuffer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->CmdBuffer = *(global::ImGuiSharp.ImVectorImDrawCmd.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVectorImDrawIdx IdxBuffer
        {
            get
            {
                return global::ImGuiSharp.ImVectorImDrawIdx.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->IdxBuffer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->IdxBuffer = *(global::ImGuiSharp.ImVectorImDrawIdx.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVectorImDrawVert VtxBuffer
        {
            get
            {
                return global::ImGuiSharp.ImVectorImDrawVert.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->VtxBuffer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->VtxBuffer = *(global::ImGuiSharp.ImVectorImDrawVert.__Internal*) value.__Instance;
            }
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public uint VtxCurrentIdx
        {
            get
            {
                return ((__Internal*)__Instance)->_VtxCurrentIdx;
            }

            set
            {
                ((__Internal*)__Instance)->_VtxCurrentIdx = value;
            }
        }

        public global::ImGuiSharp.ImDrawListSharedData Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImDrawListSharedData.__GetOrCreateInstance(((__Internal*)__Instance)->_Data, false);
                return __result0;
            }
        }

        public string OwnerName
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->_OwnerName);
            }

            set
            {
                if (___OwnerName_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->_OwnerName);
                ___OwnerName_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->_OwnerName = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->_OwnerName = (__IntPtr) __bytePtr0;
            }
        }

        public global::ImGuiSharp.ImDrawVert VtxWritePtr
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImDrawVert.__GetOrCreateInstance(((__Internal*)__Instance)->_VtxWritePtr, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->_VtxWritePtr = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public ushort* IdxWritePtr
        {
            get
            {
                return (ushort*) ((__Internal*)__Instance)->_IdxWritePtr;
            }

            set
            {
                ((__Internal*)__Instance)->_IdxWritePtr = (__IntPtr) value;
            }
        }

        public global::ImGuiSharp.ImVectorImVec4 ClipRectStack
        {
            get
            {
                return global::ImGuiSharp.ImVectorImVec4.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_ClipRectStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_ClipRectStack = *(global::ImGuiSharp.ImVectorImVec4.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVectorImTextureID TextureIdStack
        {
            get
            {
                return global::ImGuiSharp.ImVectorImTextureID.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_TextureIdStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_TextureIdStack = *(global::ImGuiSharp.ImVectorImTextureID.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVectorImVec2 Path
        {
            get
            {
                return global::ImGuiSharp.ImVectorImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_Path));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_Path = *(global::ImGuiSharp.ImVectorImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImDrawCmdHeader CmdHeader
        {
            get
            {
                return global::ImGuiSharp.ImDrawCmdHeader.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_CmdHeader));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_CmdHeader = *(global::ImGuiSharp.ImDrawCmdHeader.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImDrawListSplitter Splitter
        {
            get
            {
                return global::ImGuiSharp.ImDrawListSplitter.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_Splitter));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_Splitter = *(global::ImGuiSharp.ImDrawListSplitter.__Internal*) value.__Instance;
            }
        }

        public float FringeScale
        {
            get
            {
                return ((__Internal*)__Instance)->_FringeScale;
            }

            set
            {
                ((__Internal*)__Instance)->_FringeScale = value;
            }
        }
    }

    public unsafe partial class ImDrawData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48)]
        public partial struct __Internal
        {
            public byte Valid;
            public int CmdListsCount;
            public int TotalIdxCount;
            public int TotalVtxCount;
            public __IntPtr CmdLists;
            public global::ImGuiSharp.ImVec2.__Internal DisplayPos;
            public global::ImGuiSharp.ImVec2.__Internal DisplaySize;
            public global::ImGuiSharp.ImVec2.__Internal FramebufferScale;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImDrawData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImDrawData> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImDrawData>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImDrawData managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImDrawData managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImDrawData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawData(native.ToPointer(), skipVTables);
        }

        internal static ImDrawData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImDrawData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImDrawData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImDrawData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImDrawData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawData(global::ImGuiSharp.ImDrawData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImDrawData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImDrawData.__Internal*) __Instance) = *((global::ImGuiSharp.ImDrawData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool Valid
        {
            get
            {
                return ((__Internal*)__Instance)->Valid != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Valid = (byte) (value ? 1 : 0);
            }
        }

        public int CmdListsCount
        {
            get
            {
                return ((__Internal*)__Instance)->CmdListsCount;
            }

            set
            {
                ((__Internal*)__Instance)->CmdListsCount = value;
            }
        }

        public int TotalIdxCount
        {
            get
            {
                return ((__Internal*)__Instance)->TotalIdxCount;
            }

            set
            {
                ((__Internal*)__Instance)->TotalIdxCount = value;
            }
        }

        public int TotalVtxCount
        {
            get
            {
                return ((__Internal*)__Instance)->TotalVtxCount;
            }

            set
            {
                ((__Internal*)__Instance)->TotalVtxCount = value;
            }
        }

        public global::ImGuiSharp.ImDrawList CmdLists
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImDrawList.__GetOrCreateInstance(((__Internal*)__Instance)->CmdLists, false);
                return __result0;
            }

            set
            {
                var __value = value is null ? __IntPtr.Zero : value.__Instance;
                ((__Internal*)__Instance)->CmdLists = new __IntPtr(&__value);
            }
        }

        public global::ImGuiSharp.ImVec2 DisplayPos
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DisplayPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DisplayPos = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 DisplaySize
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DisplaySize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DisplaySize = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 FramebufferScale
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->FramebufferScale));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->FramebufferScale = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImFontConfig : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 136)]
        public partial struct __Internal
        {
            public __IntPtr FontData;
            public int FontDataSize;
            public byte FontDataOwnedByAtlas;
            public int FontNo;
            public float SizePixels;
            public int OversampleH;
            public int OversampleV;
            public byte PixelSnapH;
            public global::ImGuiSharp.ImVec2.__Internal GlyphExtraSpacing;
            public global::ImGuiSharp.ImVec2.__Internal GlyphOffset;
            public __IntPtr GlyphRanges;
            public float GlyphMinAdvanceX;
            public float GlyphMaxAdvanceX;
            public byte MergeMode;
            public uint FontBuilderFlags;
            public float RasterizerMultiply;
            public ushort EllipsisChar;
            public fixed sbyte Name[40];
            public __IntPtr DstFont;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImFontConfig@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImFontConfig> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImFontConfig>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImFontConfig managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImFontConfig managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImFontConfig __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImFontConfig(native.ToPointer(), skipVTables);
        }

        internal static ImFontConfig __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImFontConfig)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImFontConfig __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImFontConfig(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImFontConfig(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImFontConfig(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImFontConfig()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImFontConfig.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImFontConfig(global::ImGuiSharp.ImFontConfig _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImFontConfig.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImFontConfig.__Internal*) __Instance) = *((global::ImGuiSharp.ImFontConfig.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr FontData
        {
            get
            {
                return ((__Internal*)__Instance)->FontData;
            }

            set
            {
                ((__Internal*)__Instance)->FontData = (__IntPtr) value;
            }
        }

        public int FontDataSize
        {
            get
            {
                return ((__Internal*)__Instance)->FontDataSize;
            }

            set
            {
                ((__Internal*)__Instance)->FontDataSize = value;
            }
        }

        public bool FontDataOwnedByAtlas
        {
            get
            {
                return ((__Internal*)__Instance)->FontDataOwnedByAtlas != 0;
            }

            set
            {
                ((__Internal*)__Instance)->FontDataOwnedByAtlas = (byte) (value ? 1 : 0);
            }
        }

        public int FontNo
        {
            get
            {
                return ((__Internal*)__Instance)->FontNo;
            }

            set
            {
                ((__Internal*)__Instance)->FontNo = value;
            }
        }

        public float SizePixels
        {
            get
            {
                return ((__Internal*)__Instance)->SizePixels;
            }

            set
            {
                ((__Internal*)__Instance)->SizePixels = value;
            }
        }

        public int OversampleH
        {
            get
            {
                return ((__Internal*)__Instance)->OversampleH;
            }

            set
            {
                ((__Internal*)__Instance)->OversampleH = value;
            }
        }

        public int OversampleV
        {
            get
            {
                return ((__Internal*)__Instance)->OversampleV;
            }

            set
            {
                ((__Internal*)__Instance)->OversampleV = value;
            }
        }

        public bool PixelSnapH
        {
            get
            {
                return ((__Internal*)__Instance)->PixelSnapH != 0;
            }

            set
            {
                ((__Internal*)__Instance)->PixelSnapH = (byte) (value ? 1 : 0);
            }
        }

        public global::ImGuiSharp.ImVec2 GlyphExtraSpacing
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->GlyphExtraSpacing));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->GlyphExtraSpacing = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 GlyphOffset
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->GlyphOffset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->GlyphOffset = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public ushort* GlyphRanges
        {
            get
            {
                return (ushort*) ((__Internal*)__Instance)->GlyphRanges;
            }
        }

        public float GlyphMinAdvanceX
        {
            get
            {
                return ((__Internal*)__Instance)->GlyphMinAdvanceX;
            }

            set
            {
                ((__Internal*)__Instance)->GlyphMinAdvanceX = value;
            }
        }

        public float GlyphMaxAdvanceX
        {
            get
            {
                return ((__Internal*)__Instance)->GlyphMaxAdvanceX;
            }

            set
            {
                ((__Internal*)__Instance)->GlyphMaxAdvanceX = value;
            }
        }

        public bool MergeMode
        {
            get
            {
                return ((__Internal*)__Instance)->MergeMode != 0;
            }

            set
            {
                ((__Internal*)__Instance)->MergeMode = (byte) (value ? 1 : 0);
            }
        }

        public uint FontBuilderFlags
        {
            get
            {
                return ((__Internal*)__Instance)->FontBuilderFlags;
            }

            set
            {
                ((__Internal*)__Instance)->FontBuilderFlags = value;
            }
        }

        public float RasterizerMultiply
        {
            get
            {
                return ((__Internal*)__Instance)->RasterizerMultiply;
            }

            set
            {
                ((__Internal*)__Instance)->RasterizerMultiply = value;
            }
        }

        public ushort EllipsisChar
        {
            get
            {
                return ((__Internal*)__Instance)->EllipsisChar;
            }

            set
            {
                ((__Internal*)__Instance)->EllipsisChar = value;
            }
        }

        public sbyte[] Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->Name, 40);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 40; i++)
                        ((__Internal*)__Instance)->Name[i] = value[i];
                }
            }
        }

        public global::ImGuiSharp.ImFont DstFont
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImFont.__GetOrCreateInstance(((__Internal*)__Instance)->DstFont, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->DstFont = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImFontGlyph : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public uint Colored;

            [FieldOffset(0)]
            public uint Visible;

            [FieldOffset(0)]
            public uint Codepoint;

            [FieldOffset(4)]
            public float AdvanceX;

            [FieldOffset(8)]
            public float X0;

            [FieldOffset(12)]
            public float Y0;

            [FieldOffset(16)]
            public float X1;

            [FieldOffset(20)]
            public float Y1;

            [FieldOffset(24)]
            public float U0;

            [FieldOffset(28)]
            public float V0;

            [FieldOffset(32)]
            public float U1;

            [FieldOffset(36)]
            public float V1;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImFontGlyph@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImFontGlyph> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImFontGlyph>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImFontGlyph managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImFontGlyph managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImFontGlyph __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImFontGlyph(native.ToPointer(), skipVTables);
        }

        internal static ImFontGlyph __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImFontGlyph)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImFontGlyph __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImFontGlyph(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImFontGlyph(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImFontGlyph(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImFontGlyph()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImFontGlyph.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImFontGlyph(global::ImGuiSharp.ImFontGlyph _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImFontGlyph.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImFontGlyph.__Internal*) __Instance) = *((global::ImGuiSharp.ImFontGlyph.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Colored
        {
            get
            {
                return ((__Internal*)__Instance)->Colored;
            }

            set
            {
                ((__Internal*)__Instance)->Colored = value;
            }
        }

        public uint Visible
        {
            get
            {
                return ((__Internal*)__Instance)->Visible;
            }

            set
            {
                ((__Internal*)__Instance)->Visible = value;
            }
        }

        public uint Codepoint
        {
            get
            {
                return ((__Internal*)__Instance)->Codepoint;
            }

            set
            {
                ((__Internal*)__Instance)->Codepoint = value;
            }
        }

        public float AdvanceX
        {
            get
            {
                return ((__Internal*)__Instance)->AdvanceX;
            }

            set
            {
                ((__Internal*)__Instance)->AdvanceX = value;
            }
        }

        public float X0
        {
            get
            {
                return ((__Internal*)__Instance)->X0;
            }

            set
            {
                ((__Internal*)__Instance)->X0 = value;
            }
        }

        public float Y0
        {
            get
            {
                return ((__Internal*)__Instance)->Y0;
            }

            set
            {
                ((__Internal*)__Instance)->Y0 = value;
            }
        }

        public float X1
        {
            get
            {
                return ((__Internal*)__Instance)->X1;
            }

            set
            {
                ((__Internal*)__Instance)->X1 = value;
            }
        }

        public float Y1
        {
            get
            {
                return ((__Internal*)__Instance)->Y1;
            }

            set
            {
                ((__Internal*)__Instance)->Y1 = value;
            }
        }

        public float U0
        {
            get
            {
                return ((__Internal*)__Instance)->U0;
            }

            set
            {
                ((__Internal*)__Instance)->U0 = value;
            }
        }

        public float V0
        {
            get
            {
                return ((__Internal*)__Instance)->V0;
            }

            set
            {
                ((__Internal*)__Instance)->V0 = value;
            }
        }

        public float U1
        {
            get
            {
                return ((__Internal*)__Instance)->U1;
            }

            set
            {
                ((__Internal*)__Instance)->U1 = value;
            }
        }

        public float V1
        {
            get
            {
                return ((__Internal*)__Instance)->V1;
            }

            set
            {
                ((__Internal*)__Instance)->V1 = value;
            }
        }
    }

    public unsafe partial class ImVectorImU32 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImU32@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImU32> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImU32>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImU32 managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImU32 managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImU32 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImU32(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImU32 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImU32)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImU32 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImU32(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImU32(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImU32(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImU32()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImU32.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImU32(global::ImGuiSharp.ImVectorImU32 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImU32.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImU32.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImU32.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public uint* Data
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->Data;
            }

            set
            {
                ((__Internal*)__Instance)->Data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImFontGlyphRangesBuilder : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public global::ImGuiSharp.ImVectorImU32.__Internal UsedChars;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImFontGlyphRangesBuilder@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImFontGlyphRangesBuilder> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImFontGlyphRangesBuilder>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImFontGlyphRangesBuilder managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImFontGlyphRangesBuilder managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImFontGlyphRangesBuilder __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImFontGlyphRangesBuilder(native.ToPointer(), skipVTables);
        }

        internal static ImFontGlyphRangesBuilder __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImFontGlyphRangesBuilder)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImFontGlyphRangesBuilder __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImFontGlyphRangesBuilder(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImFontGlyphRangesBuilder(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImFontGlyphRangesBuilder(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImFontGlyphRangesBuilder()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImFontGlyphRangesBuilder.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImFontGlyphRangesBuilder(global::ImGuiSharp.ImFontGlyphRangesBuilder _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImFontGlyphRangesBuilder.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImFontGlyphRangesBuilder.__Internal*) __Instance) = *((global::ImGuiSharp.ImFontGlyphRangesBuilder.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGuiSharp.ImVectorImU32 UsedChars
        {
            get
            {
                return global::ImGuiSharp.ImVectorImU32.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->UsedChars));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->UsedChars = *(global::ImGuiSharp.ImVectorImU32.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImFontAtlasCustomRect : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            public ushort Width;
            public ushort Height;
            public ushort X;
            public ushort Y;
            public uint GlyphID;
            public float GlyphAdvanceX;
            public global::ImGuiSharp.ImVec2.__Internal GlyphOffset;
            public __IntPtr Font;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImFontAtlasCustomRect@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImFontAtlasCustomRect> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImFontAtlasCustomRect>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImFontAtlasCustomRect managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImFontAtlasCustomRect managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImFontAtlasCustomRect __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImFontAtlasCustomRect(native.ToPointer(), skipVTables);
        }

        internal static ImFontAtlasCustomRect __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImFontAtlasCustomRect)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImFontAtlasCustomRect __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImFontAtlasCustomRect(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImFontAtlasCustomRect(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImFontAtlasCustomRect(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImFontAtlasCustomRect()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImFontAtlasCustomRect.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImFontAtlasCustomRect(global::ImGuiSharp.ImFontAtlasCustomRect _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImFontAtlasCustomRect.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImFontAtlasCustomRect.__Internal*) __Instance) = *((global::ImGuiSharp.ImFontAtlasCustomRect.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort Width
        {
            get
            {
                return ((__Internal*)__Instance)->Width;
            }

            set
            {
                ((__Internal*)__Instance)->Width = value;
            }
        }

        public ushort Height
        {
            get
            {
                return ((__Internal*)__Instance)->Height;
            }

            set
            {
                ((__Internal*)__Instance)->Height = value;
            }
        }

        public ushort X
        {
            get
            {
                return ((__Internal*)__Instance)->X;
            }

            set
            {
                ((__Internal*)__Instance)->X = value;
            }
        }

        public ushort Y
        {
            get
            {
                return ((__Internal*)__Instance)->Y;
            }

            set
            {
                ((__Internal*)__Instance)->Y = value;
            }
        }

        public uint GlyphID
        {
            get
            {
                return ((__Internal*)__Instance)->GlyphID;
            }

            set
            {
                ((__Internal*)__Instance)->GlyphID = value;
            }
        }

        public float GlyphAdvanceX
        {
            get
            {
                return ((__Internal*)__Instance)->GlyphAdvanceX;
            }

            set
            {
                ((__Internal*)__Instance)->GlyphAdvanceX = value;
            }
        }

        public global::ImGuiSharp.ImVec2 GlyphOffset
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->GlyphOffset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->GlyphOffset = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImFont Font
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImFont.__GetOrCreateInstance(((__Internal*)__Instance)->Font, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Font = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImFontPtr : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImFontPtr@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImFontPtr> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImFontPtr>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImFontPtr managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImFontPtr managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImFontPtr __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImFontPtr(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImFontPtr __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImFontPtr)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImFontPtr __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImFontPtr(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImFontPtr(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImFontPtr(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImFontPtr()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImFontPtr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImFontPtr(global::ImGuiSharp.ImVectorImFontPtr _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImFontPtr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImFontPtr.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImFontPtr.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImFont Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImFont.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                var __value = value is null ? __IntPtr.Zero : value.__Instance;
                ((__Internal*)__Instance)->Data = new __IntPtr(&__value);
            }
        }
    }

    public unsafe partial class ImVectorImFontAtlasCustomRect : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImFontAtlasCustomRect@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImFontAtlasCustomRect> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImFontAtlasCustomRect>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImFontAtlasCustomRect managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImFontAtlasCustomRect managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImFontAtlasCustomRect __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImFontAtlasCustomRect(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImFontAtlasCustomRect __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImFontAtlasCustomRect)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImFontAtlasCustomRect __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImFontAtlasCustomRect(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImFontAtlasCustomRect(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImFontAtlasCustomRect(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImFontAtlasCustomRect()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImFontAtlasCustomRect.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImFontAtlasCustomRect(global::ImGuiSharp.ImVectorImFontAtlasCustomRect _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImFontAtlasCustomRect.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImFontAtlasCustomRect.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImFontAtlasCustomRect.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImFontAtlasCustomRect Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImFontAtlasCustomRect.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImFontConfig : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImFontConfig@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImFontConfig> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImFontConfig>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImFontConfig managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImFontConfig managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImFontConfig __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImFontConfig(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImFontConfig __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImFontConfig)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImFontConfig __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImFontConfig(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImFontConfig(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImFontConfig(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImFontConfig()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImFontConfig.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImFontConfig(global::ImGuiSharp.ImVectorImFontConfig _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImFontConfig.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImFontConfig.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImFontConfig.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImFontConfig Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImFontConfig.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImFontAtlas : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1168)]
        public partial struct __Internal
        {
            public int Flags;
            public __IntPtr TexID;
            public int TexDesiredWidth;
            public int TexGlyphPadding;
            public byte Locked;
            public byte TexReady;
            public byte TexPixelsUseColors;
            public __IntPtr TexPixelsAlpha8;
            public __IntPtr TexPixelsRGBA32;
            public int TexWidth;
            public int TexHeight;
            public global::ImGuiSharp.ImVec2.__Internal TexUvScale;
            public global::ImGuiSharp.ImVec2.__Internal TexUvWhitePixel;
            public global::ImGuiSharp.ImVectorImFontPtr.__Internal Fonts;
            public global::ImGuiSharp.ImVectorImFontAtlasCustomRect.__Internal CustomRects;
            public global::ImGuiSharp.ImVectorImFontConfig.__Internal ConfigData;
            public fixed byte TexUvLines[1024];
            public __IntPtr FontBuilderIO;
            public uint FontBuilderFlags;
            public int PackIdMouseCursors;
            public int PackIdLines;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImFontAtlas@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImFontAtlas> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImFontAtlas>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImFontAtlas managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImFontAtlas managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImFontAtlas __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImFontAtlas(native.ToPointer(), skipVTables);
        }

        internal static ImFontAtlas __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImFontAtlas)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImFontAtlas __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImFontAtlas(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImFontAtlas(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImFontAtlas(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImFontAtlas()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImFontAtlas.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImFontAtlas(global::ImGuiSharp.ImFontAtlas _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImFontAtlas.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImFontAtlas.__Internal*) __Instance) = *((global::ImGuiSharp.ImFontAtlas.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public __IntPtr TexID
        {
            get
            {
                return ((__Internal*)__Instance)->TexID;
            }

            set
            {
                ((__Internal*)__Instance)->TexID = (__IntPtr) value;
            }
        }

        public int TexDesiredWidth
        {
            get
            {
                return ((__Internal*)__Instance)->TexDesiredWidth;
            }

            set
            {
                ((__Internal*)__Instance)->TexDesiredWidth = value;
            }
        }

        public int TexGlyphPadding
        {
            get
            {
                return ((__Internal*)__Instance)->TexGlyphPadding;
            }

            set
            {
                ((__Internal*)__Instance)->TexGlyphPadding = value;
            }
        }

        public bool Locked
        {
            get
            {
                return ((__Internal*)__Instance)->Locked != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Locked = (byte) (value ? 1 : 0);
            }
        }

        public bool TexReady
        {
            get
            {
                return ((__Internal*)__Instance)->TexReady != 0;
            }

            set
            {
                ((__Internal*)__Instance)->TexReady = (byte) (value ? 1 : 0);
            }
        }

        public bool TexPixelsUseColors
        {
            get
            {
                return ((__Internal*)__Instance)->TexPixelsUseColors != 0;
            }

            set
            {
                ((__Internal*)__Instance)->TexPixelsUseColors = (byte) (value ? 1 : 0);
            }
        }

        public byte* TexPixelsAlpha8
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->TexPixelsAlpha8;
            }

            set
            {
                ((__Internal*)__Instance)->TexPixelsAlpha8 = (__IntPtr) value;
            }
        }

        public uint* TexPixelsRGBA32
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->TexPixelsRGBA32;
            }

            set
            {
                ((__Internal*)__Instance)->TexPixelsRGBA32 = (__IntPtr) value;
            }
        }

        public int TexWidth
        {
            get
            {
                return ((__Internal*)__Instance)->TexWidth;
            }

            set
            {
                ((__Internal*)__Instance)->TexWidth = value;
            }
        }

        public int TexHeight
        {
            get
            {
                return ((__Internal*)__Instance)->TexHeight;
            }

            set
            {
                ((__Internal*)__Instance)->TexHeight = value;
            }
        }

        public global::ImGuiSharp.ImVec2 TexUvScale
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->TexUvScale));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->TexUvScale = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 TexUvWhitePixel
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->TexUvWhitePixel));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->TexUvWhitePixel = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVectorImFontPtr Fonts
        {
            get
            {
                return global::ImGuiSharp.ImVectorImFontPtr.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Fonts));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Fonts = *(global::ImGuiSharp.ImVectorImFontPtr.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVectorImFontAtlasCustomRect CustomRects
        {
            get
            {
                return global::ImGuiSharp.ImVectorImFontAtlasCustomRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->CustomRects));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->CustomRects = *(global::ImGuiSharp.ImVectorImFontAtlasCustomRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVectorImFontConfig ConfigData
        {
            get
            {
                return global::ImGuiSharp.ImVectorImFontConfig.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ConfigData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ConfigData = *(global::ImGuiSharp.ImVectorImFontConfig.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec4[] TexUvLines
        {
            get
            {
                global::ImGuiSharp.ImVec4[] __value = null;
                if (((__Internal*)__Instance)->TexUvLines != null)
                {
                    __value = new global::ImGuiSharp.ImVec4[64];
                    for (int i = 0; i < 64; i++)
                        __value[i] = global::ImGuiSharp.ImVec4.__GetOrCreateInstance((IntPtr)((global::ImGuiSharp.ImVec4.__Internal*)&(((__Internal*)__Instance)->TexUvLines[i * sizeof(global::ImGuiSharp.ImVec4.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 64)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 64; i++)
                        *(global::ImGuiSharp.ImVec4.__Internal*) &((__Internal*)__Instance)->TexUvLines[i * sizeof(global::ImGuiSharp.ImVec4.__Internal)] = *(global::ImGuiSharp.ImVec4.__Internal*)value[i].__Instance;
                }
            }
        }

        public global::ImGuiSharp.ImFontBuilderIO FontBuilderIO
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImFontBuilderIO.__GetOrCreateInstance(((__Internal*)__Instance)->FontBuilderIO, false);
                return __result0;
            }
        }

        public uint FontBuilderFlags
        {
            get
            {
                return ((__Internal*)__Instance)->FontBuilderFlags;
            }

            set
            {
                ((__Internal*)__Instance)->FontBuilderFlags = value;
            }
        }

        public int PackIdMouseCursors
        {
            get
            {
                return ((__Internal*)__Instance)->PackIdMouseCursors;
            }

            set
            {
                ((__Internal*)__Instance)->PackIdMouseCursors = value;
            }
        }

        public int PackIdLines
        {
            get
            {
                return ((__Internal*)__Instance)->PackIdLines;
            }

            set
            {
                ((__Internal*)__Instance)->PackIdLines = value;
            }
        }
    }

    public unsafe partial class ImVector_float : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_float@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVector_float> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVector_float>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVector_float managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVector_float managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVector_float __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVector_float(native.ToPointer(), skipVTables);
        }

        internal static ImVector_float __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVector_float)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVector_float __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVector_float(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVector_float(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVector_float(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVector_float()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVector_float.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVector_float(global::ImGuiSharp.ImVector_float _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVector_float.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVector_float.__Internal*) __Instance) = *((global::ImGuiSharp.ImVector_float.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public float* Data
        {
            get
            {
                return (float*) ((__Internal*)__Instance)->Data;
            }

            set
            {
                ((__Internal*)__Instance)->Data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImVectorImFontGlyph : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImFontGlyph@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImFontGlyph> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImFontGlyph>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImFontGlyph managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImFontGlyph managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImFontGlyph __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImFontGlyph(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImFontGlyph __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImFontGlyph)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImFontGlyph __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImFontGlyph(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImFontGlyph(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImFontGlyph(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImFontGlyph()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImFontGlyph.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImFontGlyph(global::ImGuiSharp.ImVectorImFontGlyph _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImFontGlyph.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImFontGlyph.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImFontGlyph.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImFontGlyph Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImFontGlyph.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImFont : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 112)]
        public partial struct __Internal
        {
            public global::ImGuiSharp.ImVector_float.__Internal IndexAdvanceX;
            public float FallbackAdvanceX;
            public float FontSize;
            public global::ImGuiSharp.ImVectorImWchar.__Internal IndexLookup;
            public global::ImGuiSharp.ImVectorImFontGlyph.__Internal Glyphs;
            public __IntPtr FallbackGlyph;
            public __IntPtr ContainerAtlas;
            public __IntPtr ConfigData;
            public short ConfigDataCount;
            public ushort FallbackChar;
            public ushort EllipsisChar;
            public ushort DotChar;
            public byte DirtyLookupTables;
            public float Scale;
            public float Ascent;
            public float Descent;
            public int MetricsTotalSurface;
            public fixed byte Used4kPagesMap[2];

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImFont@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImFont> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImFont>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImFont managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImFont managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImFont __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImFont(native.ToPointer(), skipVTables);
        }

        internal static ImFont __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImFont)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImFont __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImFont(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImFont(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImFont(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImFont()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImFont.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImFont(global::ImGuiSharp.ImFont _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImFont.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImFont.__Internal*) __Instance) = *((global::ImGuiSharp.ImFont.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGuiSharp.ImVector_float IndexAdvanceX
        {
            get
            {
                return global::ImGuiSharp.ImVector_float.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->IndexAdvanceX));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->IndexAdvanceX = *(global::ImGuiSharp.ImVector_float.__Internal*) value.__Instance;
            }
        }

        public float FallbackAdvanceX
        {
            get
            {
                return ((__Internal*)__Instance)->FallbackAdvanceX;
            }

            set
            {
                ((__Internal*)__Instance)->FallbackAdvanceX = value;
            }
        }

        public float FontSize
        {
            get
            {
                return ((__Internal*)__Instance)->FontSize;
            }

            set
            {
                ((__Internal*)__Instance)->FontSize = value;
            }
        }

        public global::ImGuiSharp.ImVectorImWchar IndexLookup
        {
            get
            {
                return global::ImGuiSharp.ImVectorImWchar.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->IndexLookup));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->IndexLookup = *(global::ImGuiSharp.ImVectorImWchar.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVectorImFontGlyph Glyphs
        {
            get
            {
                return global::ImGuiSharp.ImVectorImFontGlyph.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Glyphs));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Glyphs = *(global::ImGuiSharp.ImVectorImFontGlyph.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImFontGlyph FallbackGlyph
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImFontGlyph.__GetOrCreateInstance(((__Internal*)__Instance)->FallbackGlyph, false);
                return __result0;
            }
        }

        public global::ImGuiSharp.ImFontAtlas ContainerAtlas
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImFontAtlas.__GetOrCreateInstance(((__Internal*)__Instance)->ContainerAtlas, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->ContainerAtlas = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGuiSharp.ImFontConfig ConfigData
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImFontConfig.__GetOrCreateInstance(((__Internal*)__Instance)->ConfigData, false);
                return __result0;
            }
        }

        public short ConfigDataCount
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigDataCount;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigDataCount = value;
            }
        }

        public ushort FallbackChar
        {
            get
            {
                return ((__Internal*)__Instance)->FallbackChar;
            }

            set
            {
                ((__Internal*)__Instance)->FallbackChar = value;
            }
        }

        public ushort EllipsisChar
        {
            get
            {
                return ((__Internal*)__Instance)->EllipsisChar;
            }

            set
            {
                ((__Internal*)__Instance)->EllipsisChar = value;
            }
        }

        public ushort DotChar
        {
            get
            {
                return ((__Internal*)__Instance)->DotChar;
            }

            set
            {
                ((__Internal*)__Instance)->DotChar = value;
            }
        }

        public bool DirtyLookupTables
        {
            get
            {
                return ((__Internal*)__Instance)->DirtyLookupTables != 0;
            }

            set
            {
                ((__Internal*)__Instance)->DirtyLookupTables = (byte) (value ? 1 : 0);
            }
        }

        public float Scale
        {
            get
            {
                return ((__Internal*)__Instance)->Scale;
            }

            set
            {
                ((__Internal*)__Instance)->Scale = value;
            }
        }

        public float Ascent
        {
            get
            {
                return ((__Internal*)__Instance)->Ascent;
            }

            set
            {
                ((__Internal*)__Instance)->Ascent = value;
            }
        }

        public float Descent
        {
            get
            {
                return ((__Internal*)__Instance)->Descent;
            }

            set
            {
                ((__Internal*)__Instance)->Descent = value;
            }
        }

        public int MetricsTotalSurface
        {
            get
            {
                return ((__Internal*)__Instance)->MetricsTotalSurface;
            }

            set
            {
                ((__Internal*)__Instance)->MetricsTotalSurface = value;
            }
        }

        public byte[] Used4kPagesMap
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->Used4kPagesMap, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->Used4kPagesMap[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class ImGuiViewport : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48)]
        public partial struct __Internal
        {
            public int Flags;
            public global::ImGuiSharp.ImVec2.__Internal Pos;
            public global::ImGuiSharp.ImVec2.__Internal Size;
            public global::ImGuiSharp.ImVec2.__Internal WorkPos;
            public global::ImGuiSharp.ImVec2.__Internal WorkSize;
            public __IntPtr PlatformHandleRaw;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiViewport@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiViewport> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiViewport>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiViewport managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiViewport managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiViewport __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiViewport(native.ToPointer(), skipVTables);
        }

        internal static ImGuiViewport __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiViewport)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiViewport __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiViewport(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiViewport(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiViewport(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiViewport()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiViewport.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiViewport(global::ImGuiSharp.ImGuiViewport _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiViewport.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiViewport.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiViewport.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public global::ImGuiSharp.ImVec2 Pos
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Pos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Pos = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 Size
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Size));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Size = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 WorkPos
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WorkPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WorkPos = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 WorkSize
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WorkSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WorkSize = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public __IntPtr PlatformHandleRaw
        {
            get
            {
                return ((__Internal*)__Instance)->PlatformHandleRaw;
            }

            set
            {
                ((__Internal*)__Instance)->PlatformHandleRaw = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImGuiPlatformImeData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public byte WantVisible;
            public global::ImGuiSharp.ImVec2.__Internal InputPos;
            public float InputLineHeight;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiPlatformImeData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiPlatformImeData> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiPlatformImeData>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiPlatformImeData managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiPlatformImeData managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiPlatformImeData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiPlatformImeData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiPlatformImeData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiPlatformImeData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiPlatformImeData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiPlatformImeData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiPlatformImeData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiPlatformImeData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiPlatformImeData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiPlatformImeData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiPlatformImeData(global::ImGuiSharp.ImGuiPlatformImeData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiPlatformImeData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiPlatformImeData.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiPlatformImeData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool WantVisible
        {
            get
            {
                return ((__Internal*)__Instance)->WantVisible != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantVisible = (byte) (value ? 1 : 0);
            }
        }

        public global::ImGuiSharp.ImVec2 InputPos
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->InputPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->InputPos = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float InputLineHeight
        {
            get
            {
                return ((__Internal*)__Instance)->InputLineHeight;
            }

            set
            {
                ((__Internal*)__Instance)->InputLineHeight = value;
            }
        }
    }

    public unsafe partial class StbUndoRecord : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int @where;
            public int insert_length;
            public int delete_length;
            public int char_storage;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0StbUndoRecord@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.StbUndoRecord> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.StbUndoRecord>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.StbUndoRecord managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.StbUndoRecord managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static StbUndoRecord __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new StbUndoRecord(native.ToPointer(), skipVTables);
        }

        internal static StbUndoRecord __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (StbUndoRecord)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static StbUndoRecord __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new StbUndoRecord(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private StbUndoRecord(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public StbUndoRecord(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public StbUndoRecord()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.StbUndoRecord.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public StbUndoRecord(global::ImGuiSharp.StbUndoRecord _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.StbUndoRecord.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.StbUndoRecord.__Internal*) __Instance) = *((global::ImGuiSharp.StbUndoRecord.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Where
        {
            get
            {
                return ((__Internal*)__Instance)->@where;
            }

            set
            {
                ((__Internal*)__Instance)->@where = value;
            }
        }

        public int InsertLength
        {
            get
            {
                return ((__Internal*)__Instance)->insert_length;
            }

            set
            {
                ((__Internal*)__Instance)->insert_length = value;
            }
        }

        public int DeleteLength
        {
            get
            {
                return ((__Internal*)__Instance)->delete_length;
            }

            set
            {
                ((__Internal*)__Instance)->delete_length = value;
            }
        }

        public int CharStorage
        {
            get
            {
                return ((__Internal*)__Instance)->char_storage;
            }

            set
            {
                ((__Internal*)__Instance)->char_storage = value;
            }
        }
    }

    public unsafe partial class StbUndoState : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 3596)]
        public partial struct __Internal
        {
            public fixed byte undo_rec[1584];
            public fixed ushort undo_char[999];
            public short undo_point;
            public short redo_point;
            public int undo_char_point;
            public int redo_char_point;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0StbUndoState@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.StbUndoState> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.StbUndoState>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.StbUndoState managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.StbUndoState managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static StbUndoState __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new StbUndoState(native.ToPointer(), skipVTables);
        }

        internal static StbUndoState __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (StbUndoState)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static StbUndoState __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new StbUndoState(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private StbUndoState(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public StbUndoState(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public StbUndoState()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.StbUndoState.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public StbUndoState(global::ImGuiSharp.StbUndoState _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.StbUndoState.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.StbUndoState.__Internal*) __Instance) = *((global::ImGuiSharp.StbUndoState.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGuiSharp.StbUndoRecord[] UndoRec
        {
            get
            {
                global::ImGuiSharp.StbUndoRecord[] __value = null;
                if (((__Internal*)__Instance)->undo_rec != null)
                {
                    __value = new global::ImGuiSharp.StbUndoRecord[99];
                    for (int i = 0; i < 99; i++)
                        __value[i] = global::ImGuiSharp.StbUndoRecord.__GetOrCreateInstance((IntPtr)((global::ImGuiSharp.StbUndoRecord.__Internal*)&(((__Internal*)__Instance)->undo_rec[i * sizeof(global::ImGuiSharp.StbUndoRecord.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 99)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 99; i++)
                        *(global::ImGuiSharp.StbUndoRecord.__Internal*) &((__Internal*)__Instance)->undo_rec[i * sizeof(global::ImGuiSharp.StbUndoRecord.__Internal)] = *(global::ImGuiSharp.StbUndoRecord.__Internal*)value[i].__Instance;
                }
            }
        }

        public ushort[] UndoChar
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<ushort>(((__Internal*)__Instance)->undo_char, 999);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 999; i++)
                        ((__Internal*)__Instance)->undo_char[i] = value[i];
                }
            }
        }

        public short UndoPoint
        {
            get
            {
                return ((__Internal*)__Instance)->undo_point;
            }

            set
            {
                ((__Internal*)__Instance)->undo_point = value;
            }
        }

        public short RedoPoint
        {
            get
            {
                return ((__Internal*)__Instance)->redo_point;
            }

            set
            {
                ((__Internal*)__Instance)->redo_point = value;
            }
        }

        public int UndoCharPoint
        {
            get
            {
                return ((__Internal*)__Instance)->undo_char_point;
            }

            set
            {
                ((__Internal*)__Instance)->undo_char_point = value;
            }
        }

        public int RedoCharPoint
        {
            get
            {
                return ((__Internal*)__Instance)->redo_char_point;
            }

            set
            {
                ((__Internal*)__Instance)->redo_char_point = value;
            }
        }
    }

    public unsafe partial class STB_TexteditState : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 3628)]
        public partial struct __Internal
        {
            public int cursor;
            public int select_start;
            public int select_end;
            public byte insert_mode;
            public int row_count_per_page;
            public byte cursor_at_end_of_line;
            public byte initialized;
            public byte has_preferred_x;
            public byte single_line;
            public byte padding1;
            public byte padding2;
            public byte padding3;
            public float preferred_x;
            public global::ImGuiSharp.StbUndoState.__Internal undostate;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0STB_TexteditState@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.STB_TexteditState> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.STB_TexteditState>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.STB_TexteditState managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.STB_TexteditState managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static STB_TexteditState __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new STB_TexteditState(native.ToPointer(), skipVTables);
        }

        internal static STB_TexteditState __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (STB_TexteditState)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static STB_TexteditState __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new STB_TexteditState(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private STB_TexteditState(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public STB_TexteditState(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public STB_TexteditState()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.STB_TexteditState.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public STB_TexteditState(global::ImGuiSharp.STB_TexteditState _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.STB_TexteditState.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.STB_TexteditState.__Internal*) __Instance) = *((global::ImGuiSharp.STB_TexteditState.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Cursor
        {
            get
            {
                return ((__Internal*)__Instance)->cursor;
            }

            set
            {
                ((__Internal*)__Instance)->cursor = value;
            }
        }

        public int SelectStart
        {
            get
            {
                return ((__Internal*)__Instance)->select_start;
            }

            set
            {
                ((__Internal*)__Instance)->select_start = value;
            }
        }

        public int SelectEnd
        {
            get
            {
                return ((__Internal*)__Instance)->select_end;
            }

            set
            {
                ((__Internal*)__Instance)->select_end = value;
            }
        }

        public byte InsertMode
        {
            get
            {
                return ((__Internal*)__Instance)->insert_mode;
            }

            set
            {
                ((__Internal*)__Instance)->insert_mode = value;
            }
        }

        public int RowCountPerPage
        {
            get
            {
                return ((__Internal*)__Instance)->row_count_per_page;
            }

            set
            {
                ((__Internal*)__Instance)->row_count_per_page = value;
            }
        }

        public byte CursorAtEndOfLine
        {
            get
            {
                return ((__Internal*)__Instance)->cursor_at_end_of_line;
            }

            set
            {
                ((__Internal*)__Instance)->cursor_at_end_of_line = value;
            }
        }

        public byte Initialized
        {
            get
            {
                return ((__Internal*)__Instance)->initialized;
            }

            set
            {
                ((__Internal*)__Instance)->initialized = value;
            }
        }

        public byte HasPreferredX
        {
            get
            {
                return ((__Internal*)__Instance)->has_preferred_x;
            }

            set
            {
                ((__Internal*)__Instance)->has_preferred_x = value;
            }
        }

        public byte SingleLine
        {
            get
            {
                return ((__Internal*)__Instance)->single_line;
            }

            set
            {
                ((__Internal*)__Instance)->single_line = value;
            }
        }

        public byte Padding1
        {
            get
            {
                return ((__Internal*)__Instance)->padding1;
            }

            set
            {
                ((__Internal*)__Instance)->padding1 = value;
            }
        }

        public byte Padding2
        {
            get
            {
                return ((__Internal*)__Instance)->padding2;
            }

            set
            {
                ((__Internal*)__Instance)->padding2 = value;
            }
        }

        public byte Padding3
        {
            get
            {
                return ((__Internal*)__Instance)->padding3;
            }

            set
            {
                ((__Internal*)__Instance)->padding3 = value;
            }
        }

        public float PreferredX
        {
            get
            {
                return ((__Internal*)__Instance)->preferred_x;
            }

            set
            {
                ((__Internal*)__Instance)->preferred_x = value;
            }
        }

        public global::ImGuiSharp.StbUndoState Undostate
        {
            get
            {
                return global::ImGuiSharp.StbUndoState.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->undostate));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->undostate = *(global::ImGuiSharp.StbUndoState.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class StbTexteditRow : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            public float x0;
            public float x1;
            public float baseline_y_delta;
            public float ymin;
            public float ymax;
            public int num_chars;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0StbTexteditRow@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.StbTexteditRow> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.StbTexteditRow>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.StbTexteditRow managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.StbTexteditRow managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static StbTexteditRow __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new StbTexteditRow(native.ToPointer(), skipVTables);
        }

        internal static StbTexteditRow __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (StbTexteditRow)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static StbTexteditRow __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new StbTexteditRow(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private StbTexteditRow(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public StbTexteditRow(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public StbTexteditRow()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.StbTexteditRow.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public StbTexteditRow(global::ImGuiSharp.StbTexteditRow _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.StbTexteditRow.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.StbTexteditRow.__Internal*) __Instance) = *((global::ImGuiSharp.StbTexteditRow.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float X0
        {
            get
            {
                return ((__Internal*)__Instance)->x0;
            }

            set
            {
                ((__Internal*)__Instance)->x0 = value;
            }
        }

        public float X1
        {
            get
            {
                return ((__Internal*)__Instance)->x1;
            }

            set
            {
                ((__Internal*)__Instance)->x1 = value;
            }
        }

        public float BaselineYDelta
        {
            get
            {
                return ((__Internal*)__Instance)->baseline_y_delta;
            }

            set
            {
                ((__Internal*)__Instance)->baseline_y_delta = value;
            }
        }

        public float Ymin
        {
            get
            {
                return ((__Internal*)__Instance)->ymin;
            }

            set
            {
                ((__Internal*)__Instance)->ymin = value;
            }
        }

        public float Ymax
        {
            get
            {
                return ((__Internal*)__Instance)->ymax;
            }

            set
            {
                ((__Internal*)__Instance)->ymax = value;
            }
        }

        public int NumChars
        {
            get
            {
                return ((__Internal*)__Instance)->num_chars;
            }

            set
            {
                ((__Internal*)__Instance)->num_chars = value;
            }
        }
    }

    public unsafe partial class ImVec1 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            public float x;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVec1@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVec1> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVec1>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVec1 managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVec1 managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVec1 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVec1(native.ToPointer(), skipVTables);
        }

        internal static ImVec1 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVec1)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVec1 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVec1(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVec1(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVec1(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVec1()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVec1.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVec1(global::ImGuiSharp.ImVec1 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVec1.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVec1.__Internal*) __Instance) = *((global::ImGuiSharp.ImVec1.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }
    }

    public unsafe partial class ImVec2ih : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            public short x;
            public short y;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVec2ih@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVec2ih> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVec2ih>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVec2ih managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVec2ih managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVec2ih __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVec2ih(native.ToPointer(), skipVTables);
        }

        internal static ImVec2ih __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVec2ih)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVec2ih __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVec2ih(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVec2ih(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVec2ih(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVec2ih()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVec2ih.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVec2ih(global::ImGuiSharp.ImVec2ih _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVec2ih.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVec2ih.__Internal*) __Instance) = *((global::ImGuiSharp.ImVec2ih.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public short X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        public short Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }
    }

    public unsafe partial class ImRect : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public global::ImGuiSharp.ImVec2.__Internal Min;
            public global::ImGuiSharp.ImVec2.__Internal Max;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImRect@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImRect> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImRect>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImRect managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImRect managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImRect __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImRect(native.ToPointer(), skipVTables);
        }

        internal static ImRect __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImRect)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImRect __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImRect(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImRect(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImRect(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImRect()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImRect.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImRect(global::ImGuiSharp.ImRect _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImRect.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImRect.__Internal*) __Instance) = *((global::ImGuiSharp.ImRect.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGuiSharp.ImVec2 Min
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Min));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Min = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 Max
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Max));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Max = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImBitVector : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public global::ImGuiSharp.ImVectorImU32.__Internal Storage;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImBitVector@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImBitVector> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImBitVector>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImBitVector managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImBitVector managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImBitVector __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImBitVector(native.ToPointer(), skipVTables);
        }

        internal static ImBitVector __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImBitVector)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImBitVector __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImBitVector(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImBitVector(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImBitVector(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImBitVector()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImBitVector.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImBitVector(global::ImGuiSharp.ImBitVector _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImBitVector.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImBitVector.__Internal*) __Instance) = *((global::ImGuiSharp.ImBitVector.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGuiSharp.ImVectorImU32 Storage
        {
            get
            {
                return global::ImGuiSharp.ImVectorImU32.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Storage));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Storage = *(global::ImGuiSharp.ImVectorImU32.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImDrawListSharedData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 512)]
        public partial struct __Internal
        {
            public global::ImGuiSharp.ImVec2.__Internal TexUvWhitePixel;
            public __IntPtr Font;
            public float FontSize;
            public float CurveTessellationTol;
            public float CircleSegmentMaxError;
            public global::ImGuiSharp.ImVec4.__Internal ClipRectFullscreen;
            public int InitialFlags;
            public fixed byte ArcFastVtx[384];
            public float ArcFastRadiusCutoff;
            public fixed byte CircleSegmentCounts[64];
            public __IntPtr TexUvLines;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImDrawListSharedData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImDrawListSharedData> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImDrawListSharedData>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImDrawListSharedData managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImDrawListSharedData managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImDrawListSharedData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawListSharedData(native.ToPointer(), skipVTables);
        }

        internal static ImDrawListSharedData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImDrawListSharedData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImDrawListSharedData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawListSharedData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawListSharedData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawListSharedData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImDrawListSharedData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImDrawListSharedData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawListSharedData(global::ImGuiSharp.ImDrawListSharedData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImDrawListSharedData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImDrawListSharedData.__Internal*) __Instance) = *((global::ImGuiSharp.ImDrawListSharedData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGuiSharp.ImVec2 TexUvWhitePixel
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->TexUvWhitePixel));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->TexUvWhitePixel = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImFont Font
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImFont.__GetOrCreateInstance(((__Internal*)__Instance)->Font, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Font = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public float FontSize
        {
            get
            {
                return ((__Internal*)__Instance)->FontSize;
            }

            set
            {
                ((__Internal*)__Instance)->FontSize = value;
            }
        }

        public float CurveTessellationTol
        {
            get
            {
                return ((__Internal*)__Instance)->CurveTessellationTol;
            }

            set
            {
                ((__Internal*)__Instance)->CurveTessellationTol = value;
            }
        }

        public float CircleSegmentMaxError
        {
            get
            {
                return ((__Internal*)__Instance)->CircleSegmentMaxError;
            }

            set
            {
                ((__Internal*)__Instance)->CircleSegmentMaxError = value;
            }
        }

        public global::ImGuiSharp.ImVec4 ClipRectFullscreen
        {
            get
            {
                return global::ImGuiSharp.ImVec4.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ClipRectFullscreen));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ClipRectFullscreen = *(global::ImGuiSharp.ImVec4.__Internal*) value.__Instance;
            }
        }

        public int InitialFlags
        {
            get
            {
                return ((__Internal*)__Instance)->InitialFlags;
            }

            set
            {
                ((__Internal*)__Instance)->InitialFlags = value;
            }
        }

        public global::ImGuiSharp.ImVec2[] ArcFastVtx
        {
            get
            {
                global::ImGuiSharp.ImVec2[] __value = null;
                if (((__Internal*)__Instance)->ArcFastVtx != null)
                {
                    __value = new global::ImGuiSharp.ImVec2[48];
                    for (int i = 0; i < 48; i++)
                        __value[i] = global::ImGuiSharp.ImVec2.__GetOrCreateInstance((IntPtr)((global::ImGuiSharp.ImVec2.__Internal*)&(((__Internal*)__Instance)->ArcFastVtx[i * sizeof(global::ImGuiSharp.ImVec2.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 48)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 48; i++)
                        *(global::ImGuiSharp.ImVec2.__Internal*) &((__Internal*)__Instance)->ArcFastVtx[i * sizeof(global::ImGuiSharp.ImVec2.__Internal)] = *(global::ImGuiSharp.ImVec2.__Internal*)value[i].__Instance;
                }
            }
        }

        public float ArcFastRadiusCutoff
        {
            get
            {
                return ((__Internal*)__Instance)->ArcFastRadiusCutoff;
            }

            set
            {
                ((__Internal*)__Instance)->ArcFastRadiusCutoff = value;
            }
        }

        public byte[] CircleSegmentCounts
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->CircleSegmentCounts, 64);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 64; i++)
                        ((__Internal*)__Instance)->CircleSegmentCounts[i] = value[i];
                }
            }
        }

        public global::ImGuiSharp.ImVec4 TexUvLines
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImVec4.__GetOrCreateInstance(((__Internal*)__Instance)->TexUvLines, false);
                return __result0;
            }
        }
    }

    public unsafe partial class ImVectorImDrawListPtr : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImDrawListPtr@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImDrawListPtr> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImDrawListPtr>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImDrawListPtr managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImDrawListPtr managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImDrawListPtr __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImDrawListPtr(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImDrawListPtr __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImDrawListPtr)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImDrawListPtr __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImDrawListPtr(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImDrawListPtr(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImDrawListPtr(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImDrawListPtr()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImDrawListPtr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImDrawListPtr(global::ImGuiSharp.ImVectorImDrawListPtr _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImDrawListPtr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImDrawListPtr.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImDrawListPtr.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImDrawList Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImDrawList.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                var __value = value is null ? __IntPtr.Zero : value.__Instance;
                ((__Internal*)__Instance)->Data = new __IntPtr(&__value);
            }
        }
    }

    public unsafe partial class ImDrawDataBuilder : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            public fixed byte Layers[32];

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImDrawDataBuilder@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImDrawDataBuilder> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImDrawDataBuilder>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImDrawDataBuilder managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImDrawDataBuilder managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImDrawDataBuilder __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawDataBuilder(native.ToPointer(), skipVTables);
        }

        internal static ImDrawDataBuilder __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImDrawDataBuilder)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImDrawDataBuilder __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawDataBuilder(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawDataBuilder(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawDataBuilder(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImDrawDataBuilder()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImDrawDataBuilder.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawDataBuilder(global::ImGuiSharp.ImDrawDataBuilder _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImDrawDataBuilder.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImDrawDataBuilder.__Internal*) __Instance) = *((global::ImGuiSharp.ImDrawDataBuilder.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGuiSharp.ImVectorImDrawListPtr[] Layers
        {
            get
            {
                global::ImGuiSharp.ImVectorImDrawListPtr[] __value = null;
                if (((__Internal*)__Instance)->Layers != null)
                {
                    __value = new global::ImGuiSharp.ImVectorImDrawListPtr[2];
                    for (int i = 0; i < 2; i++)
                        __value[i] = global::ImGuiSharp.ImVectorImDrawListPtr.__GetOrCreateInstance((IntPtr)((global::ImGuiSharp.ImVectorImDrawListPtr.__Internal*)&(((__Internal*)__Instance)->Layers[i * sizeof(global::ImGuiSharp.ImVectorImDrawListPtr.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 2)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 2; i++)
                        *(global::ImGuiSharp.ImVectorImDrawListPtr.__Internal*) &((__Internal*)__Instance)->Layers[i * sizeof(global::ImGuiSharp.ImVectorImDrawListPtr.__Internal)] = *(global::ImGuiSharp.ImVectorImDrawListPtr.__Internal*)value[i].__Instance;
                }
            }
        }
    }

    public unsafe partial class ImGuiDataTypeTempStorage : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            public fixed byte Data[8];

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiDataTypeTempStorage@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiDataTypeTempStorage> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiDataTypeTempStorage>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiDataTypeTempStorage managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiDataTypeTempStorage managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiDataTypeTempStorage __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiDataTypeTempStorage(native.ToPointer(), skipVTables);
        }

        internal static ImGuiDataTypeTempStorage __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiDataTypeTempStorage)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiDataTypeTempStorage __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiDataTypeTempStorage(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiDataTypeTempStorage(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiDataTypeTempStorage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiDataTypeTempStorage()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiDataTypeTempStorage.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiDataTypeTempStorage(global::ImGuiSharp.ImGuiDataTypeTempStorage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiDataTypeTempStorage.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiDataTypeTempStorage.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiDataTypeTempStorage.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public byte[] Data
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->Data, 8);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 8; i++)
                        ((__Internal*)__Instance)->Data[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class ImGuiDataTypeInfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            public IntPtr Size;
            public __IntPtr Name;
            public __IntPtr PrintFmt;
            public __IntPtr ScanFmt;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiDataTypeInfo@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiDataTypeInfo> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiDataTypeInfo>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiDataTypeInfo managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiDataTypeInfo managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        private bool __Name_OwnsNativeMemory = false;
        private bool __PrintFmt_OwnsNativeMemory = false;
        private bool __ScanFmt_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static ImGuiDataTypeInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiDataTypeInfo(native.ToPointer(), skipVTables);
        }

        internal static ImGuiDataTypeInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiDataTypeInfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiDataTypeInfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiDataTypeInfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiDataTypeInfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiDataTypeInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiDataTypeInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiDataTypeInfo.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiDataTypeInfo(global::ImGuiSharp.ImGuiDataTypeInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiDataTypeInfo.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiDataTypeInfo.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiDataTypeInfo.__Internal*) _0.__Instance);
            if (_0.__Name_OwnsNativeMemory)
                this.Name = _0.Name;
            if (_0.__PrintFmt_OwnsNativeMemory)
                this.PrintFmt = _0.PrintFmt;
            if (_0.__ScanFmt_OwnsNativeMemory)
                this.ScanFmt = _0.ScanFmt;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__Name_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->Name);
            if (__PrintFmt_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->PrintFmt);
            if (__ScanFmt_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->ScanFmt);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public IntPtr Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public string Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->Name);
            }

            set
            {
                if (__Name_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->Name);
                __Name_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->Name = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->Name = (__IntPtr) __bytePtr0;
            }
        }

        public string PrintFmt
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->PrintFmt);
            }

            set
            {
                if (__PrintFmt_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->PrintFmt);
                __PrintFmt_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->PrintFmt = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->PrintFmt = (__IntPtr) __bytePtr0;
            }
        }

        public string ScanFmt
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->ScanFmt);
            }

            set
            {
                if (__ScanFmt_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->ScanFmt);
                __ScanFmt_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->ScanFmt = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->ScanFmt = (__IntPtr) __bytePtr0;
            }
        }
    }

    public unsafe partial class ImGuiColorMod : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 20)]
        public partial struct __Internal
        {
            public int Col;
            public global::ImGuiSharp.ImVec4.__Internal BackupValue;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiColorMod@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiColorMod> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiColorMod>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiColorMod managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiColorMod managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiColorMod __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiColorMod(native.ToPointer(), skipVTables);
        }

        internal static ImGuiColorMod __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiColorMod)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiColorMod __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiColorMod(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiColorMod(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiColorMod(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiColorMod()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiColorMod.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiColorMod(global::ImGuiSharp.ImGuiColorMod _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiColorMod.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiColorMod.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiColorMod.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Col
        {
            get
            {
                return ((__Internal*)__Instance)->Col;
            }

            set
            {
                ((__Internal*)__Instance)->Col = value;
            }
        }

        public global::ImGuiSharp.ImVec4 BackupValue
        {
            get
            {
                return global::ImGuiSharp.ImVec4.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->BackupValue));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->BackupValue = *(global::ImGuiSharp.ImVec4.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiStyleMod : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public int VarIdx;

            [FieldOffset(4)]
            public fixed int BackupInt[2];

            [FieldOffset(4)]
            public fixed float BackupFloat[2];

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiStyleMod@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiStyleMod> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiStyleMod>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiStyleMod managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiStyleMod managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiStyleMod __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiStyleMod(native.ToPointer(), skipVTables);
        }

        internal static ImGuiStyleMod __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiStyleMod)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiStyleMod __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiStyleMod(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiStyleMod(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiStyleMod(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiStyleMod()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiStyleMod.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiStyleMod(global::ImGuiSharp.ImGuiStyleMod _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiStyleMod.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiStyleMod.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiStyleMod.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int VarIdx
        {
            get
            {
                return ((__Internal*)__Instance)->VarIdx;
            }

            set
            {
                ((__Internal*)__Instance)->VarIdx = value;
            }
        }

        public int[] BackupInt
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->BackupInt, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->BackupInt[i] = value[i];
                }
            }
        }

        public float[] BackupFloat
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->BackupFloat, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->BackupFloat[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class ImGuiComboPreviewData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48)]
        public partial struct __Internal
        {
            public global::ImGuiSharp.ImRect.__Internal PreviewRect;
            public global::ImGuiSharp.ImVec2.__Internal BackupCursorPos;
            public global::ImGuiSharp.ImVec2.__Internal BackupCursorMaxPos;
            public global::ImGuiSharp.ImVec2.__Internal BackupCursorPosPrevLine;
            public float BackupPrevLineTextBaseOffset;
            public int BackupLayout;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiComboPreviewData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiComboPreviewData> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiComboPreviewData>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiComboPreviewData managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiComboPreviewData managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiComboPreviewData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiComboPreviewData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiComboPreviewData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiComboPreviewData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiComboPreviewData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiComboPreviewData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiComboPreviewData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiComboPreviewData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiComboPreviewData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiComboPreviewData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiComboPreviewData(global::ImGuiSharp.ImGuiComboPreviewData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiComboPreviewData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiComboPreviewData.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiComboPreviewData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGuiSharp.ImRect PreviewRect
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->PreviewRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->PreviewRect = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 BackupCursorPos
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->BackupCursorPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->BackupCursorPos = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 BackupCursorMaxPos
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->BackupCursorMaxPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->BackupCursorMaxPos = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 BackupCursorPosPrevLine
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->BackupCursorPosPrevLine));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->BackupCursorPosPrevLine = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float BackupPrevLineTextBaseOffset
        {
            get
            {
                return ((__Internal*)__Instance)->BackupPrevLineTextBaseOffset;
            }

            set
            {
                ((__Internal*)__Instance)->BackupPrevLineTextBaseOffset = value;
            }
        }

        public int BackupLayout
        {
            get
            {
                return ((__Internal*)__Instance)->BackupLayout;
            }

            set
            {
                ((__Internal*)__Instance)->BackupLayout = value;
            }
        }
    }

    public unsafe partial class ImGuiGroupData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48)]
        public partial struct __Internal
        {
            public uint WindowID;
            public global::ImGuiSharp.ImVec2.__Internal BackupCursorPos;
            public global::ImGuiSharp.ImVec2.__Internal BackupCursorMaxPos;
            public global::ImGuiSharp.ImVec1.__Internal BackupIndent;
            public global::ImGuiSharp.ImVec1.__Internal BackupGroupOffset;
            public global::ImGuiSharp.ImVec2.__Internal BackupCurrLineSize;
            public float BackupCurrLineTextBaseOffset;
            public uint BackupActiveIdIsAlive;
            public byte BackupActiveIdPreviousFrameIsAlive;
            public byte BackupHoveredIdIsAlive;
            public byte EmitItem;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiGroupData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiGroupData> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiGroupData>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiGroupData managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiGroupData managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiGroupData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiGroupData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiGroupData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiGroupData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiGroupData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiGroupData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiGroupData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiGroupData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiGroupData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiGroupData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiGroupData(global::ImGuiSharp.ImGuiGroupData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiGroupData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiGroupData.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiGroupData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint WindowID
        {
            get
            {
                return ((__Internal*)__Instance)->WindowID;
            }

            set
            {
                ((__Internal*)__Instance)->WindowID = value;
            }
        }

        public global::ImGuiSharp.ImVec2 BackupCursorPos
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->BackupCursorPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->BackupCursorPos = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 BackupCursorMaxPos
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->BackupCursorMaxPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->BackupCursorMaxPos = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec1 BackupIndent
        {
            get
            {
                return global::ImGuiSharp.ImVec1.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->BackupIndent));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->BackupIndent = *(global::ImGuiSharp.ImVec1.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec1 BackupGroupOffset
        {
            get
            {
                return global::ImGuiSharp.ImVec1.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->BackupGroupOffset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->BackupGroupOffset = *(global::ImGuiSharp.ImVec1.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 BackupCurrLineSize
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->BackupCurrLineSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->BackupCurrLineSize = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float BackupCurrLineTextBaseOffset
        {
            get
            {
                return ((__Internal*)__Instance)->BackupCurrLineTextBaseOffset;
            }

            set
            {
                ((__Internal*)__Instance)->BackupCurrLineTextBaseOffset = value;
            }
        }

        public uint BackupActiveIdIsAlive
        {
            get
            {
                return ((__Internal*)__Instance)->BackupActiveIdIsAlive;
            }

            set
            {
                ((__Internal*)__Instance)->BackupActiveIdIsAlive = value;
            }
        }

        public bool BackupActiveIdPreviousFrameIsAlive
        {
            get
            {
                return ((__Internal*)__Instance)->BackupActiveIdPreviousFrameIsAlive != 0;
            }

            set
            {
                ((__Internal*)__Instance)->BackupActiveIdPreviousFrameIsAlive = (byte) (value ? 1 : 0);
            }
        }

        public bool BackupHoveredIdIsAlive
        {
            get
            {
                return ((__Internal*)__Instance)->BackupHoveredIdIsAlive != 0;
            }

            set
            {
                ((__Internal*)__Instance)->BackupHoveredIdIsAlive = (byte) (value ? 1 : 0);
            }
        }

        public bool EmitItem
        {
            get
            {
                return ((__Internal*)__Instance)->EmitItem != 0;
            }

            set
            {
                ((__Internal*)__Instance)->EmitItem = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImGuiMenuColumns : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 28)]
        public partial struct __Internal
        {
            public uint TotalWidth;
            public uint NextTotalWidth;
            public ushort Spacing;
            public ushort OffsetIcon;
            public ushort OffsetLabel;
            public ushort OffsetShortcut;
            public ushort OffsetMark;
            public fixed ushort Widths[4];

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiMenuColumns@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiMenuColumns> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiMenuColumns>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiMenuColumns managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiMenuColumns managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiMenuColumns __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiMenuColumns(native.ToPointer(), skipVTables);
        }

        internal static ImGuiMenuColumns __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiMenuColumns)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiMenuColumns __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiMenuColumns(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiMenuColumns(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiMenuColumns(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiMenuColumns()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiMenuColumns.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiMenuColumns(global::ImGuiSharp.ImGuiMenuColumns _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiMenuColumns.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiMenuColumns.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiMenuColumns.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint TotalWidth
        {
            get
            {
                return ((__Internal*)__Instance)->TotalWidth;
            }

            set
            {
                ((__Internal*)__Instance)->TotalWidth = value;
            }
        }

        public uint NextTotalWidth
        {
            get
            {
                return ((__Internal*)__Instance)->NextTotalWidth;
            }

            set
            {
                ((__Internal*)__Instance)->NextTotalWidth = value;
            }
        }

        public ushort Spacing
        {
            get
            {
                return ((__Internal*)__Instance)->Spacing;
            }

            set
            {
                ((__Internal*)__Instance)->Spacing = value;
            }
        }

        public ushort OffsetIcon
        {
            get
            {
                return ((__Internal*)__Instance)->OffsetIcon;
            }

            set
            {
                ((__Internal*)__Instance)->OffsetIcon = value;
            }
        }

        public ushort OffsetLabel
        {
            get
            {
                return ((__Internal*)__Instance)->OffsetLabel;
            }

            set
            {
                ((__Internal*)__Instance)->OffsetLabel = value;
            }
        }

        public ushort OffsetShortcut
        {
            get
            {
                return ((__Internal*)__Instance)->OffsetShortcut;
            }

            set
            {
                ((__Internal*)__Instance)->OffsetShortcut = value;
            }
        }

        public ushort OffsetMark
        {
            get
            {
                return ((__Internal*)__Instance)->OffsetMark;
            }

            set
            {
                ((__Internal*)__Instance)->OffsetMark = value;
            }
        }

        public ushort[] Widths
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<ushort>(((__Internal*)__Instance)->Widths, 4);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        ((__Internal*)__Instance)->Widths[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class ImGuiInputTextState : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 3720)]
        public partial struct __Internal
        {
            public uint ID;
            public int CurLenW;
            public int CurLenA;
            public global::ImGuiSharp.ImVectorImWchar.__Internal TextW;
            public global::ImGuiSharp.ImVector_char.__Internal TextA;
            public global::ImGuiSharp.ImVector_char.__Internal InitialTextA;
            public byte TextAIsValid;
            public int BufCapacityA;
            public float ScrollX;
            public global::ImGuiSharp.STB_TexteditState.__Internal Stb;
            public float CursorAnim;
            public byte CursorFollow;
            public byte SelectedAllMouseLock;
            public byte Edited;
            public int Flags;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiInputTextState@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiInputTextState> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiInputTextState>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiInputTextState managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiInputTextState managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiInputTextState __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiInputTextState(native.ToPointer(), skipVTables);
        }

        internal static ImGuiInputTextState __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiInputTextState)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiInputTextState __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiInputTextState(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiInputTextState(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputTextState(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiInputTextState()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiInputTextState.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputTextState(global::ImGuiSharp.ImGuiInputTextState _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiInputTextState.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiInputTextState.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiInputTextState.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ID
        {
            get
            {
                return ((__Internal*)__Instance)->ID;
            }

            set
            {
                ((__Internal*)__Instance)->ID = value;
            }
        }

        public int CurLenW
        {
            get
            {
                return ((__Internal*)__Instance)->CurLenW;
            }

            set
            {
                ((__Internal*)__Instance)->CurLenW = value;
            }
        }

        public int CurLenA
        {
            get
            {
                return ((__Internal*)__Instance)->CurLenA;
            }

            set
            {
                ((__Internal*)__Instance)->CurLenA = value;
            }
        }

        public global::ImGuiSharp.ImVectorImWchar TextW
        {
            get
            {
                return global::ImGuiSharp.ImVectorImWchar.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->TextW));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->TextW = *(global::ImGuiSharp.ImVectorImWchar.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVector_char TextA
        {
            get
            {
                return global::ImGuiSharp.ImVector_char.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->TextA));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->TextA = *(global::ImGuiSharp.ImVector_char.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVector_char InitialTextA
        {
            get
            {
                return global::ImGuiSharp.ImVector_char.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->InitialTextA));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->InitialTextA = *(global::ImGuiSharp.ImVector_char.__Internal*) value.__Instance;
            }
        }

        public bool TextAIsValid
        {
            get
            {
                return ((__Internal*)__Instance)->TextAIsValid != 0;
            }

            set
            {
                ((__Internal*)__Instance)->TextAIsValid = (byte) (value ? 1 : 0);
            }
        }

        public int BufCapacityA
        {
            get
            {
                return ((__Internal*)__Instance)->BufCapacityA;
            }

            set
            {
                ((__Internal*)__Instance)->BufCapacityA = value;
            }
        }

        public float ScrollX
        {
            get
            {
                return ((__Internal*)__Instance)->ScrollX;
            }

            set
            {
                ((__Internal*)__Instance)->ScrollX = value;
            }
        }

        public global::ImGuiSharp.STB_TexteditState Stb
        {
            get
            {
                return global::ImGuiSharp.STB_TexteditState.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Stb));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Stb = *(global::ImGuiSharp.STB_TexteditState.__Internal*) value.__Instance;
            }
        }

        public float CursorAnim
        {
            get
            {
                return ((__Internal*)__Instance)->CursorAnim;
            }

            set
            {
                ((__Internal*)__Instance)->CursorAnim = value;
            }
        }

        public bool CursorFollow
        {
            get
            {
                return ((__Internal*)__Instance)->CursorFollow != 0;
            }

            set
            {
                ((__Internal*)__Instance)->CursorFollow = (byte) (value ? 1 : 0);
            }
        }

        public bool SelectedAllMouseLock
        {
            get
            {
                return ((__Internal*)__Instance)->SelectedAllMouseLock != 0;
            }

            set
            {
                ((__Internal*)__Instance)->SelectedAllMouseLock = (byte) (value ? 1 : 0);
            }
        }

        public bool Edited
        {
            get
            {
                return ((__Internal*)__Instance)->Edited != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Edited = (byte) (value ? 1 : 0);
            }
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }
    }

    public unsafe partial class ImGuiPopupData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48)]
        public partial struct __Internal
        {
            public uint PopupId;
            public __IntPtr Window;
            public __IntPtr SourceWindow;
            public int OpenFrameCount;
            public uint OpenParentId;
            public global::ImGuiSharp.ImVec2.__Internal OpenPopupPos;
            public global::ImGuiSharp.ImVec2.__Internal OpenMousePos;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiPopupData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiPopupData> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiPopupData>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiPopupData managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiPopupData managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiPopupData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiPopupData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiPopupData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiPopupData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiPopupData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiPopupData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiPopupData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiPopupData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiPopupData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiPopupData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiPopupData(global::ImGuiSharp.ImGuiPopupData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiPopupData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiPopupData.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiPopupData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint PopupId
        {
            get
            {
                return ((__Internal*)__Instance)->PopupId;
            }

            set
            {
                ((__Internal*)__Instance)->PopupId = value;
            }
        }

        public global::ImGuiSharp.ImGuiWindow Window
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->Window, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Window = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiWindow SourceWindow
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->SourceWindow, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->SourceWindow = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public int OpenFrameCount
        {
            get
            {
                return ((__Internal*)__Instance)->OpenFrameCount;
            }

            set
            {
                ((__Internal*)__Instance)->OpenFrameCount = value;
            }
        }

        public uint OpenParentId
        {
            get
            {
                return ((__Internal*)__Instance)->OpenParentId;
            }

            set
            {
                ((__Internal*)__Instance)->OpenParentId = value;
            }
        }

        public global::ImGuiSharp.ImVec2 OpenPopupPos
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->OpenPopupPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->OpenPopupPos = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 OpenMousePos
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->OpenMousePos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->OpenMousePos = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiNextWindowData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 112)]
        public partial struct __Internal
        {
            public int Flags;
            public int PosCond;
            public int SizeCond;
            public int CollapsedCond;
            public global::ImGuiSharp.ImVec2.__Internal PosVal;
            public global::ImGuiSharp.ImVec2.__Internal PosPivotVal;
            public global::ImGuiSharp.ImVec2.__Internal SizeVal;
            public global::ImGuiSharp.ImVec2.__Internal ContentSizeVal;
            public global::ImGuiSharp.ImVec2.__Internal ScrollVal;
            public byte CollapsedVal;
            public global::ImGuiSharp.ImRect.__Internal SizeConstraintRect;
            public __IntPtr SizeCallback;
            public __IntPtr SizeCallbackUserData;
            public float BgAlphaVal;
            public global::ImGuiSharp.ImVec2.__Internal MenuBarOffsetMinVal;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiNextWindowData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiNextWindowData> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiNextWindowData>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiNextWindowData managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiNextWindowData managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiNextWindowData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiNextWindowData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiNextWindowData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiNextWindowData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiNextWindowData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiNextWindowData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiNextWindowData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiNextWindowData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiNextWindowData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiNextWindowData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiNextWindowData(global::ImGuiSharp.ImGuiNextWindowData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiNextWindowData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiNextWindowData.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiNextWindowData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public int PosCond
        {
            get
            {
                return ((__Internal*)__Instance)->PosCond;
            }

            set
            {
                ((__Internal*)__Instance)->PosCond = value;
            }
        }

        public int SizeCond
        {
            get
            {
                return ((__Internal*)__Instance)->SizeCond;
            }

            set
            {
                ((__Internal*)__Instance)->SizeCond = value;
            }
        }

        public int CollapsedCond
        {
            get
            {
                return ((__Internal*)__Instance)->CollapsedCond;
            }

            set
            {
                ((__Internal*)__Instance)->CollapsedCond = value;
            }
        }

        public global::ImGuiSharp.ImVec2 PosVal
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->PosVal));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->PosVal = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 PosPivotVal
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->PosPivotVal));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->PosPivotVal = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 SizeVal
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->SizeVal));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->SizeVal = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 ContentSizeVal
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ContentSizeVal));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ContentSizeVal = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 ScrollVal
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ScrollVal));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ScrollVal = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public bool CollapsedVal
        {
            get
            {
                return ((__Internal*)__Instance)->CollapsedVal != 0;
            }

            set
            {
                ((__Internal*)__Instance)->CollapsedVal = (byte) (value ? 1 : 0);
            }
        }

        public global::ImGuiSharp.ImRect SizeConstraintRect
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->SizeConstraintRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->SizeConstraintRect = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiSizeCallback SizeCallback
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->SizeCallback;
                return __ptr0 == IntPtr.Zero? null : (global::ImGuiSharp.ImGuiSizeCallback) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ImGuiSharp.ImGuiSizeCallback));
            }

            set
            {
                ((__Internal*)__Instance)->SizeCallback = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr SizeCallbackUserData
        {
            get
            {
                return ((__Internal*)__Instance)->SizeCallbackUserData;
            }

            set
            {
                ((__Internal*)__Instance)->SizeCallbackUserData = (__IntPtr) value;
            }
        }

        public float BgAlphaVal
        {
            get
            {
                return ((__Internal*)__Instance)->BgAlphaVal;
            }

            set
            {
                ((__Internal*)__Instance)->BgAlphaVal = value;
            }
        }

        public global::ImGuiSharp.ImVec2 MenuBarOffsetMinVal
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->MenuBarOffsetMinVal));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->MenuBarOffsetMinVal = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiNextItemData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 20)]
        public partial struct __Internal
        {
            public int Flags;
            public float Width;
            public uint FocusScopeId;
            public int OpenCond;
            public byte OpenVal;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiNextItemData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiNextItemData> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiNextItemData>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiNextItemData managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiNextItemData managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiNextItemData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiNextItemData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiNextItemData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiNextItemData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiNextItemData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiNextItemData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiNextItemData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiNextItemData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiNextItemData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiNextItemData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiNextItemData(global::ImGuiSharp.ImGuiNextItemData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiNextItemData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiNextItemData.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiNextItemData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public float Width
        {
            get
            {
                return ((__Internal*)__Instance)->Width;
            }

            set
            {
                ((__Internal*)__Instance)->Width = value;
            }
        }

        public uint FocusScopeId
        {
            get
            {
                return ((__Internal*)__Instance)->FocusScopeId;
            }

            set
            {
                ((__Internal*)__Instance)->FocusScopeId = value;
            }
        }

        public int OpenCond
        {
            get
            {
                return ((__Internal*)__Instance)->OpenCond;
            }

            set
            {
                ((__Internal*)__Instance)->OpenCond = value;
            }
        }

        public bool OpenVal
        {
            get
            {
                return ((__Internal*)__Instance)->OpenVal != 0;
            }

            set
            {
                ((__Internal*)__Instance)->OpenVal = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImGuiLastItemData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 60)]
        public partial struct __Internal
        {
            public uint ID;
            public int InFlags;
            public int StatusFlags;
            public global::ImGuiSharp.ImRect.__Internal Rect;
            public global::ImGuiSharp.ImRect.__Internal NavRect;
            public global::ImGuiSharp.ImRect.__Internal DisplayRect;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiLastItemData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiLastItemData> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiLastItemData>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiLastItemData managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiLastItemData managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiLastItemData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiLastItemData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiLastItemData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiLastItemData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiLastItemData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiLastItemData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiLastItemData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiLastItemData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiLastItemData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiLastItemData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiLastItemData(global::ImGuiSharp.ImGuiLastItemData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiLastItemData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiLastItemData.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiLastItemData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ID
        {
            get
            {
                return ((__Internal*)__Instance)->ID;
            }

            set
            {
                ((__Internal*)__Instance)->ID = value;
            }
        }

        public int InFlags
        {
            get
            {
                return ((__Internal*)__Instance)->InFlags;
            }

            set
            {
                ((__Internal*)__Instance)->InFlags = value;
            }
        }

        public int StatusFlags
        {
            get
            {
                return ((__Internal*)__Instance)->StatusFlags;
            }

            set
            {
                ((__Internal*)__Instance)->StatusFlags = value;
            }
        }

        public global::ImGuiSharp.ImRect Rect
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Rect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Rect = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImRect NavRect
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->NavRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->NavRect = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImRect DisplayRect
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DisplayRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DisplayRect = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiStackSizes : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 18)]
        public partial struct __Internal
        {
            public short SizeOfIDStack;
            public short SizeOfColorStack;
            public short SizeOfStyleVarStack;
            public short SizeOfFontStack;
            public short SizeOfFocusScopeStack;
            public short SizeOfGroupStack;
            public short SizeOfItemFlagsStack;
            public short SizeOfBeginPopupStack;
            public short SizeOfDisabledStack;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiStackSizes@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiStackSizes> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiStackSizes>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiStackSizes managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiStackSizes managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiStackSizes __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiStackSizes(native.ToPointer(), skipVTables);
        }

        internal static ImGuiStackSizes __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiStackSizes)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiStackSizes __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiStackSizes(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiStackSizes(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiStackSizes(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiStackSizes()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiStackSizes.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiStackSizes(global::ImGuiSharp.ImGuiStackSizes _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiStackSizes.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiStackSizes.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiStackSizes.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public short SizeOfIDStack
        {
            get
            {
                return ((__Internal*)__Instance)->SizeOfIDStack;
            }

            set
            {
                ((__Internal*)__Instance)->SizeOfIDStack = value;
            }
        }

        public short SizeOfColorStack
        {
            get
            {
                return ((__Internal*)__Instance)->SizeOfColorStack;
            }

            set
            {
                ((__Internal*)__Instance)->SizeOfColorStack = value;
            }
        }

        public short SizeOfStyleVarStack
        {
            get
            {
                return ((__Internal*)__Instance)->SizeOfStyleVarStack;
            }

            set
            {
                ((__Internal*)__Instance)->SizeOfStyleVarStack = value;
            }
        }

        public short SizeOfFontStack
        {
            get
            {
                return ((__Internal*)__Instance)->SizeOfFontStack;
            }

            set
            {
                ((__Internal*)__Instance)->SizeOfFontStack = value;
            }
        }

        public short SizeOfFocusScopeStack
        {
            get
            {
                return ((__Internal*)__Instance)->SizeOfFocusScopeStack;
            }

            set
            {
                ((__Internal*)__Instance)->SizeOfFocusScopeStack = value;
            }
        }

        public short SizeOfGroupStack
        {
            get
            {
                return ((__Internal*)__Instance)->SizeOfGroupStack;
            }

            set
            {
                ((__Internal*)__Instance)->SizeOfGroupStack = value;
            }
        }

        public short SizeOfItemFlagsStack
        {
            get
            {
                return ((__Internal*)__Instance)->SizeOfItemFlagsStack;
            }

            set
            {
                ((__Internal*)__Instance)->SizeOfItemFlagsStack = value;
            }
        }

        public short SizeOfBeginPopupStack
        {
            get
            {
                return ((__Internal*)__Instance)->SizeOfBeginPopupStack;
            }

            set
            {
                ((__Internal*)__Instance)->SizeOfBeginPopupStack = value;
            }
        }

        public short SizeOfDisabledStack
        {
            get
            {
                return ((__Internal*)__Instance)->SizeOfDisabledStack;
            }

            set
            {
                ((__Internal*)__Instance)->SizeOfDisabledStack = value;
            }
        }
    }

    public unsafe partial class ImGuiWindowStackData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 88)]
        public partial struct __Internal
        {
            public __IntPtr Window;
            public global::ImGuiSharp.ImGuiLastItemData.__Internal ParentLastItemDataBackup;
            public global::ImGuiSharp.ImGuiStackSizes.__Internal StackSizesOnBegin;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiWindowStackData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiWindowStackData> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiWindowStackData>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiWindowStackData managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiWindowStackData managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiWindowStackData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiWindowStackData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiWindowStackData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiWindowStackData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiWindowStackData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiWindowStackData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiWindowStackData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiWindowStackData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiWindowStackData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiWindowStackData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiWindowStackData(global::ImGuiSharp.ImGuiWindowStackData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiWindowStackData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiWindowStackData.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiWindowStackData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGuiSharp.ImGuiWindow Window
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->Window, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Window = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiLastItemData ParentLastItemDataBackup
        {
            get
            {
                return global::ImGuiSharp.ImGuiLastItemData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ParentLastItemDataBackup));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ParentLastItemDataBackup = *(global::ImGuiSharp.ImGuiLastItemData.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiStackSizes StackSizesOnBegin
        {
            get
            {
                return global::ImGuiSharp.ImGuiStackSizes.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->StackSizesOnBegin));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->StackSizesOnBegin = *(global::ImGuiSharp.ImGuiStackSizes.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiShrinkWidthItem : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            public int Index;
            public float Width;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiShrinkWidthItem@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiShrinkWidthItem> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiShrinkWidthItem>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiShrinkWidthItem managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiShrinkWidthItem managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiShrinkWidthItem __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiShrinkWidthItem(native.ToPointer(), skipVTables);
        }

        internal static ImGuiShrinkWidthItem __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiShrinkWidthItem)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiShrinkWidthItem __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiShrinkWidthItem(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiShrinkWidthItem(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiShrinkWidthItem(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiShrinkWidthItem()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiShrinkWidthItem.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiShrinkWidthItem(global::ImGuiSharp.ImGuiShrinkWidthItem _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiShrinkWidthItem.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiShrinkWidthItem.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiShrinkWidthItem.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Index
        {
            get
            {
                return ((__Internal*)__Instance)->Index;
            }

            set
            {
                ((__Internal*)__Instance)->Index = value;
            }
        }

        public float Width
        {
            get
            {
                return ((__Internal*)__Instance)->Width;
            }

            set
            {
                ((__Internal*)__Instance)->Width = value;
            }
        }
    }

    public unsafe partial class ImGuiPtrOrIndex : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public __IntPtr Ptr;
            public int Index;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiPtrOrIndex@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiPtrOrIndex> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiPtrOrIndex>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiPtrOrIndex managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiPtrOrIndex managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiPtrOrIndex __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiPtrOrIndex(native.ToPointer(), skipVTables);
        }

        internal static ImGuiPtrOrIndex __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiPtrOrIndex)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiPtrOrIndex __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiPtrOrIndex(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiPtrOrIndex(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiPtrOrIndex(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiPtrOrIndex()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiPtrOrIndex.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiPtrOrIndex(global::ImGuiSharp.ImGuiPtrOrIndex _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiPtrOrIndex.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiPtrOrIndex.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiPtrOrIndex.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr Ptr
        {
            get
            {
                return ((__Internal*)__Instance)->Ptr;
            }

            set
            {
                ((__Internal*)__Instance)->Ptr = (__IntPtr) value;
            }
        }

        public int Index
        {
            get
            {
                return ((__Internal*)__Instance)->Index;
            }

            set
            {
                ((__Internal*)__Instance)->Index = value;
            }
        }
    }

    public unsafe partial class ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 20)]
        public partial struct __Internal
        {
            public fixed uint Storage[5];

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImBitArray_ImGuiKey_NamedKey_COUNT__lessImGuiKey_NamedKey_BEGIN@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN(native.ToPointer(), skipVTables);
        }

        internal static ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN(global::ImGuiSharp.ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN.__Internal*) __Instance) = *((global::ImGuiSharp.ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint[] Storage
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->Storage, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->Storage[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class ImGuiInputEventMousePos : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            public float PosX;
            public float PosY;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiInputEventMousePos@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiInputEventMousePos> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiInputEventMousePos>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiInputEventMousePos managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiInputEventMousePos managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiInputEventMousePos __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiInputEventMousePos(native.ToPointer(), skipVTables);
        }

        internal static ImGuiInputEventMousePos __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiInputEventMousePos)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiInputEventMousePos __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiInputEventMousePos(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiInputEventMousePos(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputEventMousePos(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiInputEventMousePos()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiInputEventMousePos.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputEventMousePos(global::ImGuiSharp.ImGuiInputEventMousePos _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiInputEventMousePos.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiInputEventMousePos.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiInputEventMousePos.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float PosX
        {
            get
            {
                return ((__Internal*)__Instance)->PosX;
            }

            set
            {
                ((__Internal*)__Instance)->PosX = value;
            }
        }

        public float PosY
        {
            get
            {
                return ((__Internal*)__Instance)->PosY;
            }

            set
            {
                ((__Internal*)__Instance)->PosY = value;
            }
        }
    }

    public unsafe partial class ImGuiInputEventMouseWheel : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            public float WheelX;
            public float WheelY;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiInputEventMouseWheel@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiInputEventMouseWheel> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiInputEventMouseWheel>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiInputEventMouseWheel managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiInputEventMouseWheel managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiInputEventMouseWheel __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiInputEventMouseWheel(native.ToPointer(), skipVTables);
        }

        internal static ImGuiInputEventMouseWheel __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiInputEventMouseWheel)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiInputEventMouseWheel __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiInputEventMouseWheel(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiInputEventMouseWheel(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputEventMouseWheel(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiInputEventMouseWheel()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiInputEventMouseWheel.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputEventMouseWheel(global::ImGuiSharp.ImGuiInputEventMouseWheel _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiInputEventMouseWheel.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiInputEventMouseWheel.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiInputEventMouseWheel.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float WheelX
        {
            get
            {
                return ((__Internal*)__Instance)->WheelX;
            }

            set
            {
                ((__Internal*)__Instance)->WheelX = value;
            }
        }

        public float WheelY
        {
            get
            {
                return ((__Internal*)__Instance)->WheelY;
            }

            set
            {
                ((__Internal*)__Instance)->WheelY = value;
            }
        }
    }

    public unsafe partial class ImGuiInputEventMouseButton : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            public int Button;
            public byte Down;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiInputEventMouseButton@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiInputEventMouseButton> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiInputEventMouseButton>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiInputEventMouseButton managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiInputEventMouseButton managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiInputEventMouseButton __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiInputEventMouseButton(native.ToPointer(), skipVTables);
        }

        internal static ImGuiInputEventMouseButton __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiInputEventMouseButton)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiInputEventMouseButton __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiInputEventMouseButton(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiInputEventMouseButton(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputEventMouseButton(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiInputEventMouseButton()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiInputEventMouseButton.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputEventMouseButton(global::ImGuiSharp.ImGuiInputEventMouseButton _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiInputEventMouseButton.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiInputEventMouseButton.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiInputEventMouseButton.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Button
        {
            get
            {
                return ((__Internal*)__Instance)->Button;
            }

            set
            {
                ((__Internal*)__Instance)->Button = value;
            }
        }

        public bool Down
        {
            get
            {
                return ((__Internal*)__Instance)->Down != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Down = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImGuiInputEventKey : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            public int Key;
            public byte Down;
            public float AnalogValue;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiInputEventKey@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiInputEventKey> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiInputEventKey>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiInputEventKey managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiInputEventKey managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiInputEventKey __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiInputEventKey(native.ToPointer(), skipVTables);
        }

        internal static ImGuiInputEventKey __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiInputEventKey)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiInputEventKey __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiInputEventKey(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiInputEventKey(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputEventKey(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiInputEventKey()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiInputEventKey.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputEventKey(global::ImGuiSharp.ImGuiInputEventKey _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiInputEventKey.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiInputEventKey.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiInputEventKey.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Key
        {
            get
            {
                return ((__Internal*)__Instance)->Key;
            }

            set
            {
                ((__Internal*)__Instance)->Key = value;
            }
        }

        public bool Down
        {
            get
            {
                return ((__Internal*)__Instance)->Down != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Down = (byte) (value ? 1 : 0);
            }
        }

        public float AnalogValue
        {
            get
            {
                return ((__Internal*)__Instance)->AnalogValue;
            }

            set
            {
                ((__Internal*)__Instance)->AnalogValue = value;
            }
        }
    }

    public unsafe partial class ImGuiInputEventText : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            public uint Char;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiInputEventText@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiInputEventText> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiInputEventText>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiInputEventText managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiInputEventText managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiInputEventText __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiInputEventText(native.ToPointer(), skipVTables);
        }

        internal static ImGuiInputEventText __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiInputEventText)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiInputEventText __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiInputEventText(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiInputEventText(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputEventText(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiInputEventText()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiInputEventText.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputEventText(global::ImGuiSharp.ImGuiInputEventText _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiInputEventText.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiInputEventText.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiInputEventText.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Char
        {
            get
            {
                return ((__Internal*)__Instance)->Char;
            }

            set
            {
                ((__Internal*)__Instance)->Char = value;
            }
        }
    }

    public unsafe partial class ImGuiInputEventAppFocused : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            public byte Focused;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiInputEventAppFocused@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiInputEventAppFocused> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiInputEventAppFocused>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiInputEventAppFocused managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiInputEventAppFocused managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiInputEventAppFocused __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiInputEventAppFocused(native.ToPointer(), skipVTables);
        }

        internal static ImGuiInputEventAppFocused __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiInputEventAppFocused)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiInputEventAppFocused __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiInputEventAppFocused(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiInputEventAppFocused(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputEventAppFocused(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiInputEventAppFocused()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiInputEventAppFocused.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputEventAppFocused(global::ImGuiSharp.ImGuiInputEventAppFocused _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiInputEventAppFocused.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiInputEventAppFocused.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiInputEventAppFocused.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool Focused
        {
            get
            {
                return ((__Internal*)__Instance)->Focused != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Focused = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImGuiInputEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::ImGuiSharp.ImGuiInputEventType Type;

            [FieldOffset(4)]
            public global::ImGuiSharp.ImGuiInputSource Source;

            [FieldOffset(8)]
            public global::ImGuiSharp.ImGuiInputEventMousePos.__Internal MousePos;

            [FieldOffset(8)]
            public global::ImGuiSharp.ImGuiInputEventMouseWheel.__Internal MouseWheel;

            [FieldOffset(8)]
            public global::ImGuiSharp.ImGuiInputEventMouseButton.__Internal MouseButton;

            [FieldOffset(8)]
            public global::ImGuiSharp.ImGuiInputEventKey.__Internal Key;

            [FieldOffset(8)]
            public global::ImGuiSharp.ImGuiInputEventText.__Internal Text;

            [FieldOffset(8)]
            public global::ImGuiSharp.ImGuiInputEventAppFocused.__Internal AppFocused;

            [FieldOffset(20)]
            public byte AddedByTestEngine;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiInputEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiInputEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiInputEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiInputEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiInputEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiInputEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiInputEvent(native.ToPointer(), skipVTables);
        }

        internal static ImGuiInputEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiInputEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiInputEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiInputEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiInputEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiInputEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiInputEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputEvent(global::ImGuiSharp.ImGuiInputEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiInputEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiInputEvent.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiInputEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGuiSharp.ImGuiInputEventType Type
        {
            get
            {
                return ((__Internal*)__Instance)->Type;
            }

            set
            {
                ((__Internal*)__Instance)->Type = value;
            }
        }

        public global::ImGuiSharp.ImGuiInputSource Source
        {
            get
            {
                return ((__Internal*)__Instance)->Source;
            }

            set
            {
                ((__Internal*)__Instance)->Source = value;
            }
        }

        public global::ImGuiSharp.ImGuiInputEventMousePos MousePos
        {
            get
            {
                return global::ImGuiSharp.ImGuiInputEventMousePos.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->MousePos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->MousePos = *(global::ImGuiSharp.ImGuiInputEventMousePos.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiInputEventMouseWheel MouseWheel
        {
            get
            {
                return global::ImGuiSharp.ImGuiInputEventMouseWheel.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->MouseWheel));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->MouseWheel = *(global::ImGuiSharp.ImGuiInputEventMouseWheel.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiInputEventMouseButton MouseButton
        {
            get
            {
                return global::ImGuiSharp.ImGuiInputEventMouseButton.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->MouseButton));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->MouseButton = *(global::ImGuiSharp.ImGuiInputEventMouseButton.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiInputEventKey Key
        {
            get
            {
                return global::ImGuiSharp.ImGuiInputEventKey.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Key));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Key = *(global::ImGuiSharp.ImGuiInputEventKey.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiInputEventText Text
        {
            get
            {
                return global::ImGuiSharp.ImGuiInputEventText.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Text));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Text = *(global::ImGuiSharp.ImGuiInputEventText.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiInputEventAppFocused AppFocused
        {
            get
            {
                return global::ImGuiSharp.ImGuiInputEventAppFocused.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->AppFocused));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->AppFocused = *(global::ImGuiSharp.ImGuiInputEventAppFocused.__Internal*) value.__Instance;
            }
        }

        public bool AddedByTestEngine
        {
            get
            {
                return ((__Internal*)__Instance)->AddedByTestEngine != 0;
            }

            set
            {
                ((__Internal*)__Instance)->AddedByTestEngine = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImGuiListClipperRange : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            public int Min;
            public int Max;
            public byte PosToIndexConvert;
            public sbyte PosToIndexOffsetMin;
            public sbyte PosToIndexOffsetMax;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiListClipperRange@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiListClipperRange> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiListClipperRange>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiListClipperRange managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiListClipperRange managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiListClipperRange __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiListClipperRange(native.ToPointer(), skipVTables);
        }

        internal static ImGuiListClipperRange __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiListClipperRange)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiListClipperRange __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiListClipperRange(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiListClipperRange(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiListClipperRange(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiListClipperRange()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiListClipperRange.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiListClipperRange(global::ImGuiSharp.ImGuiListClipperRange _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiListClipperRange.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiListClipperRange.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiListClipperRange.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Min
        {
            get
            {
                return ((__Internal*)__Instance)->Min;
            }

            set
            {
                ((__Internal*)__Instance)->Min = value;
            }
        }

        public int Max
        {
            get
            {
                return ((__Internal*)__Instance)->Max;
            }

            set
            {
                ((__Internal*)__Instance)->Max = value;
            }
        }

        public bool PosToIndexConvert
        {
            get
            {
                return ((__Internal*)__Instance)->PosToIndexConvert != 0;
            }

            set
            {
                ((__Internal*)__Instance)->PosToIndexConvert = (byte) (value ? 1 : 0);
            }
        }

        public sbyte PosToIndexOffsetMin
        {
            get
            {
                return ((__Internal*)__Instance)->PosToIndexOffsetMin;
            }

            set
            {
                ((__Internal*)__Instance)->PosToIndexOffsetMin = value;
            }
        }

        public sbyte PosToIndexOffsetMax
        {
            get
            {
                return ((__Internal*)__Instance)->PosToIndexOffsetMax;
            }

            set
            {
                ((__Internal*)__Instance)->PosToIndexOffsetMax = value;
            }
        }
    }

    public unsafe partial class ImVectorImGuiListClipperRange : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiListClipperRange@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiListClipperRange> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiListClipperRange>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImGuiListClipperRange managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImGuiListClipperRange managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiListClipperRange __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiListClipperRange(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiListClipperRange __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiListClipperRange)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiListClipperRange __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiListClipperRange(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiListClipperRange(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiListClipperRange(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiListClipperRange()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiListClipperRange.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiListClipperRange(global::ImGuiSharp.ImVectorImGuiListClipperRange _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiListClipperRange.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImGuiListClipperRange.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImGuiListClipperRange.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImGuiListClipperRange Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiListClipperRange.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiListClipperData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            public __IntPtr ListClipper;
            public float LossynessOffset;
            public int StepNo;
            public int ItemsFrozen;
            public global::ImGuiSharp.ImVectorImGuiListClipperRange.__Internal Ranges;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiListClipperData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiListClipperData> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiListClipperData>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiListClipperData managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiListClipperData managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiListClipperData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiListClipperData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiListClipperData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiListClipperData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiListClipperData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiListClipperData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiListClipperData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiListClipperData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiListClipperData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiListClipperData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiListClipperData(global::ImGuiSharp.ImGuiListClipperData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiListClipperData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiListClipperData.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiListClipperData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGuiSharp.ImGuiListClipper ListClipper
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiListClipper.__GetOrCreateInstance(((__Internal*)__Instance)->ListClipper, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->ListClipper = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public float LossynessOffset
        {
            get
            {
                return ((__Internal*)__Instance)->LossynessOffset;
            }

            set
            {
                ((__Internal*)__Instance)->LossynessOffset = value;
            }
        }

        public int StepNo
        {
            get
            {
                return ((__Internal*)__Instance)->StepNo;
            }

            set
            {
                ((__Internal*)__Instance)->StepNo = value;
            }
        }

        public int ItemsFrozen
        {
            get
            {
                return ((__Internal*)__Instance)->ItemsFrozen;
            }

            set
            {
                ((__Internal*)__Instance)->ItemsFrozen = value;
            }
        }

        public global::ImGuiSharp.ImVectorImGuiListClipperRange Ranges
        {
            get
            {
                return global::ImGuiSharp.ImVectorImGuiListClipperRange.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Ranges));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Ranges = *(global::ImGuiSharp.ImVectorImGuiListClipperRange.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiNavItemData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48)]
        public partial struct __Internal
        {
            public __IntPtr Window;
            public uint ID;
            public uint FocusScopeId;
            public global::ImGuiSharp.ImRect.__Internal RectRel;
            public int InFlags;
            public float DistBox;
            public float DistCenter;
            public float DistAxial;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiNavItemData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiNavItemData> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiNavItemData>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiNavItemData managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiNavItemData managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiNavItemData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiNavItemData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiNavItemData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiNavItemData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiNavItemData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiNavItemData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiNavItemData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiNavItemData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiNavItemData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiNavItemData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiNavItemData(global::ImGuiSharp.ImGuiNavItemData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiNavItemData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiNavItemData.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiNavItemData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGuiSharp.ImGuiWindow Window
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->Window, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Window = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public uint ID
        {
            get
            {
                return ((__Internal*)__Instance)->ID;
            }

            set
            {
                ((__Internal*)__Instance)->ID = value;
            }
        }

        public uint FocusScopeId
        {
            get
            {
                return ((__Internal*)__Instance)->FocusScopeId;
            }

            set
            {
                ((__Internal*)__Instance)->FocusScopeId = value;
            }
        }

        public global::ImGuiSharp.ImRect RectRel
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->RectRel));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->RectRel = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public int InFlags
        {
            get
            {
                return ((__Internal*)__Instance)->InFlags;
            }

            set
            {
                ((__Internal*)__Instance)->InFlags = value;
            }
        }

        public float DistBox
        {
            get
            {
                return ((__Internal*)__Instance)->DistBox;
            }

            set
            {
                ((__Internal*)__Instance)->DistBox = value;
            }
        }

        public float DistCenter
        {
            get
            {
                return ((__Internal*)__Instance)->DistCenter;
            }

            set
            {
                ((__Internal*)__Instance)->DistCenter = value;
            }
        }

        public float DistAxial
        {
            get
            {
                return ((__Internal*)__Instance)->DistAxial;
            }

            set
            {
                ((__Internal*)__Instance)->DistAxial = value;
            }
        }
    }

    public unsafe partial class ImGuiOldColumnData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 28)]
        public partial struct __Internal
        {
            public float OffsetNorm;
            public float OffsetNormBeforeResize;
            public int Flags;
            public global::ImGuiSharp.ImRect.__Internal ClipRect;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiOldColumnData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiOldColumnData> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiOldColumnData>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiOldColumnData managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiOldColumnData managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiOldColumnData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiOldColumnData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiOldColumnData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiOldColumnData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiOldColumnData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiOldColumnData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiOldColumnData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiOldColumnData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiOldColumnData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiOldColumnData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiOldColumnData(global::ImGuiSharp.ImGuiOldColumnData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiOldColumnData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiOldColumnData.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiOldColumnData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float OffsetNorm
        {
            get
            {
                return ((__Internal*)__Instance)->OffsetNorm;
            }

            set
            {
                ((__Internal*)__Instance)->OffsetNorm = value;
            }
        }

        public float OffsetNormBeforeResize
        {
            get
            {
                return ((__Internal*)__Instance)->OffsetNormBeforeResize;
            }

            set
            {
                ((__Internal*)__Instance)->OffsetNormBeforeResize = value;
            }
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public global::ImGuiSharp.ImRect ClipRect
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ClipRect = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiOldColumnData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiOldColumnData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiOldColumnData> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiOldColumnData>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImGuiOldColumnData managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImGuiOldColumnData managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiOldColumnData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiOldColumnData(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiOldColumnData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiOldColumnData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiOldColumnData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiOldColumnData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiOldColumnData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiOldColumnData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiOldColumnData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiOldColumnData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiOldColumnData(global::ImGuiSharp.ImVectorImGuiOldColumnData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiOldColumnData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImGuiOldColumnData.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImGuiOldColumnData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImGuiOldColumnData Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiOldColumnData.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiOldColumns : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 136)]
        public partial struct __Internal
        {
            public uint ID;
            public int Flags;
            public byte IsFirstFrame;
            public byte IsBeingResized;
            public int Current;
            public int Count;
            public float OffMinX;
            public float OffMaxX;
            public float LineMinY;
            public float LineMaxY;
            public float HostCursorPosY;
            public float HostCursorMaxPosX;
            public global::ImGuiSharp.ImRect.__Internal HostInitialClipRect;
            public global::ImGuiSharp.ImRect.__Internal HostBackupClipRect;
            public global::ImGuiSharp.ImRect.__Internal HostBackupParentWorkRect;
            public global::ImGuiSharp.ImVectorImGuiOldColumnData.__Internal Columns;
            public global::ImGuiSharp.ImDrawListSplitter.__Internal Splitter;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiOldColumns@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiOldColumns> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiOldColumns>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiOldColumns managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiOldColumns managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiOldColumns __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiOldColumns(native.ToPointer(), skipVTables);
        }

        internal static ImGuiOldColumns __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiOldColumns)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiOldColumns __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiOldColumns(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiOldColumns(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiOldColumns(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiOldColumns()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiOldColumns.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiOldColumns(global::ImGuiSharp.ImGuiOldColumns _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiOldColumns.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiOldColumns.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiOldColumns.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ID
        {
            get
            {
                return ((__Internal*)__Instance)->ID;
            }

            set
            {
                ((__Internal*)__Instance)->ID = value;
            }
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public bool IsFirstFrame
        {
            get
            {
                return ((__Internal*)__Instance)->IsFirstFrame != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsFirstFrame = (byte) (value ? 1 : 0);
            }
        }

        public bool IsBeingResized
        {
            get
            {
                return ((__Internal*)__Instance)->IsBeingResized != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsBeingResized = (byte) (value ? 1 : 0);
            }
        }

        public int Current
        {
            get
            {
                return ((__Internal*)__Instance)->Current;
            }

            set
            {
                ((__Internal*)__Instance)->Current = value;
            }
        }

        public int Count
        {
            get
            {
                return ((__Internal*)__Instance)->Count;
            }

            set
            {
                ((__Internal*)__Instance)->Count = value;
            }
        }

        public float OffMinX
        {
            get
            {
                return ((__Internal*)__Instance)->OffMinX;
            }

            set
            {
                ((__Internal*)__Instance)->OffMinX = value;
            }
        }

        public float OffMaxX
        {
            get
            {
                return ((__Internal*)__Instance)->OffMaxX;
            }

            set
            {
                ((__Internal*)__Instance)->OffMaxX = value;
            }
        }

        public float LineMinY
        {
            get
            {
                return ((__Internal*)__Instance)->LineMinY;
            }

            set
            {
                ((__Internal*)__Instance)->LineMinY = value;
            }
        }

        public float LineMaxY
        {
            get
            {
                return ((__Internal*)__Instance)->LineMaxY;
            }

            set
            {
                ((__Internal*)__Instance)->LineMaxY = value;
            }
        }

        public float HostCursorPosY
        {
            get
            {
                return ((__Internal*)__Instance)->HostCursorPosY;
            }

            set
            {
                ((__Internal*)__Instance)->HostCursorPosY = value;
            }
        }

        public float HostCursorMaxPosX
        {
            get
            {
                return ((__Internal*)__Instance)->HostCursorMaxPosX;
            }

            set
            {
                ((__Internal*)__Instance)->HostCursorMaxPosX = value;
            }
        }

        public global::ImGuiSharp.ImRect HostInitialClipRect
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->HostInitialClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->HostInitialClipRect = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImRect HostBackupClipRect
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->HostBackupClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->HostBackupClipRect = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImRect HostBackupParentWorkRect
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->HostBackupParentWorkRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->HostBackupParentWorkRect = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVectorImGuiOldColumnData Columns
        {
            get
            {
                return global::ImGuiSharp.ImVectorImGuiOldColumnData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Columns));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Columns = *(global::ImGuiSharp.ImVectorImGuiOldColumnData.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImDrawListSplitter Splitter
        {
            get
            {
                return global::ImGuiSharp.ImDrawListSplitter.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Splitter));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Splitter = *(global::ImGuiSharp.ImDrawListSplitter.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiViewportP : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 184)]
        public partial struct __Internal
        {
            public global::ImGuiSharp.ImGuiViewport.__Internal _ImGuiViewport;
            public fixed int DrawListsLastFrame[2];
            public fixed long DrawLists[2];
            public global::ImGuiSharp.ImDrawData.__Internal DrawDataP;
            public global::ImGuiSharp.ImDrawDataBuilder.__Internal DrawDataBuilder;
            public global::ImGuiSharp.ImVec2.__Internal WorkOffsetMin;
            public global::ImGuiSharp.ImVec2.__Internal WorkOffsetMax;
            public global::ImGuiSharp.ImVec2.__Internal BuildWorkOffsetMin;
            public global::ImGuiSharp.ImVec2.__Internal BuildWorkOffsetMax;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiViewportP@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiViewportP> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiViewportP>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiViewportP managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiViewportP managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiViewportP __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiViewportP(native.ToPointer(), skipVTables);
        }

        internal static ImGuiViewportP __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiViewportP)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiViewportP __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiViewportP(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiViewportP(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiViewportP(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiViewportP()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiViewportP.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiViewportP(global::ImGuiSharp.ImGuiViewportP _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiViewportP.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiViewportP.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiViewportP.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGuiSharp.ImGuiViewport ImGuiViewport
        {
            get
            {
                return global::ImGuiSharp.ImGuiViewport.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_ImGuiViewport));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_ImGuiViewport = *(global::ImGuiSharp.ImGuiViewport.__Internal*) value.__Instance;
            }
        }

        public int[] DrawListsLastFrame
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->DrawListsLastFrame, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->DrawListsLastFrame[i] = value[i];
                }
            }
        }

        public global::ImGuiSharp.ImDrawList[] DrawLists
        {
            get
            {
                global::ImGuiSharp.ImDrawList[] __value = null;
                if (((__Internal*)__Instance)->DrawLists != null)
                {
                    __value = new global::ImGuiSharp.ImDrawList[2];
                    for (int i = 0; i < 2; i++)
                        __value[i] = global::ImGuiSharp.ImDrawList.__CreateInstance((__IntPtr) ((__Internal*)__Instance)->DrawLists[i]);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 2)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->DrawLists[i] = (long) value[i].__Instance;
                }
            }
        }

        public global::ImGuiSharp.ImDrawData DrawDataP
        {
            get
            {
                return global::ImGuiSharp.ImDrawData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DrawDataP));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DrawDataP = *(global::ImGuiSharp.ImDrawData.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImDrawDataBuilder DrawDataBuilder
        {
            get
            {
                return global::ImGuiSharp.ImDrawDataBuilder.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DrawDataBuilder));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DrawDataBuilder = *(global::ImGuiSharp.ImDrawDataBuilder.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 WorkOffsetMin
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WorkOffsetMin));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WorkOffsetMin = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 WorkOffsetMax
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WorkOffsetMax));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WorkOffsetMax = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 BuildWorkOffsetMin
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->BuildWorkOffsetMin));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->BuildWorkOffsetMin = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 BuildWorkOffsetMax
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->BuildWorkOffsetMax));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->BuildWorkOffsetMax = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiWindowSettings : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public uint ID;
            public global::ImGuiSharp.ImVec2ih.__Internal Pos;
            public global::ImGuiSharp.ImVec2ih.__Internal Size;
            public byte Collapsed;
            public byte WantApply;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiWindowSettings@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiWindowSettings> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiWindowSettings>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiWindowSettings managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiWindowSettings managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiWindowSettings __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiWindowSettings(native.ToPointer(), skipVTables);
        }

        internal static ImGuiWindowSettings __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiWindowSettings)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiWindowSettings __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiWindowSettings(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiWindowSettings(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiWindowSettings(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiWindowSettings()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiWindowSettings.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiWindowSettings(global::ImGuiSharp.ImGuiWindowSettings _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiWindowSettings.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiWindowSettings.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiWindowSettings.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ID
        {
            get
            {
                return ((__Internal*)__Instance)->ID;
            }

            set
            {
                ((__Internal*)__Instance)->ID = value;
            }
        }

        public global::ImGuiSharp.ImVec2ih Pos
        {
            get
            {
                return global::ImGuiSharp.ImVec2ih.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Pos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Pos = *(global::ImGuiSharp.ImVec2ih.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2ih Size
        {
            get
            {
                return global::ImGuiSharp.ImVec2ih.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Size));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Size = *(global::ImGuiSharp.ImVec2ih.__Internal*) value.__Instance;
            }
        }

        public bool Collapsed
        {
            get
            {
                return ((__Internal*)__Instance)->Collapsed != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Collapsed = (byte) (value ? 1 : 0);
            }
        }

        public bool WantApply
        {
            get
            {
                return ((__Internal*)__Instance)->WantApply != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantApply = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImGuiSettingsHandler : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 72)]
        public partial struct __Internal
        {
            public __IntPtr TypeName;
            public uint TypeHash;
            public __IntPtr ClearAllFn;
            public __IntPtr ReadInitFn;
            public __IntPtr ReadOpenFn;
            public __IntPtr ReadLineFn;
            public __IntPtr ApplyAllFn;
            public __IntPtr WriteAllFn;
            public __IntPtr UserData;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiSettingsHandler@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiSettingsHandler> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiSettingsHandler>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiSettingsHandler managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiSettingsHandler managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        private bool __TypeName_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static ImGuiSettingsHandler __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiSettingsHandler(native.ToPointer(), skipVTables);
        }

        internal static ImGuiSettingsHandler __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiSettingsHandler)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiSettingsHandler __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiSettingsHandler(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiSettingsHandler(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiSettingsHandler(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiSettingsHandler()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiSettingsHandler.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiSettingsHandler(global::ImGuiSharp.ImGuiSettingsHandler _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiSettingsHandler.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiSettingsHandler.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiSettingsHandler.__Internal*) _0.__Instance);
            if (_0.__TypeName_OwnsNativeMemory)
                this.TypeName = _0.TypeName;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__TypeName_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->TypeName);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string TypeName
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->TypeName);
            }

            set
            {
                if (__TypeName_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->TypeName);
                __TypeName_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->TypeName = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->TypeName = (__IntPtr) __bytePtr0;
            }
        }

        public uint TypeHash
        {
            get
            {
                return ((__Internal*)__Instance)->TypeHash;
            }

            set
            {
                ((__Internal*)__Instance)->TypeHash = value;
            }
        }

        public global::ImGuiSharp.Delegates.Action___IntPtr___IntPtr ClearAllFn
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->ClearAllFn;
                return __ptr0 == IntPtr.Zero? null : (global::ImGuiSharp.Delegates.Action___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ImGuiSharp.Delegates.Action___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->ClearAllFn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::ImGuiSharp.Delegates.Action___IntPtr___IntPtr ReadInitFn
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->ReadInitFn;
                return __ptr0 == IntPtr.Zero? null : (global::ImGuiSharp.Delegates.Action___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ImGuiSharp.Delegates.Action___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->ReadInitFn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::ImGuiSharp.Delegates.Func___IntPtr___IntPtr___IntPtr_string8 ReadOpenFn
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->ReadOpenFn;
                return __ptr0 == IntPtr.Zero? null : (global::ImGuiSharp.Delegates.Func___IntPtr___IntPtr___IntPtr_string8) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ImGuiSharp.Delegates.Func___IntPtr___IntPtr___IntPtr_string8));
            }

            set
            {
                ((__Internal*)__Instance)->ReadOpenFn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::ImGuiSharp.Delegates.Action___IntPtr___IntPtr___IntPtr_string8 ReadLineFn
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->ReadLineFn;
                return __ptr0 == IntPtr.Zero? null : (global::ImGuiSharp.Delegates.Action___IntPtr___IntPtr___IntPtr_string8) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ImGuiSharp.Delegates.Action___IntPtr___IntPtr___IntPtr_string8));
            }

            set
            {
                ((__Internal*)__Instance)->ReadLineFn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::ImGuiSharp.Delegates.Action___IntPtr___IntPtr ApplyAllFn
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->ApplyAllFn;
                return __ptr0 == IntPtr.Zero? null : (global::ImGuiSharp.Delegates.Action___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ImGuiSharp.Delegates.Action___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->ApplyAllFn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::ImGuiSharp.Delegates.Action___IntPtr___IntPtr___IntPtr WriteAllFn
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->WriteAllFn;
                return __ptr0 == IntPtr.Zero? null : (global::ImGuiSharp.Delegates.Action___IntPtr___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ImGuiSharp.Delegates.Action___IntPtr___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->WriteAllFn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->UserData;
            }

            set
            {
                ((__Internal*)__Instance)->UserData = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImGuiMetricsConfig : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public byte ShowStackTool;
            public byte ShowWindowsRects;
            public byte ShowWindowsBeginOrder;
            public byte ShowTablesRects;
            public byte ShowDrawCmdMesh;
            public byte ShowDrawCmdBoundingBoxes;
            public int ShowWindowsRectsType;
            public int ShowTablesRectsType;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiMetricsConfig@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiMetricsConfig> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiMetricsConfig>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiMetricsConfig managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiMetricsConfig managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiMetricsConfig __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiMetricsConfig(native.ToPointer(), skipVTables);
        }

        internal static ImGuiMetricsConfig __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiMetricsConfig)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiMetricsConfig __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiMetricsConfig(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiMetricsConfig(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiMetricsConfig(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiMetricsConfig()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiMetricsConfig.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiMetricsConfig(global::ImGuiSharp.ImGuiMetricsConfig _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiMetricsConfig.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiMetricsConfig.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiMetricsConfig.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool ShowStackTool
        {
            get
            {
                return ((__Internal*)__Instance)->ShowStackTool != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ShowStackTool = (byte) (value ? 1 : 0);
            }
        }

        public bool ShowWindowsRects
        {
            get
            {
                return ((__Internal*)__Instance)->ShowWindowsRects != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ShowWindowsRects = (byte) (value ? 1 : 0);
            }
        }

        public bool ShowWindowsBeginOrder
        {
            get
            {
                return ((__Internal*)__Instance)->ShowWindowsBeginOrder != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ShowWindowsBeginOrder = (byte) (value ? 1 : 0);
            }
        }

        public bool ShowTablesRects
        {
            get
            {
                return ((__Internal*)__Instance)->ShowTablesRects != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ShowTablesRects = (byte) (value ? 1 : 0);
            }
        }

        public bool ShowDrawCmdMesh
        {
            get
            {
                return ((__Internal*)__Instance)->ShowDrawCmdMesh != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ShowDrawCmdMesh = (byte) (value ? 1 : 0);
            }
        }

        public bool ShowDrawCmdBoundingBoxes
        {
            get
            {
                return ((__Internal*)__Instance)->ShowDrawCmdBoundingBoxes != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ShowDrawCmdBoundingBoxes = (byte) (value ? 1 : 0);
            }
        }

        public int ShowWindowsRectsType
        {
            get
            {
                return ((__Internal*)__Instance)->ShowWindowsRectsType;
            }

            set
            {
                ((__Internal*)__Instance)->ShowWindowsRectsType = value;
            }
        }

        public int ShowTablesRectsType
        {
            get
            {
                return ((__Internal*)__Instance)->ShowTablesRectsType;
            }

            set
            {
                ((__Internal*)__Instance)->ShowTablesRectsType = value;
            }
        }
    }

    public unsafe partial class ImGuiStackLevelInfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            public uint ID;
            public sbyte QueryFrameCount;
            public byte QuerySuccess;
            public fixed sbyte Desc[58];

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiStackLevelInfo@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiStackLevelInfo> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiStackLevelInfo>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiStackLevelInfo managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiStackLevelInfo managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiStackLevelInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiStackLevelInfo(native.ToPointer(), skipVTables);
        }

        internal static ImGuiStackLevelInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiStackLevelInfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiStackLevelInfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiStackLevelInfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiStackLevelInfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiStackLevelInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiStackLevelInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiStackLevelInfo.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiStackLevelInfo(global::ImGuiSharp.ImGuiStackLevelInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiStackLevelInfo.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiStackLevelInfo.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiStackLevelInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ID
        {
            get
            {
                return ((__Internal*)__Instance)->ID;
            }

            set
            {
                ((__Internal*)__Instance)->ID = value;
            }
        }

        public sbyte QueryFrameCount
        {
            get
            {
                return ((__Internal*)__Instance)->QueryFrameCount;
            }

            set
            {
                ((__Internal*)__Instance)->QueryFrameCount = value;
            }
        }

        public bool QuerySuccess
        {
            get
            {
                return ((__Internal*)__Instance)->QuerySuccess != 0;
            }

            set
            {
                ((__Internal*)__Instance)->QuerySuccess = (byte) (value ? 1 : 0);
            }
        }

        public sbyte[] Desc
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->Desc, 58);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 58; i++)
                        ((__Internal*)__Instance)->Desc[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class ImVectorImGuiStackLevelInfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiStackLevelInfo@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiStackLevelInfo> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiStackLevelInfo>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImGuiStackLevelInfo managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImGuiStackLevelInfo managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiStackLevelInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiStackLevelInfo(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiStackLevelInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiStackLevelInfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiStackLevelInfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiStackLevelInfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiStackLevelInfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiStackLevelInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiStackLevelInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiStackLevelInfo.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiStackLevelInfo(global::ImGuiSharp.ImVectorImGuiStackLevelInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiStackLevelInfo.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImGuiStackLevelInfo.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImGuiStackLevelInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImGuiStackLevelInfo Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiStackLevelInfo.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiStackTool : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            public int LastActiveFrame;
            public int StackLevel;
            public uint QueryId;
            public global::ImGuiSharp.ImVectorImGuiStackLevelInfo.__Internal Results;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiStackTool@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiStackTool> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiStackTool>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiStackTool managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiStackTool managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiStackTool __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiStackTool(native.ToPointer(), skipVTables);
        }

        internal static ImGuiStackTool __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiStackTool)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiStackTool __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiStackTool(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiStackTool(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiStackTool(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiStackTool()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiStackTool.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiStackTool(global::ImGuiSharp.ImGuiStackTool _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiStackTool.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiStackTool.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiStackTool.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int LastActiveFrame
        {
            get
            {
                return ((__Internal*)__Instance)->LastActiveFrame;
            }

            set
            {
                ((__Internal*)__Instance)->LastActiveFrame = value;
            }
        }

        public int StackLevel
        {
            get
            {
                return ((__Internal*)__Instance)->StackLevel;
            }

            set
            {
                ((__Internal*)__Instance)->StackLevel = value;
            }
        }

        public uint QueryId
        {
            get
            {
                return ((__Internal*)__Instance)->QueryId;
            }

            set
            {
                ((__Internal*)__Instance)->QueryId = value;
            }
        }

        public global::ImGuiSharp.ImVectorImGuiStackLevelInfo Results
        {
            get
            {
                return global::ImGuiSharp.ImVectorImGuiStackLevelInfo.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Results));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Results = *(global::ImGuiSharp.ImVectorImGuiStackLevelInfo.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiContextHook : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            public uint HookId;
            public global::ImGuiSharp.ImGuiContextHookType Type;
            public uint Owner;
            public __IntPtr Callback;
            public __IntPtr UserData;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiContextHook@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiContextHook> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiContextHook>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiContextHook managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiContextHook managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiContextHook __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiContextHook(native.ToPointer(), skipVTables);
        }

        internal static ImGuiContextHook __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiContextHook)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiContextHook __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiContextHook(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiContextHook(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiContextHook(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiContextHook()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiContextHook.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiContextHook(global::ImGuiSharp.ImGuiContextHook _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiContextHook.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiContextHook.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiContextHook.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint HookId
        {
            get
            {
                return ((__Internal*)__Instance)->HookId;
            }

            set
            {
                ((__Internal*)__Instance)->HookId = value;
            }
        }

        public global::ImGuiSharp.ImGuiContextHookType Type
        {
            get
            {
                return ((__Internal*)__Instance)->Type;
            }

            set
            {
                ((__Internal*)__Instance)->Type = value;
            }
        }

        public uint Owner
        {
            get
            {
                return ((__Internal*)__Instance)->Owner;
            }

            set
            {
                ((__Internal*)__Instance)->Owner = value;
            }
        }

        public global::ImGuiSharp.ImGuiContextHookCallback Callback
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Callback;
                return __ptr0 == IntPtr.Zero? null : (global::ImGuiSharp.ImGuiContextHookCallback) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ImGuiSharp.ImGuiContextHookCallback));
            }

            set
            {
                ((__Internal*)__Instance)->Callback = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->UserData;
            }

            set
            {
                ((__Internal*)__Instance)->UserData = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImVectorImGuiInputEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiInputEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiInputEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiInputEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImGuiInputEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImGuiInputEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiInputEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiInputEvent(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiInputEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiInputEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiInputEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiInputEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiInputEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiInputEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiInputEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiInputEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiInputEvent(global::ImGuiSharp.ImVectorImGuiInputEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiInputEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImGuiInputEvent.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImGuiInputEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImGuiInputEvent Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiInputEvent.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiWindowPtr : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiWindowPtr@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiWindowPtr> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiWindowPtr>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImGuiWindowPtr managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImGuiWindowPtr managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiWindowPtr __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiWindowPtr(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiWindowPtr __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiWindowPtr)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiWindowPtr __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiWindowPtr(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiWindowPtr(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiWindowPtr(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiWindowPtr()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiWindowPtr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiWindowPtr(global::ImGuiSharp.ImVectorImGuiWindowPtr _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiWindowPtr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImGuiWindowPtr.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImGuiWindowPtr.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImGuiWindow Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                var __value = value is null ? __IntPtr.Zero : value.__Instance;
                ((__Internal*)__Instance)->Data = new __IntPtr(&__value);
            }
        }
    }

    public unsafe partial class ImVectorImGuiWindowStackData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiWindowStackData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiWindowStackData> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiWindowStackData>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImGuiWindowStackData managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImGuiWindowStackData managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiWindowStackData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiWindowStackData(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiWindowStackData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiWindowStackData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiWindowStackData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiWindowStackData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiWindowStackData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiWindowStackData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiWindowStackData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiWindowStackData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiWindowStackData(global::ImGuiSharp.ImVectorImGuiWindowStackData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiWindowStackData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImGuiWindowStackData.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImGuiWindowStackData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImGuiWindowStackData Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiWindowStackData.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiColorMod : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiColorMod@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiColorMod> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiColorMod>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImGuiColorMod managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImGuiColorMod managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiColorMod __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiColorMod(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiColorMod __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiColorMod)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiColorMod __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiColorMod(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiColorMod(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiColorMod(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiColorMod()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiColorMod.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiColorMod(global::ImGuiSharp.ImVectorImGuiColorMod _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiColorMod.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImGuiColorMod.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImGuiColorMod.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImGuiColorMod Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiColorMod.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiStyleMod : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiStyleMod@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiStyleMod> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiStyleMod>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImGuiStyleMod managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImGuiStyleMod managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiStyleMod __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiStyleMod(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiStyleMod __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiStyleMod)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiStyleMod __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiStyleMod(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiStyleMod(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiStyleMod(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiStyleMod()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiStyleMod.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiStyleMod(global::ImGuiSharp.ImVectorImGuiStyleMod _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiStyleMod.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImGuiStyleMod.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImGuiStyleMod.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImGuiStyleMod Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiStyleMod.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiID : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiID@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiID> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiID>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImGuiID managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImGuiID managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiID __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiID(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiID __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiID)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiID __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiID(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiID(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiID(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiID()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiID.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiID(global::ImGuiSharp.ImVectorImGuiID _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiID.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImGuiID.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImGuiID.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public uint* Data
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->Data;
            }

            set
            {
                ((__Internal*)__Instance)->Data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImVectorImGuiItemFlags : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiItemFlags@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiItemFlags> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiItemFlags>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImGuiItemFlags managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImGuiItemFlags managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiItemFlags __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiItemFlags(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiItemFlags __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiItemFlags)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiItemFlags __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiItemFlags(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiItemFlags(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiItemFlags(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiItemFlags()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiItemFlags.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiItemFlags(global::ImGuiSharp.ImVectorImGuiItemFlags _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiItemFlags.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImGuiItemFlags.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImGuiItemFlags.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public int* Data
        {
            get
            {
                return (int*) ((__Internal*)__Instance)->Data;
            }

            set
            {
                ((__Internal*)__Instance)->Data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImVectorImGuiGroupData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiGroupData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiGroupData> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiGroupData>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImGuiGroupData managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImGuiGroupData managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiGroupData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiGroupData(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiGroupData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiGroupData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiGroupData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiGroupData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiGroupData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiGroupData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiGroupData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiGroupData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiGroupData(global::ImGuiSharp.ImVectorImGuiGroupData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiGroupData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImGuiGroupData.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImGuiGroupData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImGuiGroupData Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiGroupData.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiPopupData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiPopupData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiPopupData> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiPopupData>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImGuiPopupData managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImGuiPopupData managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiPopupData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiPopupData(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiPopupData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiPopupData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiPopupData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiPopupData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiPopupData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiPopupData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiPopupData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiPopupData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiPopupData(global::ImGuiSharp.ImVectorImGuiPopupData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiPopupData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImGuiPopupData.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImGuiPopupData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImGuiPopupData Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiPopupData.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiViewportPPtr : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiViewportPPtr@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiViewportPPtr> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiViewportPPtr>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImGuiViewportPPtr managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImGuiViewportPPtr managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiViewportPPtr __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiViewportPPtr(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiViewportPPtr __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiViewportPPtr)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiViewportPPtr __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiViewportPPtr(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiViewportPPtr(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiViewportPPtr(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiViewportPPtr()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiViewportPPtr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiViewportPPtr(global::ImGuiSharp.ImVectorImGuiViewportPPtr _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiViewportPPtr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImGuiViewportPPtr.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImGuiViewportPPtr.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImGuiViewportP Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiViewportP.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                var __value = value is null ? __IntPtr.Zero : value.__Instance;
                ((__Internal*)__Instance)->Data = new __IntPtr(&__value);
            }
        }
    }

    public unsafe partial class ImVector_unsigned_char : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_unsigned_char@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVector_unsigned_char> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVector_unsigned_char>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVector_unsigned_char managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVector_unsigned_char managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVector_unsigned_char __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVector_unsigned_char(native.ToPointer(), skipVTables);
        }

        internal static ImVector_unsigned_char __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVector_unsigned_char)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVector_unsigned_char __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVector_unsigned_char(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVector_unsigned_char(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVector_unsigned_char(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVector_unsigned_char()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVector_unsigned_char.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVector_unsigned_char(global::ImGuiSharp.ImVector_unsigned_char _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVector_unsigned_char.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVector_unsigned_char.__Internal*) __Instance) = *((global::ImGuiSharp.ImVector_unsigned_char.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public byte* Data
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->Data;
            }

            set
            {
                ((__Internal*)__Instance)->Data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImVectorImGuiListClipperData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiListClipperData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiListClipperData> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiListClipperData>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImGuiListClipperData managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImGuiListClipperData managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiListClipperData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiListClipperData(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiListClipperData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiListClipperData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiListClipperData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiListClipperData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiListClipperData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiListClipperData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiListClipperData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiListClipperData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiListClipperData(global::ImGuiSharp.ImVectorImGuiListClipperData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiListClipperData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImGuiListClipperData.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImGuiListClipperData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImGuiListClipperData Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiListClipperData.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiTableTempData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiTableTempData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiTableTempData> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiTableTempData>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImGuiTableTempData managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImGuiTableTempData managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiTableTempData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiTableTempData(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiTableTempData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiTableTempData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiTableTempData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiTableTempData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiTableTempData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiTableTempData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiTableTempData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiTableTempData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiTableTempData(global::ImGuiSharp.ImVectorImGuiTableTempData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiTableTempData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImGuiTableTempData.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImGuiTableTempData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImGuiTableTempData Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiTableTempData.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiTable : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiTable@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiTable> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiTable>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImGuiTable managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImGuiTable managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiTable __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiTable(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiTable __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiTable)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiTable __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiTable(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiTable(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiTable(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiTable()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiTable.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiTable(global::ImGuiSharp.ImVectorImGuiTable _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiTable.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImGuiTable.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImGuiTable.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImGuiTable Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiTable.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImPoolImGuiTable : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            public global::ImGuiSharp.ImVectorImGuiTable.__Internal Buf;
            public global::ImGuiSharp.ImGuiStorage.__Internal Map;
            public int FreeIdx;
            public int AliveCount;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImPool_ImGuiTable@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImPoolImGuiTable> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImPoolImGuiTable>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImPoolImGuiTable managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImPoolImGuiTable managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImPoolImGuiTable __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImPoolImGuiTable(native.ToPointer(), skipVTables);
        }

        internal static ImPoolImGuiTable __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImPoolImGuiTable)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImPoolImGuiTable __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImPoolImGuiTable(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImPoolImGuiTable(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImPoolImGuiTable(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImPoolImGuiTable()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImPoolImGuiTable.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImPoolImGuiTable(global::ImGuiSharp.ImPoolImGuiTable _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImPoolImGuiTable.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImPoolImGuiTable.__Internal*) __Instance) = *((global::ImGuiSharp.ImPoolImGuiTable.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGuiSharp.ImVectorImGuiTable Buf
        {
            get
            {
                return global::ImGuiSharp.ImVectorImGuiTable.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Buf));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Buf = *(global::ImGuiSharp.ImVectorImGuiTable.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiStorage Map
        {
            get
            {
                return global::ImGuiSharp.ImGuiStorage.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Map));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Map = *(global::ImGuiSharp.ImGuiStorage.__Internal*) value.__Instance;
            }
        }

        public int FreeIdx
        {
            get
            {
                return ((__Internal*)__Instance)->FreeIdx;
            }

            set
            {
                ((__Internal*)__Instance)->FreeIdx = value;
            }
        }

        public int AliveCount
        {
            get
            {
                return ((__Internal*)__Instance)->AliveCount;
            }

            set
            {
                ((__Internal*)__Instance)->AliveCount = value;
            }
        }
    }

    public unsafe partial class ImVectorImGuiTabBar : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiTabBar@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiTabBar> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiTabBar>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImGuiTabBar managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImGuiTabBar managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiTabBar __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiTabBar(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiTabBar __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiTabBar)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiTabBar __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiTabBar(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiTabBar(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiTabBar(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiTabBar()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiTabBar.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiTabBar(global::ImGuiSharp.ImVectorImGuiTabBar _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiTabBar.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImGuiTabBar.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImGuiTabBar.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImGuiTabBar Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiTabBar.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImPoolImGuiTabBar : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            public global::ImGuiSharp.ImVectorImGuiTabBar.__Internal Buf;
            public global::ImGuiSharp.ImGuiStorage.__Internal Map;
            public int FreeIdx;
            public int AliveCount;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImPool_ImGuiTabBar@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImPoolImGuiTabBar> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImPoolImGuiTabBar>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImPoolImGuiTabBar managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImPoolImGuiTabBar managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImPoolImGuiTabBar __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImPoolImGuiTabBar(native.ToPointer(), skipVTables);
        }

        internal static ImPoolImGuiTabBar __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImPoolImGuiTabBar)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImPoolImGuiTabBar __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImPoolImGuiTabBar(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImPoolImGuiTabBar(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImPoolImGuiTabBar(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImPoolImGuiTabBar()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImPoolImGuiTabBar.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImPoolImGuiTabBar(global::ImGuiSharp.ImPoolImGuiTabBar _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImPoolImGuiTabBar.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImPoolImGuiTabBar.__Internal*) __Instance) = *((global::ImGuiSharp.ImPoolImGuiTabBar.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGuiSharp.ImVectorImGuiTabBar Buf
        {
            get
            {
                return global::ImGuiSharp.ImVectorImGuiTabBar.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Buf));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Buf = *(global::ImGuiSharp.ImVectorImGuiTabBar.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiStorage Map
        {
            get
            {
                return global::ImGuiSharp.ImGuiStorage.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Map));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Map = *(global::ImGuiSharp.ImGuiStorage.__Internal*) value.__Instance;
            }
        }

        public int FreeIdx
        {
            get
            {
                return ((__Internal*)__Instance)->FreeIdx;
            }

            set
            {
                ((__Internal*)__Instance)->FreeIdx = value;
            }
        }

        public int AliveCount
        {
            get
            {
                return ((__Internal*)__Instance)->AliveCount;
            }

            set
            {
                ((__Internal*)__Instance)->AliveCount = value;
            }
        }
    }

    public unsafe partial class ImVectorImGuiPtrOrIndex : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiPtrOrIndex@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiPtrOrIndex> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiPtrOrIndex>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImGuiPtrOrIndex managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImGuiPtrOrIndex managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiPtrOrIndex __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiPtrOrIndex(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiPtrOrIndex __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiPtrOrIndex)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiPtrOrIndex __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiPtrOrIndex(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiPtrOrIndex(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiPtrOrIndex(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiPtrOrIndex()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiPtrOrIndex.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiPtrOrIndex(global::ImGuiSharp.ImVectorImGuiPtrOrIndex _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiPtrOrIndex.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImGuiPtrOrIndex.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImGuiPtrOrIndex.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImGuiPtrOrIndex Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiPtrOrIndex.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiShrinkWidthItem : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiShrinkWidthItem@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiShrinkWidthItem> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiShrinkWidthItem>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImGuiShrinkWidthItem managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImGuiShrinkWidthItem managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiShrinkWidthItem __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiShrinkWidthItem(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiShrinkWidthItem __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiShrinkWidthItem)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiShrinkWidthItem __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiShrinkWidthItem(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiShrinkWidthItem(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiShrinkWidthItem(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiShrinkWidthItem()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiShrinkWidthItem.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiShrinkWidthItem(global::ImGuiSharp.ImVectorImGuiShrinkWidthItem _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiShrinkWidthItem.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImGuiShrinkWidthItem.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImGuiShrinkWidthItem.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImGuiShrinkWidthItem Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiShrinkWidthItem.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiSettingsHandler : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiSettingsHandler@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiSettingsHandler> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiSettingsHandler>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImGuiSettingsHandler managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImGuiSettingsHandler managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiSettingsHandler __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiSettingsHandler(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiSettingsHandler __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiSettingsHandler)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiSettingsHandler __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiSettingsHandler(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiSettingsHandler(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiSettingsHandler(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiSettingsHandler()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiSettingsHandler.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiSettingsHandler(global::ImGuiSharp.ImVectorImGuiSettingsHandler _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiSettingsHandler.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImGuiSettingsHandler.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImGuiSettingsHandler.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImGuiSettingsHandler Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiSettingsHandler.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImChunkStreamImGuiWindowSettings : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public global::ImGuiSharp.ImVector_char.__Internal Buf;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImChunkStream_ImGuiWindowSettings@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImChunkStreamImGuiWindowSettings> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImChunkStreamImGuiWindowSettings>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImChunkStreamImGuiWindowSettings managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImChunkStreamImGuiWindowSettings managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImChunkStreamImGuiWindowSettings __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImChunkStreamImGuiWindowSettings(native.ToPointer(), skipVTables);
        }

        internal static ImChunkStreamImGuiWindowSettings __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImChunkStreamImGuiWindowSettings)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImChunkStreamImGuiWindowSettings __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImChunkStreamImGuiWindowSettings(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImChunkStreamImGuiWindowSettings(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImChunkStreamImGuiWindowSettings(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImChunkStreamImGuiWindowSettings()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImChunkStreamImGuiWindowSettings.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImChunkStreamImGuiWindowSettings(global::ImGuiSharp.ImChunkStreamImGuiWindowSettings _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImChunkStreamImGuiWindowSettings.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImChunkStreamImGuiWindowSettings.__Internal*) __Instance) = *((global::ImGuiSharp.ImChunkStreamImGuiWindowSettings.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGuiSharp.ImVector_char Buf
        {
            get
            {
                return global::ImGuiSharp.ImVector_char.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Buf));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Buf = *(global::ImGuiSharp.ImVector_char.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImChunkStreamImGuiTableSettings : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public global::ImGuiSharp.ImVector_char.__Internal Buf;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImChunkStream_ImGuiTableSettings@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImChunkStreamImGuiTableSettings> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImChunkStreamImGuiTableSettings>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImChunkStreamImGuiTableSettings managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImChunkStreamImGuiTableSettings managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImChunkStreamImGuiTableSettings __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImChunkStreamImGuiTableSettings(native.ToPointer(), skipVTables);
        }

        internal static ImChunkStreamImGuiTableSettings __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImChunkStreamImGuiTableSettings)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImChunkStreamImGuiTableSettings __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImChunkStreamImGuiTableSettings(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImChunkStreamImGuiTableSettings(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImChunkStreamImGuiTableSettings(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImChunkStreamImGuiTableSettings()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImChunkStreamImGuiTableSettings.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImChunkStreamImGuiTableSettings(global::ImGuiSharp.ImChunkStreamImGuiTableSettings _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImChunkStreamImGuiTableSettings.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImChunkStreamImGuiTableSettings.__Internal*) __Instance) = *((global::ImGuiSharp.ImChunkStreamImGuiTableSettings.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGuiSharp.ImVector_char Buf
        {
            get
            {
                return global::ImGuiSharp.ImVector_char.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Buf));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Buf = *(global::ImGuiSharp.ImVector_char.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiContextHook : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiContextHook@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiContextHook> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiContextHook>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImGuiContextHook managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImGuiContextHook managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiContextHook __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiContextHook(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiContextHook __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiContextHook)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiContextHook __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiContextHook(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiContextHook(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiContextHook(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiContextHook()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiContextHook.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiContextHook(global::ImGuiSharp.ImVectorImGuiContextHook _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiContextHook.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImGuiContextHook.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImGuiContextHook.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImGuiContextHook Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiContextHook.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiContext : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 25048)]
        public partial struct __Internal
        {
            public byte Initialized;
            public byte FontAtlasOwnedByContext;
            public global::ImGuiSharp.ImGuiIO.__Internal IO;
            public global::ImGuiSharp.ImVectorImGuiInputEvent.__Internal InputEventsQueue;
            public global::ImGuiSharp.ImVectorImGuiInputEvent.__Internal InputEventsTrail;
            public global::ImGuiSharp.ImGuiStyle.__Internal Style;
            public __IntPtr Font;
            public float FontSize;
            public float FontBaseSize;
            public global::ImGuiSharp.ImDrawListSharedData.__Internal DrawListSharedData;
            public double Time;
            public int FrameCount;
            public int FrameCountEnded;
            public int FrameCountRendered;
            public byte WithinFrameScope;
            public byte WithinFrameScopeWithImplicitWindow;
            public byte WithinEndChild;
            public byte GcCompactAll;
            public byte TestEngineHookItems;
            public __IntPtr TestEngine;
            public global::ImGuiSharp.ImVectorImGuiWindowPtr.__Internal Windows;
            public global::ImGuiSharp.ImVectorImGuiWindowPtr.__Internal WindowsFocusOrder;
            public global::ImGuiSharp.ImVectorImGuiWindowPtr.__Internal WindowsTempSortBuffer;
            public global::ImGuiSharp.ImVectorImGuiWindowStackData.__Internal CurrentWindowStack;
            public global::ImGuiSharp.ImGuiStorage.__Internal WindowsById;
            public int WindowsActiveCount;
            public global::ImGuiSharp.ImVec2.__Internal WindowsHoverPadding;
            public __IntPtr CurrentWindow;
            public __IntPtr HoveredWindow;
            public __IntPtr HoveredWindowUnderMovingWindow;
            public __IntPtr MovingWindow;
            public __IntPtr WheelingWindow;
            public global::ImGuiSharp.ImVec2.__Internal WheelingWindowRefMousePos;
            public float WheelingWindowTimer;
            public uint DebugHookIdInfo;
            public uint HoveredId;
            public uint HoveredIdPreviousFrame;
            public byte HoveredIdAllowOverlap;
            public byte HoveredIdUsingMouseWheel;
            public byte HoveredIdPreviousFrameUsingMouseWheel;
            public byte HoveredIdDisabled;
            public float HoveredIdTimer;
            public float HoveredIdNotActiveTimer;
            public uint ActiveId;
            public uint ActiveIdIsAlive;
            public float ActiveIdTimer;
            public byte ActiveIdIsJustActivated;
            public byte ActiveIdAllowOverlap;
            public byte ActiveIdNoClearOnFocusLoss;
            public byte ActiveIdHasBeenPressedBefore;
            public byte ActiveIdHasBeenEditedBefore;
            public byte ActiveIdHasBeenEditedThisFrame;
            public byte ActiveIdUsingMouseWheel;
            public uint ActiveIdUsingNavDirMask;
            public uint ActiveIdUsingNavInputMask;
            public global::ImGuiSharp.ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN.__Internal ActiveIdUsingKeyInputMask;
            public global::ImGuiSharp.ImVec2.__Internal ActiveIdClickOffset;
            public __IntPtr ActiveIdWindow;
            public global::ImGuiSharp.ImGuiInputSource ActiveIdSource;
            public int ActiveIdMouseButton;
            public uint ActiveIdPreviousFrame;
            public byte ActiveIdPreviousFrameIsAlive;
            public byte ActiveIdPreviousFrameHasBeenEditedBefore;
            public __IntPtr ActiveIdPreviousFrameWindow;
            public uint LastActiveId;
            public float LastActiveIdTimer;
            public int CurrentItemFlags;
            public global::ImGuiSharp.ImGuiNextItemData.__Internal NextItemData;
            public global::ImGuiSharp.ImGuiLastItemData.__Internal LastItemData;
            public global::ImGuiSharp.ImGuiNextWindowData.__Internal NextWindowData;
            public global::ImGuiSharp.ImVectorImGuiColorMod.__Internal ColorStack;
            public global::ImGuiSharp.ImVectorImGuiStyleMod.__Internal StyleVarStack;
            public global::ImGuiSharp.ImVectorImFontPtr.__Internal FontStack;
            public global::ImGuiSharp.ImVectorImGuiID.__Internal FocusScopeStack;
            public global::ImGuiSharp.ImVectorImGuiItemFlags.__Internal ItemFlagsStack;
            public global::ImGuiSharp.ImVectorImGuiGroupData.__Internal GroupStack;
            public global::ImGuiSharp.ImVectorImGuiPopupData.__Internal OpenPopupStack;
            public global::ImGuiSharp.ImVectorImGuiPopupData.__Internal BeginPopupStack;
            public int BeginMenuCount;
            public global::ImGuiSharp.ImVectorImGuiViewportPPtr.__Internal Viewports;
            public __IntPtr NavWindow;
            public uint NavId;
            public uint NavFocusScopeId;
            public uint NavActivateId;
            public uint NavActivateDownId;
            public uint NavActivatePressedId;
            public uint NavActivateInputId;
            public int NavActivateFlags;
            public uint NavJustMovedToId;
            public uint NavJustMovedToFocusScopeId;
            public int NavJustMovedToKeyMods;
            public uint NavNextActivateId;
            public int NavNextActivateFlags;
            public global::ImGuiSharp.ImGuiInputSource NavInputSource;
            public global::ImGuiSharp.ImGuiNavLayer NavLayer;
            public byte NavIdIsAlive;
            public byte NavMousePosDirty;
            public byte NavDisableHighlight;
            public byte NavDisableMouseHover;
            public byte NavAnyRequest;
            public byte NavInitRequest;
            public byte NavInitRequestFromMove;
            public uint NavInitResultId;
            public global::ImGuiSharp.ImRect.__Internal NavInitResultRectRel;
            public byte NavMoveSubmitted;
            public byte NavMoveScoringItems;
            public byte NavMoveForwardToNextFrame;
            public int NavMoveFlags;
            public int NavMoveScrollFlags;
            public int NavMoveKeyMods;
            public int NavMoveDir;
            public int NavMoveDirForDebug;
            public int NavMoveClipDir;
            public global::ImGuiSharp.ImRect.__Internal NavScoringRect;
            public global::ImGuiSharp.ImRect.__Internal NavScoringNoClipRect;
            public int NavScoringDebugCount;
            public int NavTabbingDir;
            public int NavTabbingCounter;
            public global::ImGuiSharp.ImGuiNavItemData.__Internal NavMoveResultLocal;
            public global::ImGuiSharp.ImGuiNavItemData.__Internal NavMoveResultLocalVisible;
            public global::ImGuiSharp.ImGuiNavItemData.__Internal NavMoveResultOther;
            public global::ImGuiSharp.ImGuiNavItemData.__Internal NavTabbingResultFirst;
            public __IntPtr NavWindowingTarget;
            public __IntPtr NavWindowingTargetAnim;
            public __IntPtr NavWindowingListWindow;
            public float NavWindowingTimer;
            public float NavWindowingHighlightAlpha;
            public byte NavWindowingToggleLayer;
            public float DimBgRatio;
            public int MouseCursor;
            public byte DragDropActive;
            public byte DragDropWithinSource;
            public byte DragDropWithinTarget;
            public int DragDropSourceFlags;
            public int DragDropSourceFrameCount;
            public int DragDropMouseButton;
            public global::ImGuiSharp.ImGuiPayload.__Internal DragDropPayload;
            public global::ImGuiSharp.ImRect.__Internal DragDropTargetRect;
            public uint DragDropTargetId;
            public int DragDropAcceptFlags;
            public float DragDropAcceptIdCurrRectSurface;
            public uint DragDropAcceptIdCurr;
            public uint DragDropAcceptIdPrev;
            public int DragDropAcceptFrameCount;
            public uint DragDropHoldJustPressedId;
            public global::ImGuiSharp.ImVector_unsigned_char.__Internal DragDropPayloadBufHeap;
            public fixed byte DragDropPayloadBufLocal[16];
            public int ClipperTempDataStacked;
            public global::ImGuiSharp.ImVectorImGuiListClipperData.__Internal ClipperTempData;
            public __IntPtr CurrentTable;
            public int TablesTempDataStacked;
            public global::ImGuiSharp.ImVectorImGuiTableTempData.__Internal TablesTempData;
            public global::ImGuiSharp.ImPoolImGuiTable.__Internal Tables;
            public global::ImGuiSharp.ImVector_float.__Internal TablesLastTimeActive;
            public global::ImGuiSharp.ImVectorImDrawChannel.__Internal DrawChannelsTempMergeBuffer;
            public __IntPtr CurrentTabBar;
            public global::ImGuiSharp.ImPoolImGuiTabBar.__Internal TabBars;
            public global::ImGuiSharp.ImVectorImGuiPtrOrIndex.__Internal CurrentTabBarStack;
            public global::ImGuiSharp.ImVectorImGuiShrinkWidthItem.__Internal ShrinkWidthBuffer;
            public global::ImGuiSharp.ImVec2.__Internal MouseLastValidPos;
            public global::ImGuiSharp.ImGuiInputTextState.__Internal InputTextState;
            public global::ImGuiSharp.ImFont.__Internal InputTextPasswordFont;
            public uint TempInputId;
            public int ColorEditOptions;
            public float ColorEditLastHue;
            public float ColorEditLastSat;
            public uint ColorEditLastColor;
            public global::ImGuiSharp.ImVec4.__Internal ColorPickerRef;
            public global::ImGuiSharp.ImGuiComboPreviewData.__Internal ComboPreviewData;
            public float SliderCurrentAccum;
            public byte SliderCurrentAccumDirty;
            public byte DragCurrentAccumDirty;
            public float DragCurrentAccum;
            public float DragSpeedDefaultRatio;
            public float ScrollbarClickDeltaToGrabCenter;
            public float DisabledAlphaBackup;
            public short DisabledStackSize;
            public short TooltipOverrideCount;
            public float TooltipSlowDelay;
            public global::ImGuiSharp.ImVector_char.__Internal ClipboardHandlerData;
            public global::ImGuiSharp.ImVectorImGuiID.__Internal MenusIdSubmittedThisFrame;
            public global::ImGuiSharp.ImGuiPlatformImeData.__Internal PlatformImeData;
            public global::ImGuiSharp.ImGuiPlatformImeData.__Internal PlatformImeDataPrev;
            public sbyte PlatformLocaleDecimalPoint;
            public byte SettingsLoaded;
            public float SettingsDirtyTimer;
            public global::ImGuiSharp.ImGuiTextBuffer.__Internal SettingsIniData;
            public global::ImGuiSharp.ImVectorImGuiSettingsHandler.__Internal SettingsHandlers;
            public global::ImGuiSharp.ImChunkStreamImGuiWindowSettings.__Internal SettingsWindows;
            public global::ImGuiSharp.ImChunkStreamImGuiTableSettings.__Internal SettingsTables;
            public global::ImGuiSharp.ImVectorImGuiContextHook.__Internal Hooks;
            public uint HookIdNext;
            public byte LogEnabled;
            public global::ImGuiSharp.ImGuiLogType LogType;
            public __IntPtr LogFile;
            public global::ImGuiSharp.ImGuiTextBuffer.__Internal LogBuffer;
            public __IntPtr LogNextPrefix;
            public __IntPtr LogNextSuffix;
            public float LogLinePosY;
            public byte LogLineFirstItem;
            public int LogDepthRef;
            public int LogDepthToExpand;
            public int LogDepthToExpandDefault;
            public byte DebugItemPickerActive;
            public uint DebugItemPickerBreakId;
            public global::ImGuiSharp.ImGuiMetricsConfig.__Internal DebugMetricsConfig;
            public global::ImGuiSharp.ImGuiStackTool.__Internal DebugStackTool;
            public fixed float FramerateSecPerFrame[120];
            public int FramerateSecPerFrameIdx;
            public int FramerateSecPerFrameCount;
            public float FramerateSecPerFrameAccum;
            public int WantCaptureMouseNextFrame;
            public int WantCaptureKeyboardNextFrame;
            public int WantTextInputNextFrame;
            public fixed sbyte TempBuffer[3073];

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiContext@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiContext> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiContext>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiContext managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiContext managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        private bool __LogNextPrefix_OwnsNativeMemory = false;
        private bool __LogNextSuffix_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static ImGuiContext __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiContext(native.ToPointer(), skipVTables);
        }

        internal static ImGuiContext __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiContext)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiContext __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiContext(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiContext(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiContext(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiContext()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiContext.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiContext(global::ImGuiSharp.ImGuiContext _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiContext.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiContext.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiContext.__Internal*) _0.__Instance);
            if (_0.__LogNextPrefix_OwnsNativeMemory)
                this.LogNextPrefix = _0.LogNextPrefix;
            if (_0.__LogNextSuffix_OwnsNativeMemory)
                this.LogNextSuffix = _0.LogNextSuffix;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__LogNextPrefix_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->LogNextPrefix);
            if (__LogNextSuffix_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->LogNextSuffix);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool Initialized
        {
            get
            {
                return ((__Internal*)__Instance)->Initialized != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Initialized = (byte) (value ? 1 : 0);
            }
        }

        public bool FontAtlasOwnedByContext
        {
            get
            {
                return ((__Internal*)__Instance)->FontAtlasOwnedByContext != 0;
            }

            set
            {
                ((__Internal*)__Instance)->FontAtlasOwnedByContext = (byte) (value ? 1 : 0);
            }
        }

        public global::ImGuiSharp.ImGuiIO IO
        {
            get
            {
                return global::ImGuiSharp.ImGuiIO.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->IO));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->IO = *(global::ImGuiSharp.ImGuiIO.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVectorImGuiInputEvent InputEventsQueue
        {
            get
            {
                return global::ImGuiSharp.ImVectorImGuiInputEvent.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->InputEventsQueue));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->InputEventsQueue = *(global::ImGuiSharp.ImVectorImGuiInputEvent.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVectorImGuiInputEvent InputEventsTrail
        {
            get
            {
                return global::ImGuiSharp.ImVectorImGuiInputEvent.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->InputEventsTrail));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->InputEventsTrail = *(global::ImGuiSharp.ImVectorImGuiInputEvent.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiStyle Style
        {
            get
            {
                return global::ImGuiSharp.ImGuiStyle.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Style));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Style = *(global::ImGuiSharp.ImGuiStyle.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImFont Font
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImFont.__GetOrCreateInstance(((__Internal*)__Instance)->Font, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Font = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public float FontSize
        {
            get
            {
                return ((__Internal*)__Instance)->FontSize;
            }

            set
            {
                ((__Internal*)__Instance)->FontSize = value;
            }
        }

        public float FontBaseSize
        {
            get
            {
                return ((__Internal*)__Instance)->FontBaseSize;
            }

            set
            {
                ((__Internal*)__Instance)->FontBaseSize = value;
            }
        }

        public global::ImGuiSharp.ImDrawListSharedData DrawListSharedData
        {
            get
            {
                return global::ImGuiSharp.ImDrawListSharedData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DrawListSharedData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DrawListSharedData = *(global::ImGuiSharp.ImDrawListSharedData.__Internal*) value.__Instance;
            }
        }

        public double Time
        {
            get
            {
                return ((__Internal*)__Instance)->Time;
            }

            set
            {
                ((__Internal*)__Instance)->Time = value;
            }
        }

        public int FrameCount
        {
            get
            {
                return ((__Internal*)__Instance)->FrameCount;
            }

            set
            {
                ((__Internal*)__Instance)->FrameCount = value;
            }
        }

        public int FrameCountEnded
        {
            get
            {
                return ((__Internal*)__Instance)->FrameCountEnded;
            }

            set
            {
                ((__Internal*)__Instance)->FrameCountEnded = value;
            }
        }

        public int FrameCountRendered
        {
            get
            {
                return ((__Internal*)__Instance)->FrameCountRendered;
            }

            set
            {
                ((__Internal*)__Instance)->FrameCountRendered = value;
            }
        }

        public bool WithinFrameScope
        {
            get
            {
                return ((__Internal*)__Instance)->WithinFrameScope != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WithinFrameScope = (byte) (value ? 1 : 0);
            }
        }

        public bool WithinFrameScopeWithImplicitWindow
        {
            get
            {
                return ((__Internal*)__Instance)->WithinFrameScopeWithImplicitWindow != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WithinFrameScopeWithImplicitWindow = (byte) (value ? 1 : 0);
            }
        }

        public bool WithinEndChild
        {
            get
            {
                return ((__Internal*)__Instance)->WithinEndChild != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WithinEndChild = (byte) (value ? 1 : 0);
            }
        }

        public bool GcCompactAll
        {
            get
            {
                return ((__Internal*)__Instance)->GcCompactAll != 0;
            }

            set
            {
                ((__Internal*)__Instance)->GcCompactAll = (byte) (value ? 1 : 0);
            }
        }

        public bool TestEngineHookItems
        {
            get
            {
                return ((__Internal*)__Instance)->TestEngineHookItems != 0;
            }

            set
            {
                ((__Internal*)__Instance)->TestEngineHookItems = (byte) (value ? 1 : 0);
            }
        }

        public __IntPtr TestEngine
        {
            get
            {
                return ((__Internal*)__Instance)->TestEngine;
            }

            set
            {
                ((__Internal*)__Instance)->TestEngine = (__IntPtr) value;
            }
        }

        public global::ImGuiSharp.ImVectorImGuiWindowPtr Windows
        {
            get
            {
                return global::ImGuiSharp.ImVectorImGuiWindowPtr.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Windows));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Windows = *(global::ImGuiSharp.ImVectorImGuiWindowPtr.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVectorImGuiWindowPtr WindowsFocusOrder
        {
            get
            {
                return global::ImGuiSharp.ImVectorImGuiWindowPtr.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WindowsFocusOrder));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WindowsFocusOrder = *(global::ImGuiSharp.ImVectorImGuiWindowPtr.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVectorImGuiWindowPtr WindowsTempSortBuffer
        {
            get
            {
                return global::ImGuiSharp.ImVectorImGuiWindowPtr.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WindowsTempSortBuffer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WindowsTempSortBuffer = *(global::ImGuiSharp.ImVectorImGuiWindowPtr.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVectorImGuiWindowStackData CurrentWindowStack
        {
            get
            {
                return global::ImGuiSharp.ImVectorImGuiWindowStackData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->CurrentWindowStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->CurrentWindowStack = *(global::ImGuiSharp.ImVectorImGuiWindowStackData.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiStorage WindowsById
        {
            get
            {
                return global::ImGuiSharp.ImGuiStorage.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WindowsById));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WindowsById = *(global::ImGuiSharp.ImGuiStorage.__Internal*) value.__Instance;
            }
        }

        public int WindowsActiveCount
        {
            get
            {
                return ((__Internal*)__Instance)->WindowsActiveCount;
            }

            set
            {
                ((__Internal*)__Instance)->WindowsActiveCount = value;
            }
        }

        public global::ImGuiSharp.ImVec2 WindowsHoverPadding
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WindowsHoverPadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WindowsHoverPadding = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiWindow CurrentWindow
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->CurrentWindow, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->CurrentWindow = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiWindow HoveredWindow
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->HoveredWindow, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->HoveredWindow = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiWindow HoveredWindowUnderMovingWindow
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->HoveredWindowUnderMovingWindow, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->HoveredWindowUnderMovingWindow = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiWindow MovingWindow
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->MovingWindow, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->MovingWindow = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiWindow WheelingWindow
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->WheelingWindow, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->WheelingWindow = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 WheelingWindowRefMousePos
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WheelingWindowRefMousePos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WheelingWindowRefMousePos = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float WheelingWindowTimer
        {
            get
            {
                return ((__Internal*)__Instance)->WheelingWindowTimer;
            }

            set
            {
                ((__Internal*)__Instance)->WheelingWindowTimer = value;
            }
        }

        public uint DebugHookIdInfo
        {
            get
            {
                return ((__Internal*)__Instance)->DebugHookIdInfo;
            }

            set
            {
                ((__Internal*)__Instance)->DebugHookIdInfo = value;
            }
        }

        public uint HoveredId
        {
            get
            {
                return ((__Internal*)__Instance)->HoveredId;
            }

            set
            {
                ((__Internal*)__Instance)->HoveredId = value;
            }
        }

        public uint HoveredIdPreviousFrame
        {
            get
            {
                return ((__Internal*)__Instance)->HoveredIdPreviousFrame;
            }

            set
            {
                ((__Internal*)__Instance)->HoveredIdPreviousFrame = value;
            }
        }

        public bool HoveredIdAllowOverlap
        {
            get
            {
                return ((__Internal*)__Instance)->HoveredIdAllowOverlap != 0;
            }

            set
            {
                ((__Internal*)__Instance)->HoveredIdAllowOverlap = (byte) (value ? 1 : 0);
            }
        }

        public bool HoveredIdUsingMouseWheel
        {
            get
            {
                return ((__Internal*)__Instance)->HoveredIdUsingMouseWheel != 0;
            }

            set
            {
                ((__Internal*)__Instance)->HoveredIdUsingMouseWheel = (byte) (value ? 1 : 0);
            }
        }

        public bool HoveredIdPreviousFrameUsingMouseWheel
        {
            get
            {
                return ((__Internal*)__Instance)->HoveredIdPreviousFrameUsingMouseWheel != 0;
            }

            set
            {
                ((__Internal*)__Instance)->HoveredIdPreviousFrameUsingMouseWheel = (byte) (value ? 1 : 0);
            }
        }

        public bool HoveredIdDisabled
        {
            get
            {
                return ((__Internal*)__Instance)->HoveredIdDisabled != 0;
            }

            set
            {
                ((__Internal*)__Instance)->HoveredIdDisabled = (byte) (value ? 1 : 0);
            }
        }

        public float HoveredIdTimer
        {
            get
            {
                return ((__Internal*)__Instance)->HoveredIdTimer;
            }

            set
            {
                ((__Internal*)__Instance)->HoveredIdTimer = value;
            }
        }

        public float HoveredIdNotActiveTimer
        {
            get
            {
                return ((__Internal*)__Instance)->HoveredIdNotActiveTimer;
            }

            set
            {
                ((__Internal*)__Instance)->HoveredIdNotActiveTimer = value;
            }
        }

        public uint ActiveId
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveId;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveId = value;
            }
        }

        public uint ActiveIdIsAlive
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveIdIsAlive;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdIsAlive = value;
            }
        }

        public float ActiveIdTimer
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveIdTimer;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdTimer = value;
            }
        }

        public bool ActiveIdIsJustActivated
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveIdIsJustActivated != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdIsJustActivated = (byte) (value ? 1 : 0);
            }
        }

        public bool ActiveIdAllowOverlap
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveIdAllowOverlap != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdAllowOverlap = (byte) (value ? 1 : 0);
            }
        }

        public bool ActiveIdNoClearOnFocusLoss
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveIdNoClearOnFocusLoss != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdNoClearOnFocusLoss = (byte) (value ? 1 : 0);
            }
        }

        public bool ActiveIdHasBeenPressedBefore
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveIdHasBeenPressedBefore != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdHasBeenPressedBefore = (byte) (value ? 1 : 0);
            }
        }

        public bool ActiveIdHasBeenEditedBefore
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveIdHasBeenEditedBefore != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdHasBeenEditedBefore = (byte) (value ? 1 : 0);
            }
        }

        public bool ActiveIdHasBeenEditedThisFrame
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveIdHasBeenEditedThisFrame != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdHasBeenEditedThisFrame = (byte) (value ? 1 : 0);
            }
        }

        public bool ActiveIdUsingMouseWheel
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveIdUsingMouseWheel != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdUsingMouseWheel = (byte) (value ? 1 : 0);
            }
        }

        public uint ActiveIdUsingNavDirMask
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveIdUsingNavDirMask;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdUsingNavDirMask = value;
            }
        }

        public uint ActiveIdUsingNavInputMask
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveIdUsingNavInputMask;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdUsingNavInputMask = value;
            }
        }

        public global::ImGuiSharp.ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN ActiveIdUsingKeyInputMask
        {
            get
            {
                return global::ImGuiSharp.ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ActiveIdUsingKeyInputMask));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ActiveIdUsingKeyInputMask = *(global::ImGuiSharp.ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 ActiveIdClickOffset
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ActiveIdClickOffset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ActiveIdClickOffset = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiWindow ActiveIdWindow
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->ActiveIdWindow, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdWindow = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiInputSource ActiveIdSource
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveIdSource;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdSource = value;
            }
        }

        public int ActiveIdMouseButton
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveIdMouseButton;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdMouseButton = value;
            }
        }

        public uint ActiveIdPreviousFrame
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveIdPreviousFrame;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdPreviousFrame = value;
            }
        }

        public bool ActiveIdPreviousFrameIsAlive
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveIdPreviousFrameIsAlive != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdPreviousFrameIsAlive = (byte) (value ? 1 : 0);
            }
        }

        public bool ActiveIdPreviousFrameHasBeenEditedBefore
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveIdPreviousFrameHasBeenEditedBefore != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdPreviousFrameHasBeenEditedBefore = (byte) (value ? 1 : 0);
            }
        }

        public global::ImGuiSharp.ImGuiWindow ActiveIdPreviousFrameWindow
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->ActiveIdPreviousFrameWindow, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdPreviousFrameWindow = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public uint LastActiveId
        {
            get
            {
                return ((__Internal*)__Instance)->LastActiveId;
            }

            set
            {
                ((__Internal*)__Instance)->LastActiveId = value;
            }
        }

        public float LastActiveIdTimer
        {
            get
            {
                return ((__Internal*)__Instance)->LastActiveIdTimer;
            }

            set
            {
                ((__Internal*)__Instance)->LastActiveIdTimer = value;
            }
        }

        public int CurrentItemFlags
        {
            get
            {
                return ((__Internal*)__Instance)->CurrentItemFlags;
            }

            set
            {
                ((__Internal*)__Instance)->CurrentItemFlags = value;
            }
        }

        public global::ImGuiSharp.ImGuiNextItemData NextItemData
        {
            get
            {
                return global::ImGuiSharp.ImGuiNextItemData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->NextItemData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->NextItemData = *(global::ImGuiSharp.ImGuiNextItemData.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiLastItemData LastItemData
        {
            get
            {
                return global::ImGuiSharp.ImGuiLastItemData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->LastItemData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->LastItemData = *(global::ImGuiSharp.ImGuiLastItemData.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiNextWindowData NextWindowData
        {
            get
            {
                return global::ImGuiSharp.ImGuiNextWindowData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->NextWindowData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->NextWindowData = *(global::ImGuiSharp.ImGuiNextWindowData.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVectorImGuiColorMod ColorStack
        {
            get
            {
                return global::ImGuiSharp.ImVectorImGuiColorMod.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ColorStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ColorStack = *(global::ImGuiSharp.ImVectorImGuiColorMod.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVectorImGuiStyleMod StyleVarStack
        {
            get
            {
                return global::ImGuiSharp.ImVectorImGuiStyleMod.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->StyleVarStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->StyleVarStack = *(global::ImGuiSharp.ImVectorImGuiStyleMod.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVectorImFontPtr FontStack
        {
            get
            {
                return global::ImGuiSharp.ImVectorImFontPtr.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->FontStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->FontStack = *(global::ImGuiSharp.ImVectorImFontPtr.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVectorImGuiID FocusScopeStack
        {
            get
            {
                return global::ImGuiSharp.ImVectorImGuiID.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->FocusScopeStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->FocusScopeStack = *(global::ImGuiSharp.ImVectorImGuiID.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVectorImGuiItemFlags ItemFlagsStack
        {
            get
            {
                return global::ImGuiSharp.ImVectorImGuiItemFlags.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ItemFlagsStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ItemFlagsStack = *(global::ImGuiSharp.ImVectorImGuiItemFlags.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVectorImGuiGroupData GroupStack
        {
            get
            {
                return global::ImGuiSharp.ImVectorImGuiGroupData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->GroupStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->GroupStack = *(global::ImGuiSharp.ImVectorImGuiGroupData.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVectorImGuiPopupData OpenPopupStack
        {
            get
            {
                return global::ImGuiSharp.ImVectorImGuiPopupData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->OpenPopupStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->OpenPopupStack = *(global::ImGuiSharp.ImVectorImGuiPopupData.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVectorImGuiPopupData BeginPopupStack
        {
            get
            {
                return global::ImGuiSharp.ImVectorImGuiPopupData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->BeginPopupStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->BeginPopupStack = *(global::ImGuiSharp.ImVectorImGuiPopupData.__Internal*) value.__Instance;
            }
        }

        public int BeginMenuCount
        {
            get
            {
                return ((__Internal*)__Instance)->BeginMenuCount;
            }

            set
            {
                ((__Internal*)__Instance)->BeginMenuCount = value;
            }
        }

        public global::ImGuiSharp.ImVectorImGuiViewportPPtr Viewports
        {
            get
            {
                return global::ImGuiSharp.ImVectorImGuiViewportPPtr.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Viewports));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Viewports = *(global::ImGuiSharp.ImVectorImGuiViewportPPtr.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiWindow NavWindow
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->NavWindow, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->NavWindow = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public uint NavId
        {
            get
            {
                return ((__Internal*)__Instance)->NavId;
            }

            set
            {
                ((__Internal*)__Instance)->NavId = value;
            }
        }

        public uint NavFocusScopeId
        {
            get
            {
                return ((__Internal*)__Instance)->NavFocusScopeId;
            }

            set
            {
                ((__Internal*)__Instance)->NavFocusScopeId = value;
            }
        }

        public uint NavActivateId
        {
            get
            {
                return ((__Internal*)__Instance)->NavActivateId;
            }

            set
            {
                ((__Internal*)__Instance)->NavActivateId = value;
            }
        }

        public uint NavActivateDownId
        {
            get
            {
                return ((__Internal*)__Instance)->NavActivateDownId;
            }

            set
            {
                ((__Internal*)__Instance)->NavActivateDownId = value;
            }
        }

        public uint NavActivatePressedId
        {
            get
            {
                return ((__Internal*)__Instance)->NavActivatePressedId;
            }

            set
            {
                ((__Internal*)__Instance)->NavActivatePressedId = value;
            }
        }

        public uint NavActivateInputId
        {
            get
            {
                return ((__Internal*)__Instance)->NavActivateInputId;
            }

            set
            {
                ((__Internal*)__Instance)->NavActivateInputId = value;
            }
        }

        public int NavActivateFlags
        {
            get
            {
                return ((__Internal*)__Instance)->NavActivateFlags;
            }

            set
            {
                ((__Internal*)__Instance)->NavActivateFlags = value;
            }
        }

        public uint NavJustMovedToId
        {
            get
            {
                return ((__Internal*)__Instance)->NavJustMovedToId;
            }

            set
            {
                ((__Internal*)__Instance)->NavJustMovedToId = value;
            }
        }

        public uint NavJustMovedToFocusScopeId
        {
            get
            {
                return ((__Internal*)__Instance)->NavJustMovedToFocusScopeId;
            }

            set
            {
                ((__Internal*)__Instance)->NavJustMovedToFocusScopeId = value;
            }
        }

        public int NavJustMovedToKeyMods
        {
            get
            {
                return ((__Internal*)__Instance)->NavJustMovedToKeyMods;
            }

            set
            {
                ((__Internal*)__Instance)->NavJustMovedToKeyMods = value;
            }
        }

        public uint NavNextActivateId
        {
            get
            {
                return ((__Internal*)__Instance)->NavNextActivateId;
            }

            set
            {
                ((__Internal*)__Instance)->NavNextActivateId = value;
            }
        }

        public int NavNextActivateFlags
        {
            get
            {
                return ((__Internal*)__Instance)->NavNextActivateFlags;
            }

            set
            {
                ((__Internal*)__Instance)->NavNextActivateFlags = value;
            }
        }

        public global::ImGuiSharp.ImGuiInputSource NavInputSource
        {
            get
            {
                return ((__Internal*)__Instance)->NavInputSource;
            }

            set
            {
                ((__Internal*)__Instance)->NavInputSource = value;
            }
        }

        public global::ImGuiSharp.ImGuiNavLayer NavLayer
        {
            get
            {
                return ((__Internal*)__Instance)->NavLayer;
            }

            set
            {
                ((__Internal*)__Instance)->NavLayer = value;
            }
        }

        public bool NavIdIsAlive
        {
            get
            {
                return ((__Internal*)__Instance)->NavIdIsAlive != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavIdIsAlive = (byte) (value ? 1 : 0);
            }
        }

        public bool NavMousePosDirty
        {
            get
            {
                return ((__Internal*)__Instance)->NavMousePosDirty != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavMousePosDirty = (byte) (value ? 1 : 0);
            }
        }

        public bool NavDisableHighlight
        {
            get
            {
                return ((__Internal*)__Instance)->NavDisableHighlight != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavDisableHighlight = (byte) (value ? 1 : 0);
            }
        }

        public bool NavDisableMouseHover
        {
            get
            {
                return ((__Internal*)__Instance)->NavDisableMouseHover != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavDisableMouseHover = (byte) (value ? 1 : 0);
            }
        }

        public bool NavAnyRequest
        {
            get
            {
                return ((__Internal*)__Instance)->NavAnyRequest != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavAnyRequest = (byte) (value ? 1 : 0);
            }
        }

        public bool NavInitRequest
        {
            get
            {
                return ((__Internal*)__Instance)->NavInitRequest != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavInitRequest = (byte) (value ? 1 : 0);
            }
        }

        public bool NavInitRequestFromMove
        {
            get
            {
                return ((__Internal*)__Instance)->NavInitRequestFromMove != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavInitRequestFromMove = (byte) (value ? 1 : 0);
            }
        }

        public uint NavInitResultId
        {
            get
            {
                return ((__Internal*)__Instance)->NavInitResultId;
            }

            set
            {
                ((__Internal*)__Instance)->NavInitResultId = value;
            }
        }

        public global::ImGuiSharp.ImRect NavInitResultRectRel
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->NavInitResultRectRel));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->NavInitResultRectRel = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public bool NavMoveSubmitted
        {
            get
            {
                return ((__Internal*)__Instance)->NavMoveSubmitted != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavMoveSubmitted = (byte) (value ? 1 : 0);
            }
        }

        public bool NavMoveScoringItems
        {
            get
            {
                return ((__Internal*)__Instance)->NavMoveScoringItems != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavMoveScoringItems = (byte) (value ? 1 : 0);
            }
        }

        public bool NavMoveForwardToNextFrame
        {
            get
            {
                return ((__Internal*)__Instance)->NavMoveForwardToNextFrame != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavMoveForwardToNextFrame = (byte) (value ? 1 : 0);
            }
        }

        public int NavMoveFlags
        {
            get
            {
                return ((__Internal*)__Instance)->NavMoveFlags;
            }

            set
            {
                ((__Internal*)__Instance)->NavMoveFlags = value;
            }
        }

        public int NavMoveScrollFlags
        {
            get
            {
                return ((__Internal*)__Instance)->NavMoveScrollFlags;
            }

            set
            {
                ((__Internal*)__Instance)->NavMoveScrollFlags = value;
            }
        }

        public int NavMoveKeyMods
        {
            get
            {
                return ((__Internal*)__Instance)->NavMoveKeyMods;
            }

            set
            {
                ((__Internal*)__Instance)->NavMoveKeyMods = value;
            }
        }

        public int NavMoveDir
        {
            get
            {
                return ((__Internal*)__Instance)->NavMoveDir;
            }

            set
            {
                ((__Internal*)__Instance)->NavMoveDir = value;
            }
        }

        public int NavMoveDirForDebug
        {
            get
            {
                return ((__Internal*)__Instance)->NavMoveDirForDebug;
            }

            set
            {
                ((__Internal*)__Instance)->NavMoveDirForDebug = value;
            }
        }

        public int NavMoveClipDir
        {
            get
            {
                return ((__Internal*)__Instance)->NavMoveClipDir;
            }

            set
            {
                ((__Internal*)__Instance)->NavMoveClipDir = value;
            }
        }

        public global::ImGuiSharp.ImRect NavScoringRect
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->NavScoringRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->NavScoringRect = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImRect NavScoringNoClipRect
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->NavScoringNoClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->NavScoringNoClipRect = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public int NavScoringDebugCount
        {
            get
            {
                return ((__Internal*)__Instance)->NavScoringDebugCount;
            }

            set
            {
                ((__Internal*)__Instance)->NavScoringDebugCount = value;
            }
        }

        public int NavTabbingDir
        {
            get
            {
                return ((__Internal*)__Instance)->NavTabbingDir;
            }

            set
            {
                ((__Internal*)__Instance)->NavTabbingDir = value;
            }
        }

        public int NavTabbingCounter
        {
            get
            {
                return ((__Internal*)__Instance)->NavTabbingCounter;
            }

            set
            {
                ((__Internal*)__Instance)->NavTabbingCounter = value;
            }
        }

        public global::ImGuiSharp.ImGuiNavItemData NavMoveResultLocal
        {
            get
            {
                return global::ImGuiSharp.ImGuiNavItemData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->NavMoveResultLocal));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->NavMoveResultLocal = *(global::ImGuiSharp.ImGuiNavItemData.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiNavItemData NavMoveResultLocalVisible
        {
            get
            {
                return global::ImGuiSharp.ImGuiNavItemData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->NavMoveResultLocalVisible));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->NavMoveResultLocalVisible = *(global::ImGuiSharp.ImGuiNavItemData.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiNavItemData NavMoveResultOther
        {
            get
            {
                return global::ImGuiSharp.ImGuiNavItemData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->NavMoveResultOther));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->NavMoveResultOther = *(global::ImGuiSharp.ImGuiNavItemData.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiNavItemData NavTabbingResultFirst
        {
            get
            {
                return global::ImGuiSharp.ImGuiNavItemData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->NavTabbingResultFirst));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->NavTabbingResultFirst = *(global::ImGuiSharp.ImGuiNavItemData.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiWindow NavWindowingTarget
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->NavWindowingTarget, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->NavWindowingTarget = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiWindow NavWindowingTargetAnim
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->NavWindowingTargetAnim, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->NavWindowingTargetAnim = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiWindow NavWindowingListWindow
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->NavWindowingListWindow, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->NavWindowingListWindow = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public float NavWindowingTimer
        {
            get
            {
                return ((__Internal*)__Instance)->NavWindowingTimer;
            }

            set
            {
                ((__Internal*)__Instance)->NavWindowingTimer = value;
            }
        }

        public float NavWindowingHighlightAlpha
        {
            get
            {
                return ((__Internal*)__Instance)->NavWindowingHighlightAlpha;
            }

            set
            {
                ((__Internal*)__Instance)->NavWindowingHighlightAlpha = value;
            }
        }

        public bool NavWindowingToggleLayer
        {
            get
            {
                return ((__Internal*)__Instance)->NavWindowingToggleLayer != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavWindowingToggleLayer = (byte) (value ? 1 : 0);
            }
        }

        public float DimBgRatio
        {
            get
            {
                return ((__Internal*)__Instance)->DimBgRatio;
            }

            set
            {
                ((__Internal*)__Instance)->DimBgRatio = value;
            }
        }

        public int MouseCursor
        {
            get
            {
                return ((__Internal*)__Instance)->MouseCursor;
            }

            set
            {
                ((__Internal*)__Instance)->MouseCursor = value;
            }
        }

        public bool DragDropActive
        {
            get
            {
                return ((__Internal*)__Instance)->DragDropActive != 0;
            }

            set
            {
                ((__Internal*)__Instance)->DragDropActive = (byte) (value ? 1 : 0);
            }
        }

        public bool DragDropWithinSource
        {
            get
            {
                return ((__Internal*)__Instance)->DragDropWithinSource != 0;
            }

            set
            {
                ((__Internal*)__Instance)->DragDropWithinSource = (byte) (value ? 1 : 0);
            }
        }

        public bool DragDropWithinTarget
        {
            get
            {
                return ((__Internal*)__Instance)->DragDropWithinTarget != 0;
            }

            set
            {
                ((__Internal*)__Instance)->DragDropWithinTarget = (byte) (value ? 1 : 0);
            }
        }

        public int DragDropSourceFlags
        {
            get
            {
                return ((__Internal*)__Instance)->DragDropSourceFlags;
            }

            set
            {
                ((__Internal*)__Instance)->DragDropSourceFlags = value;
            }
        }

        public int DragDropSourceFrameCount
        {
            get
            {
                return ((__Internal*)__Instance)->DragDropSourceFrameCount;
            }

            set
            {
                ((__Internal*)__Instance)->DragDropSourceFrameCount = value;
            }
        }

        public int DragDropMouseButton
        {
            get
            {
                return ((__Internal*)__Instance)->DragDropMouseButton;
            }

            set
            {
                ((__Internal*)__Instance)->DragDropMouseButton = value;
            }
        }

        public global::ImGuiSharp.ImGuiPayload DragDropPayload
        {
            get
            {
                return global::ImGuiSharp.ImGuiPayload.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DragDropPayload));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DragDropPayload = *(global::ImGuiSharp.ImGuiPayload.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImRect DragDropTargetRect
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DragDropTargetRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DragDropTargetRect = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public uint DragDropTargetId
        {
            get
            {
                return ((__Internal*)__Instance)->DragDropTargetId;
            }

            set
            {
                ((__Internal*)__Instance)->DragDropTargetId = value;
            }
        }

        public int DragDropAcceptFlags
        {
            get
            {
                return ((__Internal*)__Instance)->DragDropAcceptFlags;
            }

            set
            {
                ((__Internal*)__Instance)->DragDropAcceptFlags = value;
            }
        }

        public float DragDropAcceptIdCurrRectSurface
        {
            get
            {
                return ((__Internal*)__Instance)->DragDropAcceptIdCurrRectSurface;
            }

            set
            {
                ((__Internal*)__Instance)->DragDropAcceptIdCurrRectSurface = value;
            }
        }

        public uint DragDropAcceptIdCurr
        {
            get
            {
                return ((__Internal*)__Instance)->DragDropAcceptIdCurr;
            }

            set
            {
                ((__Internal*)__Instance)->DragDropAcceptIdCurr = value;
            }
        }

        public uint DragDropAcceptIdPrev
        {
            get
            {
                return ((__Internal*)__Instance)->DragDropAcceptIdPrev;
            }

            set
            {
                ((__Internal*)__Instance)->DragDropAcceptIdPrev = value;
            }
        }

        public int DragDropAcceptFrameCount
        {
            get
            {
                return ((__Internal*)__Instance)->DragDropAcceptFrameCount;
            }

            set
            {
                ((__Internal*)__Instance)->DragDropAcceptFrameCount = value;
            }
        }

        public uint DragDropHoldJustPressedId
        {
            get
            {
                return ((__Internal*)__Instance)->DragDropHoldJustPressedId;
            }

            set
            {
                ((__Internal*)__Instance)->DragDropHoldJustPressedId = value;
            }
        }

        public global::ImGuiSharp.ImVector_unsigned_char DragDropPayloadBufHeap
        {
            get
            {
                return global::ImGuiSharp.ImVector_unsigned_char.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DragDropPayloadBufHeap));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DragDropPayloadBufHeap = *(global::ImGuiSharp.ImVector_unsigned_char.__Internal*) value.__Instance;
            }
        }

        public byte[] DragDropPayloadBufLocal
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->DragDropPayloadBufLocal, 16);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((__Internal*)__Instance)->DragDropPayloadBufLocal[i] = value[i];
                }
            }
        }

        public int ClipperTempDataStacked
        {
            get
            {
                return ((__Internal*)__Instance)->ClipperTempDataStacked;
            }

            set
            {
                ((__Internal*)__Instance)->ClipperTempDataStacked = value;
            }
        }

        public global::ImGuiSharp.ImVectorImGuiListClipperData ClipperTempData
        {
            get
            {
                return global::ImGuiSharp.ImVectorImGuiListClipperData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ClipperTempData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ClipperTempData = *(global::ImGuiSharp.ImVectorImGuiListClipperData.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiTable CurrentTable
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiTable.__GetOrCreateInstance(((__Internal*)__Instance)->CurrentTable, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->CurrentTable = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public int TablesTempDataStacked
        {
            get
            {
                return ((__Internal*)__Instance)->TablesTempDataStacked;
            }

            set
            {
                ((__Internal*)__Instance)->TablesTempDataStacked = value;
            }
        }

        public global::ImGuiSharp.ImVectorImGuiTableTempData TablesTempData
        {
            get
            {
                return global::ImGuiSharp.ImVectorImGuiTableTempData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->TablesTempData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->TablesTempData = *(global::ImGuiSharp.ImVectorImGuiTableTempData.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImPoolImGuiTable Tables
        {
            get
            {
                return global::ImGuiSharp.ImPoolImGuiTable.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Tables));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Tables = *(global::ImGuiSharp.ImPoolImGuiTable.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVector_float TablesLastTimeActive
        {
            get
            {
                return global::ImGuiSharp.ImVector_float.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->TablesLastTimeActive));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->TablesLastTimeActive = *(global::ImGuiSharp.ImVector_float.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVectorImDrawChannel DrawChannelsTempMergeBuffer
        {
            get
            {
                return global::ImGuiSharp.ImVectorImDrawChannel.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DrawChannelsTempMergeBuffer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DrawChannelsTempMergeBuffer = *(global::ImGuiSharp.ImVectorImDrawChannel.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiTabBar CurrentTabBar
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiTabBar.__GetOrCreateInstance(((__Internal*)__Instance)->CurrentTabBar, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->CurrentTabBar = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGuiSharp.ImPoolImGuiTabBar TabBars
        {
            get
            {
                return global::ImGuiSharp.ImPoolImGuiTabBar.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->TabBars));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->TabBars = *(global::ImGuiSharp.ImPoolImGuiTabBar.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVectorImGuiPtrOrIndex CurrentTabBarStack
        {
            get
            {
                return global::ImGuiSharp.ImVectorImGuiPtrOrIndex.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->CurrentTabBarStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->CurrentTabBarStack = *(global::ImGuiSharp.ImVectorImGuiPtrOrIndex.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVectorImGuiShrinkWidthItem ShrinkWidthBuffer
        {
            get
            {
                return global::ImGuiSharp.ImVectorImGuiShrinkWidthItem.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ShrinkWidthBuffer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ShrinkWidthBuffer = *(global::ImGuiSharp.ImVectorImGuiShrinkWidthItem.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 MouseLastValidPos
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->MouseLastValidPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->MouseLastValidPos = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiInputTextState InputTextState
        {
            get
            {
                return global::ImGuiSharp.ImGuiInputTextState.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->InputTextState));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->InputTextState = *(global::ImGuiSharp.ImGuiInputTextState.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImFont InputTextPasswordFont
        {
            get
            {
                return global::ImGuiSharp.ImFont.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->InputTextPasswordFont));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->InputTextPasswordFont = *(global::ImGuiSharp.ImFont.__Internal*) value.__Instance;
            }
        }

        public uint TempInputId
        {
            get
            {
                return ((__Internal*)__Instance)->TempInputId;
            }

            set
            {
                ((__Internal*)__Instance)->TempInputId = value;
            }
        }

        public int ColorEditOptions
        {
            get
            {
                return ((__Internal*)__Instance)->ColorEditOptions;
            }

            set
            {
                ((__Internal*)__Instance)->ColorEditOptions = value;
            }
        }

        public float ColorEditLastHue
        {
            get
            {
                return ((__Internal*)__Instance)->ColorEditLastHue;
            }

            set
            {
                ((__Internal*)__Instance)->ColorEditLastHue = value;
            }
        }

        public float ColorEditLastSat
        {
            get
            {
                return ((__Internal*)__Instance)->ColorEditLastSat;
            }

            set
            {
                ((__Internal*)__Instance)->ColorEditLastSat = value;
            }
        }

        public uint ColorEditLastColor
        {
            get
            {
                return ((__Internal*)__Instance)->ColorEditLastColor;
            }

            set
            {
                ((__Internal*)__Instance)->ColorEditLastColor = value;
            }
        }

        public global::ImGuiSharp.ImVec4 ColorPickerRef
        {
            get
            {
                return global::ImGuiSharp.ImVec4.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ColorPickerRef));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ColorPickerRef = *(global::ImGuiSharp.ImVec4.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiComboPreviewData ComboPreviewData
        {
            get
            {
                return global::ImGuiSharp.ImGuiComboPreviewData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ComboPreviewData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ComboPreviewData = *(global::ImGuiSharp.ImGuiComboPreviewData.__Internal*) value.__Instance;
            }
        }

        public float SliderCurrentAccum
        {
            get
            {
                return ((__Internal*)__Instance)->SliderCurrentAccum;
            }

            set
            {
                ((__Internal*)__Instance)->SliderCurrentAccum = value;
            }
        }

        public bool SliderCurrentAccumDirty
        {
            get
            {
                return ((__Internal*)__Instance)->SliderCurrentAccumDirty != 0;
            }

            set
            {
                ((__Internal*)__Instance)->SliderCurrentAccumDirty = (byte) (value ? 1 : 0);
            }
        }

        public bool DragCurrentAccumDirty
        {
            get
            {
                return ((__Internal*)__Instance)->DragCurrentAccumDirty != 0;
            }

            set
            {
                ((__Internal*)__Instance)->DragCurrentAccumDirty = (byte) (value ? 1 : 0);
            }
        }

        public float DragCurrentAccum
        {
            get
            {
                return ((__Internal*)__Instance)->DragCurrentAccum;
            }

            set
            {
                ((__Internal*)__Instance)->DragCurrentAccum = value;
            }
        }

        public float DragSpeedDefaultRatio
        {
            get
            {
                return ((__Internal*)__Instance)->DragSpeedDefaultRatio;
            }

            set
            {
                ((__Internal*)__Instance)->DragSpeedDefaultRatio = value;
            }
        }

        public float ScrollbarClickDeltaToGrabCenter
        {
            get
            {
                return ((__Internal*)__Instance)->ScrollbarClickDeltaToGrabCenter;
            }

            set
            {
                ((__Internal*)__Instance)->ScrollbarClickDeltaToGrabCenter = value;
            }
        }

        public float DisabledAlphaBackup
        {
            get
            {
                return ((__Internal*)__Instance)->DisabledAlphaBackup;
            }

            set
            {
                ((__Internal*)__Instance)->DisabledAlphaBackup = value;
            }
        }

        public short DisabledStackSize
        {
            get
            {
                return ((__Internal*)__Instance)->DisabledStackSize;
            }

            set
            {
                ((__Internal*)__Instance)->DisabledStackSize = value;
            }
        }

        public short TooltipOverrideCount
        {
            get
            {
                return ((__Internal*)__Instance)->TooltipOverrideCount;
            }

            set
            {
                ((__Internal*)__Instance)->TooltipOverrideCount = value;
            }
        }

        public float TooltipSlowDelay
        {
            get
            {
                return ((__Internal*)__Instance)->TooltipSlowDelay;
            }

            set
            {
                ((__Internal*)__Instance)->TooltipSlowDelay = value;
            }
        }

        public global::ImGuiSharp.ImVector_char ClipboardHandlerData
        {
            get
            {
                return global::ImGuiSharp.ImVector_char.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ClipboardHandlerData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ClipboardHandlerData = *(global::ImGuiSharp.ImVector_char.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVectorImGuiID MenusIdSubmittedThisFrame
        {
            get
            {
                return global::ImGuiSharp.ImVectorImGuiID.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->MenusIdSubmittedThisFrame));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->MenusIdSubmittedThisFrame = *(global::ImGuiSharp.ImVectorImGuiID.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiPlatformImeData PlatformImeData
        {
            get
            {
                return global::ImGuiSharp.ImGuiPlatformImeData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->PlatformImeData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->PlatformImeData = *(global::ImGuiSharp.ImGuiPlatformImeData.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiPlatformImeData PlatformImeDataPrev
        {
            get
            {
                return global::ImGuiSharp.ImGuiPlatformImeData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->PlatformImeDataPrev));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->PlatformImeDataPrev = *(global::ImGuiSharp.ImGuiPlatformImeData.__Internal*) value.__Instance;
            }
        }

        public sbyte PlatformLocaleDecimalPoint
        {
            get
            {
                return ((__Internal*)__Instance)->PlatformLocaleDecimalPoint;
            }

            set
            {
                ((__Internal*)__Instance)->PlatformLocaleDecimalPoint = value;
            }
        }

        public bool SettingsLoaded
        {
            get
            {
                return ((__Internal*)__Instance)->SettingsLoaded != 0;
            }

            set
            {
                ((__Internal*)__Instance)->SettingsLoaded = (byte) (value ? 1 : 0);
            }
        }

        public float SettingsDirtyTimer
        {
            get
            {
                return ((__Internal*)__Instance)->SettingsDirtyTimer;
            }

            set
            {
                ((__Internal*)__Instance)->SettingsDirtyTimer = value;
            }
        }

        public global::ImGuiSharp.ImGuiTextBuffer SettingsIniData
        {
            get
            {
                return global::ImGuiSharp.ImGuiTextBuffer.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->SettingsIniData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->SettingsIniData = *(global::ImGuiSharp.ImGuiTextBuffer.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVectorImGuiSettingsHandler SettingsHandlers
        {
            get
            {
                return global::ImGuiSharp.ImVectorImGuiSettingsHandler.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->SettingsHandlers));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->SettingsHandlers = *(global::ImGuiSharp.ImVectorImGuiSettingsHandler.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImChunkStreamImGuiWindowSettings SettingsWindows
        {
            get
            {
                return global::ImGuiSharp.ImChunkStreamImGuiWindowSettings.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->SettingsWindows));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->SettingsWindows = *(global::ImGuiSharp.ImChunkStreamImGuiWindowSettings.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImChunkStreamImGuiTableSettings SettingsTables
        {
            get
            {
                return global::ImGuiSharp.ImChunkStreamImGuiTableSettings.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->SettingsTables));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->SettingsTables = *(global::ImGuiSharp.ImChunkStreamImGuiTableSettings.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVectorImGuiContextHook Hooks
        {
            get
            {
                return global::ImGuiSharp.ImVectorImGuiContextHook.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Hooks));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Hooks = *(global::ImGuiSharp.ImVectorImGuiContextHook.__Internal*) value.__Instance;
            }
        }

        public uint HookIdNext
        {
            get
            {
                return ((__Internal*)__Instance)->HookIdNext;
            }

            set
            {
                ((__Internal*)__Instance)->HookIdNext = value;
            }
        }

        public bool LogEnabled
        {
            get
            {
                return ((__Internal*)__Instance)->LogEnabled != 0;
            }

            set
            {
                ((__Internal*)__Instance)->LogEnabled = (byte) (value ? 1 : 0);
            }
        }

        public global::ImGuiSharp.ImGuiLogType LogType
        {
            get
            {
                return ((__Internal*)__Instance)->LogType;
            }

            set
            {
                ((__Internal*)__Instance)->LogType = value;
            }
        }

        public global::System.IntPtr LogFile
        {
            get
            {
                return ((__Internal*)__Instance)->LogFile;
            }

            set
            {
                ((__Internal*)__Instance)->LogFile = value;
            }
        }

        public global::ImGuiSharp.ImGuiTextBuffer LogBuffer
        {
            get
            {
                return global::ImGuiSharp.ImGuiTextBuffer.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->LogBuffer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->LogBuffer = *(global::ImGuiSharp.ImGuiTextBuffer.__Internal*) value.__Instance;
            }
        }

        public string LogNextPrefix
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->LogNextPrefix);
            }

            set
            {
                if (__LogNextPrefix_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->LogNextPrefix);
                __LogNextPrefix_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->LogNextPrefix = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->LogNextPrefix = (__IntPtr) __bytePtr0;
            }
        }

        public string LogNextSuffix
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->LogNextSuffix);
            }

            set
            {
                if (__LogNextSuffix_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->LogNextSuffix);
                __LogNextSuffix_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->LogNextSuffix = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->LogNextSuffix = (__IntPtr) __bytePtr0;
            }
        }

        public float LogLinePosY
        {
            get
            {
                return ((__Internal*)__Instance)->LogLinePosY;
            }

            set
            {
                ((__Internal*)__Instance)->LogLinePosY = value;
            }
        }

        public bool LogLineFirstItem
        {
            get
            {
                return ((__Internal*)__Instance)->LogLineFirstItem != 0;
            }

            set
            {
                ((__Internal*)__Instance)->LogLineFirstItem = (byte) (value ? 1 : 0);
            }
        }

        public int LogDepthRef
        {
            get
            {
                return ((__Internal*)__Instance)->LogDepthRef;
            }

            set
            {
                ((__Internal*)__Instance)->LogDepthRef = value;
            }
        }

        public int LogDepthToExpand
        {
            get
            {
                return ((__Internal*)__Instance)->LogDepthToExpand;
            }

            set
            {
                ((__Internal*)__Instance)->LogDepthToExpand = value;
            }
        }

        public int LogDepthToExpandDefault
        {
            get
            {
                return ((__Internal*)__Instance)->LogDepthToExpandDefault;
            }

            set
            {
                ((__Internal*)__Instance)->LogDepthToExpandDefault = value;
            }
        }

        public bool DebugItemPickerActive
        {
            get
            {
                return ((__Internal*)__Instance)->DebugItemPickerActive != 0;
            }

            set
            {
                ((__Internal*)__Instance)->DebugItemPickerActive = (byte) (value ? 1 : 0);
            }
        }

        public uint DebugItemPickerBreakId
        {
            get
            {
                return ((__Internal*)__Instance)->DebugItemPickerBreakId;
            }

            set
            {
                ((__Internal*)__Instance)->DebugItemPickerBreakId = value;
            }
        }

        public global::ImGuiSharp.ImGuiMetricsConfig DebugMetricsConfig
        {
            get
            {
                return global::ImGuiSharp.ImGuiMetricsConfig.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DebugMetricsConfig));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DebugMetricsConfig = *(global::ImGuiSharp.ImGuiMetricsConfig.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiStackTool DebugStackTool
        {
            get
            {
                return global::ImGuiSharp.ImGuiStackTool.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DebugStackTool));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DebugStackTool = *(global::ImGuiSharp.ImGuiStackTool.__Internal*) value.__Instance;
            }
        }

        public float[] FramerateSecPerFrame
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->FramerateSecPerFrame, 120);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 120; i++)
                        ((__Internal*)__Instance)->FramerateSecPerFrame[i] = value[i];
                }
            }
        }

        public int FramerateSecPerFrameIdx
        {
            get
            {
                return ((__Internal*)__Instance)->FramerateSecPerFrameIdx;
            }

            set
            {
                ((__Internal*)__Instance)->FramerateSecPerFrameIdx = value;
            }
        }

        public int FramerateSecPerFrameCount
        {
            get
            {
                return ((__Internal*)__Instance)->FramerateSecPerFrameCount;
            }

            set
            {
                ((__Internal*)__Instance)->FramerateSecPerFrameCount = value;
            }
        }

        public float FramerateSecPerFrameAccum
        {
            get
            {
                return ((__Internal*)__Instance)->FramerateSecPerFrameAccum;
            }

            set
            {
                ((__Internal*)__Instance)->FramerateSecPerFrameAccum = value;
            }
        }

        public int WantCaptureMouseNextFrame
        {
            get
            {
                return ((__Internal*)__Instance)->WantCaptureMouseNextFrame;
            }

            set
            {
                ((__Internal*)__Instance)->WantCaptureMouseNextFrame = value;
            }
        }

        public int WantCaptureKeyboardNextFrame
        {
            get
            {
                return ((__Internal*)__Instance)->WantCaptureKeyboardNextFrame;
            }

            set
            {
                ((__Internal*)__Instance)->WantCaptureKeyboardNextFrame = value;
            }
        }

        public int WantTextInputNextFrame
        {
            get
            {
                return ((__Internal*)__Instance)->WantTextInputNextFrame;
            }

            set
            {
                ((__Internal*)__Instance)->WantTextInputNextFrame = value;
            }
        }

        public sbyte[] TempBuffer
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->TempBuffer, 3073);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3073; i++)
                        ((__Internal*)__Instance)->TempBuffer[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class ImGuiWindowTempData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 232)]
        public partial struct __Internal
        {
            public global::ImGuiSharp.ImVec2.__Internal CursorPos;
            public global::ImGuiSharp.ImVec2.__Internal CursorPosPrevLine;
            public global::ImGuiSharp.ImVec2.__Internal CursorStartPos;
            public global::ImGuiSharp.ImVec2.__Internal CursorMaxPos;
            public global::ImGuiSharp.ImVec2.__Internal IdealMaxPos;
            public global::ImGuiSharp.ImVec2.__Internal CurrLineSize;
            public global::ImGuiSharp.ImVec2.__Internal PrevLineSize;
            public float CurrLineTextBaseOffset;
            public float PrevLineTextBaseOffset;
            public global::ImGuiSharp.ImVec1.__Internal Indent;
            public global::ImGuiSharp.ImVec1.__Internal ColumnsOffset;
            public global::ImGuiSharp.ImVec1.__Internal GroupOffset;
            public global::ImGuiSharp.ImVec2.__Internal CursorStartPosLossyness;
            public global::ImGuiSharp.ImGuiNavLayer NavLayerCurrent;
            public short NavLayersActiveMask;
            public short NavLayersActiveMaskNext;
            public uint NavFocusScopeIdCurrent;
            public byte NavHideHighlightOneFrame;
            public byte NavHasScroll;
            public byte MenuBarAppending;
            public global::ImGuiSharp.ImVec2.__Internal MenuBarOffset;
            public global::ImGuiSharp.ImGuiMenuColumns.__Internal MenuColumns;
            public int TreeDepth;
            public uint TreeJumpToParentOnPopMask;
            public global::ImGuiSharp.ImVectorImGuiWindowPtr.__Internal ChildWindows;
            public __IntPtr StateStorage;
            public __IntPtr CurrentColumns;
            public int CurrentTableIdx;
            public int LayoutType;
            public int ParentLayoutType;
            public float ItemWidth;
            public float TextWrapPos;
            public global::ImGuiSharp.ImVector_float.__Internal ItemWidthStack;
            public global::ImGuiSharp.ImVector_float.__Internal TextWrapPosStack;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiWindowTempData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiWindowTempData> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiWindowTempData>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiWindowTempData managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiWindowTempData managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiWindowTempData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiWindowTempData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiWindowTempData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiWindowTempData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiWindowTempData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiWindowTempData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiWindowTempData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiWindowTempData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiWindowTempData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiWindowTempData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiWindowTempData(global::ImGuiSharp.ImGuiWindowTempData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiWindowTempData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiWindowTempData.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiWindowTempData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGuiSharp.ImVec2 CursorPos
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->CursorPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->CursorPos = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 CursorPosPrevLine
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->CursorPosPrevLine));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->CursorPosPrevLine = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 CursorStartPos
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->CursorStartPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->CursorStartPos = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 CursorMaxPos
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->CursorMaxPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->CursorMaxPos = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 IdealMaxPos
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->IdealMaxPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->IdealMaxPos = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 CurrLineSize
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->CurrLineSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->CurrLineSize = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 PrevLineSize
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->PrevLineSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->PrevLineSize = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float CurrLineTextBaseOffset
        {
            get
            {
                return ((__Internal*)__Instance)->CurrLineTextBaseOffset;
            }

            set
            {
                ((__Internal*)__Instance)->CurrLineTextBaseOffset = value;
            }
        }

        public float PrevLineTextBaseOffset
        {
            get
            {
                return ((__Internal*)__Instance)->PrevLineTextBaseOffset;
            }

            set
            {
                ((__Internal*)__Instance)->PrevLineTextBaseOffset = value;
            }
        }

        public global::ImGuiSharp.ImVec1 Indent
        {
            get
            {
                return global::ImGuiSharp.ImVec1.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Indent));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Indent = *(global::ImGuiSharp.ImVec1.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec1 ColumnsOffset
        {
            get
            {
                return global::ImGuiSharp.ImVec1.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ColumnsOffset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ColumnsOffset = *(global::ImGuiSharp.ImVec1.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec1 GroupOffset
        {
            get
            {
                return global::ImGuiSharp.ImVec1.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->GroupOffset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->GroupOffset = *(global::ImGuiSharp.ImVec1.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 CursorStartPosLossyness
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->CursorStartPosLossyness));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->CursorStartPosLossyness = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiNavLayer NavLayerCurrent
        {
            get
            {
                return ((__Internal*)__Instance)->NavLayerCurrent;
            }

            set
            {
                ((__Internal*)__Instance)->NavLayerCurrent = value;
            }
        }

        public short NavLayersActiveMask
        {
            get
            {
                return ((__Internal*)__Instance)->NavLayersActiveMask;
            }

            set
            {
                ((__Internal*)__Instance)->NavLayersActiveMask = value;
            }
        }

        public short NavLayersActiveMaskNext
        {
            get
            {
                return ((__Internal*)__Instance)->NavLayersActiveMaskNext;
            }

            set
            {
                ((__Internal*)__Instance)->NavLayersActiveMaskNext = value;
            }
        }

        public uint NavFocusScopeIdCurrent
        {
            get
            {
                return ((__Internal*)__Instance)->NavFocusScopeIdCurrent;
            }

            set
            {
                ((__Internal*)__Instance)->NavFocusScopeIdCurrent = value;
            }
        }

        public bool NavHideHighlightOneFrame
        {
            get
            {
                return ((__Internal*)__Instance)->NavHideHighlightOneFrame != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavHideHighlightOneFrame = (byte) (value ? 1 : 0);
            }
        }

        public bool NavHasScroll
        {
            get
            {
                return ((__Internal*)__Instance)->NavHasScroll != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavHasScroll = (byte) (value ? 1 : 0);
            }
        }

        public bool MenuBarAppending
        {
            get
            {
                return ((__Internal*)__Instance)->MenuBarAppending != 0;
            }

            set
            {
                ((__Internal*)__Instance)->MenuBarAppending = (byte) (value ? 1 : 0);
            }
        }

        public global::ImGuiSharp.ImVec2 MenuBarOffset
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->MenuBarOffset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->MenuBarOffset = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiMenuColumns MenuColumns
        {
            get
            {
                return global::ImGuiSharp.ImGuiMenuColumns.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->MenuColumns));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->MenuColumns = *(global::ImGuiSharp.ImGuiMenuColumns.__Internal*) value.__Instance;
            }
        }

        public int TreeDepth
        {
            get
            {
                return ((__Internal*)__Instance)->TreeDepth;
            }

            set
            {
                ((__Internal*)__Instance)->TreeDepth = value;
            }
        }

        public uint TreeJumpToParentOnPopMask
        {
            get
            {
                return ((__Internal*)__Instance)->TreeJumpToParentOnPopMask;
            }

            set
            {
                ((__Internal*)__Instance)->TreeJumpToParentOnPopMask = value;
            }
        }

        public global::ImGuiSharp.ImVectorImGuiWindowPtr ChildWindows
        {
            get
            {
                return global::ImGuiSharp.ImVectorImGuiWindowPtr.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ChildWindows));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ChildWindows = *(global::ImGuiSharp.ImVectorImGuiWindowPtr.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiStorage StateStorage
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiStorage.__GetOrCreateInstance(((__Internal*)__Instance)->StateStorage, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->StateStorage = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiOldColumns CurrentColumns
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiOldColumns.__GetOrCreateInstance(((__Internal*)__Instance)->CurrentColumns, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->CurrentColumns = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public int CurrentTableIdx
        {
            get
            {
                return ((__Internal*)__Instance)->CurrentTableIdx;
            }

            set
            {
                ((__Internal*)__Instance)->CurrentTableIdx = value;
            }
        }

        public int LayoutType
        {
            get
            {
                return ((__Internal*)__Instance)->LayoutType;
            }

            set
            {
                ((__Internal*)__Instance)->LayoutType = value;
            }
        }

        public int ParentLayoutType
        {
            get
            {
                return ((__Internal*)__Instance)->ParentLayoutType;
            }

            set
            {
                ((__Internal*)__Instance)->ParentLayoutType = value;
            }
        }

        public float ItemWidth
        {
            get
            {
                return ((__Internal*)__Instance)->ItemWidth;
            }

            set
            {
                ((__Internal*)__Instance)->ItemWidth = value;
            }
        }

        public float TextWrapPos
        {
            get
            {
                return ((__Internal*)__Instance)->TextWrapPos;
            }

            set
            {
                ((__Internal*)__Instance)->TextWrapPos = value;
            }
        }

        public global::ImGuiSharp.ImVector_float ItemWidthStack
        {
            get
            {
                return global::ImGuiSharp.ImVector_float.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ItemWidthStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ItemWidthStack = *(global::ImGuiSharp.ImVector_float.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVector_float TextWrapPosStack
        {
            get
            {
                return global::ImGuiSharp.ImVector_float.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->TextWrapPosStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->TextWrapPosStack = *(global::ImGuiSharp.ImVector_float.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiOldColumns : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiOldColumns@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiOldColumns> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiOldColumns>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImGuiOldColumns managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImGuiOldColumns managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiOldColumns __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiOldColumns(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiOldColumns __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiOldColumns)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiOldColumns __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiOldColumns(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiOldColumns(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiOldColumns(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiOldColumns()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiOldColumns.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiOldColumns(global::ImGuiSharp.ImVectorImGuiOldColumns _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiOldColumns.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImGuiOldColumns.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImGuiOldColumns.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImGuiOldColumns Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiOldColumns.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiWindow : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 944)]
        public partial struct __Internal
        {
            public __IntPtr Name;
            public uint ID;
            public int Flags;
            public global::ImGuiSharp.ImVec2.__Internal Pos;
            public global::ImGuiSharp.ImVec2.__Internal Size;
            public global::ImGuiSharp.ImVec2.__Internal SizeFull;
            public global::ImGuiSharp.ImVec2.__Internal ContentSize;
            public global::ImGuiSharp.ImVec2.__Internal ContentSizeIdeal;
            public global::ImGuiSharp.ImVec2.__Internal ContentSizeExplicit;
            public global::ImGuiSharp.ImVec2.__Internal WindowPadding;
            public float WindowRounding;
            public float WindowBorderSize;
            public int NameBufLen;
            public uint MoveId;
            public uint ChildId;
            public global::ImGuiSharp.ImVec2.__Internal Scroll;
            public global::ImGuiSharp.ImVec2.__Internal ScrollMax;
            public global::ImGuiSharp.ImVec2.__Internal ScrollTarget;
            public global::ImGuiSharp.ImVec2.__Internal ScrollTargetCenterRatio;
            public global::ImGuiSharp.ImVec2.__Internal ScrollTargetEdgeSnapDist;
            public global::ImGuiSharp.ImVec2.__Internal ScrollbarSizes;
            public byte ScrollbarX;
            public byte ScrollbarY;
            public byte Active;
            public byte WasActive;
            public byte WriteAccessed;
            public byte Collapsed;
            public byte WantCollapseToggle;
            public byte SkipItems;
            public byte Appearing;
            public byte Hidden;
            public byte IsFallbackWindow;
            public byte IsExplicitChild;
            public byte HasCloseButton;
            public sbyte ResizeBorderHeld;
            public short BeginCount;
            public short BeginOrderWithinParent;
            public short BeginOrderWithinContext;
            public short FocusOrder;
            public uint PopupId;
            public sbyte AutoFitFramesX;
            public sbyte AutoFitFramesY;
            public sbyte AutoFitChildAxises;
            public byte AutoFitOnlyGrows;
            public int AutoPosLastDirection;
            public sbyte HiddenFramesCanSkipItems;
            public sbyte HiddenFramesCannotSkipItems;
            public sbyte HiddenFramesForRenderOnly;
            public sbyte DisableInputsFrames;
            public int SetWindowPosAllowFlags;
            public int SetWindowSizeAllowFlags;
            public int SetWindowCollapsedAllowFlags;
            public global::ImGuiSharp.ImVec2.__Internal SetWindowPosVal;
            public global::ImGuiSharp.ImVec2.__Internal SetWindowPosPivot;
            public global::ImGuiSharp.ImVectorImGuiID.__Internal IDStack;
            public global::ImGuiSharp.ImGuiWindowTempData.__Internal DC;
            public global::ImGuiSharp.ImRect.__Internal OuterRectClipped;
            public global::ImGuiSharp.ImRect.__Internal InnerRect;
            public global::ImGuiSharp.ImRect.__Internal InnerClipRect;
            public global::ImGuiSharp.ImRect.__Internal WorkRect;
            public global::ImGuiSharp.ImRect.__Internal ParentWorkRect;
            public global::ImGuiSharp.ImRect.__Internal ClipRect;
            public global::ImGuiSharp.ImRect.__Internal ContentRegionRect;
            public global::ImGuiSharp.ImVec2ih.__Internal HitTestHoleSize;
            public global::ImGuiSharp.ImVec2ih.__Internal HitTestHoleOffset;
            public int LastFrameActive;
            public float LastTimeActive;
            public float ItemWidthDefault;
            public global::ImGuiSharp.ImGuiStorage.__Internal StateStorage;
            public global::ImGuiSharp.ImVectorImGuiOldColumns.__Internal ColumnsStorage;
            public float FontWindowScale;
            public int SettingsOffset;
            public __IntPtr DrawList;
            public global::ImGuiSharp.ImDrawList.__Internal DrawListInst;
            public __IntPtr ParentWindow;
            public __IntPtr ParentWindowInBeginStack;
            public __IntPtr RootWindow;
            public __IntPtr RootWindowPopupTree;
            public __IntPtr RootWindowForTitleBarHighlight;
            public __IntPtr RootWindowForNav;
            public __IntPtr NavLastChildNavWindow;
            public fixed uint NavLastIds[2];
            public fixed byte NavRectRel[32];
            public int MemoryDrawListIdxCapacity;
            public int MemoryDrawListVtxCapacity;
            public byte MemoryCompacted;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiWindow@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiWindow> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiWindow>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiWindow managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiWindow managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiWindow __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiWindow(native.ToPointer(), skipVTables);
        }

        internal static ImGuiWindow __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiWindow)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiWindow __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiWindow(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiWindow(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiWindow(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiWindow()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiWindow.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiWindow(global::ImGuiSharp.ImGuiWindow _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiWindow.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiWindow.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiWindow.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte* Name
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->Name;
            }

            set
            {
                ((__Internal*)__Instance)->Name = (__IntPtr) value;
            }
        }

        public uint ID
        {
            get
            {
                return ((__Internal*)__Instance)->ID;
            }

            set
            {
                ((__Internal*)__Instance)->ID = value;
            }
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public global::ImGuiSharp.ImVec2 Pos
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Pos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Pos = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 Size
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Size));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Size = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 SizeFull
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->SizeFull));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->SizeFull = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 ContentSize
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ContentSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ContentSize = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 ContentSizeIdeal
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ContentSizeIdeal));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ContentSizeIdeal = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 ContentSizeExplicit
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ContentSizeExplicit));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ContentSizeExplicit = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 WindowPadding
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WindowPadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WindowPadding = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float WindowRounding
        {
            get
            {
                return ((__Internal*)__Instance)->WindowRounding;
            }

            set
            {
                ((__Internal*)__Instance)->WindowRounding = value;
            }
        }

        public float WindowBorderSize
        {
            get
            {
                return ((__Internal*)__Instance)->WindowBorderSize;
            }

            set
            {
                ((__Internal*)__Instance)->WindowBorderSize = value;
            }
        }

        public int NameBufLen
        {
            get
            {
                return ((__Internal*)__Instance)->NameBufLen;
            }

            set
            {
                ((__Internal*)__Instance)->NameBufLen = value;
            }
        }

        public uint MoveId
        {
            get
            {
                return ((__Internal*)__Instance)->MoveId;
            }

            set
            {
                ((__Internal*)__Instance)->MoveId = value;
            }
        }

        public uint ChildId
        {
            get
            {
                return ((__Internal*)__Instance)->ChildId;
            }

            set
            {
                ((__Internal*)__Instance)->ChildId = value;
            }
        }

        public global::ImGuiSharp.ImVec2 Scroll
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Scroll));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Scroll = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 ScrollMax
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ScrollMax));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ScrollMax = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 ScrollTarget
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ScrollTarget));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ScrollTarget = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 ScrollTargetCenterRatio
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ScrollTargetCenterRatio));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ScrollTargetCenterRatio = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 ScrollTargetEdgeSnapDist
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ScrollTargetEdgeSnapDist));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ScrollTargetEdgeSnapDist = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 ScrollbarSizes
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ScrollbarSizes));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ScrollbarSizes = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public bool ScrollbarX
        {
            get
            {
                return ((__Internal*)__Instance)->ScrollbarX != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ScrollbarX = (byte) (value ? 1 : 0);
            }
        }

        public bool ScrollbarY
        {
            get
            {
                return ((__Internal*)__Instance)->ScrollbarY != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ScrollbarY = (byte) (value ? 1 : 0);
            }
        }

        public bool Active
        {
            get
            {
                return ((__Internal*)__Instance)->Active != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Active = (byte) (value ? 1 : 0);
            }
        }

        public bool WasActive
        {
            get
            {
                return ((__Internal*)__Instance)->WasActive != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WasActive = (byte) (value ? 1 : 0);
            }
        }

        public bool WriteAccessed
        {
            get
            {
                return ((__Internal*)__Instance)->WriteAccessed != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WriteAccessed = (byte) (value ? 1 : 0);
            }
        }

        public bool Collapsed
        {
            get
            {
                return ((__Internal*)__Instance)->Collapsed != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Collapsed = (byte) (value ? 1 : 0);
            }
        }

        public bool WantCollapseToggle
        {
            get
            {
                return ((__Internal*)__Instance)->WantCollapseToggle != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantCollapseToggle = (byte) (value ? 1 : 0);
            }
        }

        public bool SkipItems
        {
            get
            {
                return ((__Internal*)__Instance)->SkipItems != 0;
            }

            set
            {
                ((__Internal*)__Instance)->SkipItems = (byte) (value ? 1 : 0);
            }
        }

        public bool Appearing
        {
            get
            {
                return ((__Internal*)__Instance)->Appearing != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Appearing = (byte) (value ? 1 : 0);
            }
        }

        public bool Hidden
        {
            get
            {
                return ((__Internal*)__Instance)->Hidden != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Hidden = (byte) (value ? 1 : 0);
            }
        }

        public bool IsFallbackWindow
        {
            get
            {
                return ((__Internal*)__Instance)->IsFallbackWindow != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsFallbackWindow = (byte) (value ? 1 : 0);
            }
        }

        public bool IsExplicitChild
        {
            get
            {
                return ((__Internal*)__Instance)->IsExplicitChild != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsExplicitChild = (byte) (value ? 1 : 0);
            }
        }

        public bool HasCloseButton
        {
            get
            {
                return ((__Internal*)__Instance)->HasCloseButton != 0;
            }

            set
            {
                ((__Internal*)__Instance)->HasCloseButton = (byte) (value ? 1 : 0);
            }
        }

        public sbyte ResizeBorderHeld
        {
            get
            {
                return ((__Internal*)__Instance)->ResizeBorderHeld;
            }

            set
            {
                ((__Internal*)__Instance)->ResizeBorderHeld = value;
            }
        }

        public short BeginCount
        {
            get
            {
                return ((__Internal*)__Instance)->BeginCount;
            }

            set
            {
                ((__Internal*)__Instance)->BeginCount = value;
            }
        }

        public short BeginOrderWithinParent
        {
            get
            {
                return ((__Internal*)__Instance)->BeginOrderWithinParent;
            }

            set
            {
                ((__Internal*)__Instance)->BeginOrderWithinParent = value;
            }
        }

        public short BeginOrderWithinContext
        {
            get
            {
                return ((__Internal*)__Instance)->BeginOrderWithinContext;
            }

            set
            {
                ((__Internal*)__Instance)->BeginOrderWithinContext = value;
            }
        }

        public short FocusOrder
        {
            get
            {
                return ((__Internal*)__Instance)->FocusOrder;
            }

            set
            {
                ((__Internal*)__Instance)->FocusOrder = value;
            }
        }

        public uint PopupId
        {
            get
            {
                return ((__Internal*)__Instance)->PopupId;
            }

            set
            {
                ((__Internal*)__Instance)->PopupId = value;
            }
        }

        public sbyte AutoFitFramesX
        {
            get
            {
                return ((__Internal*)__Instance)->AutoFitFramesX;
            }

            set
            {
                ((__Internal*)__Instance)->AutoFitFramesX = value;
            }
        }

        public sbyte AutoFitFramesY
        {
            get
            {
                return ((__Internal*)__Instance)->AutoFitFramesY;
            }

            set
            {
                ((__Internal*)__Instance)->AutoFitFramesY = value;
            }
        }

        public sbyte AutoFitChildAxises
        {
            get
            {
                return ((__Internal*)__Instance)->AutoFitChildAxises;
            }

            set
            {
                ((__Internal*)__Instance)->AutoFitChildAxises = value;
            }
        }

        public bool AutoFitOnlyGrows
        {
            get
            {
                return ((__Internal*)__Instance)->AutoFitOnlyGrows != 0;
            }

            set
            {
                ((__Internal*)__Instance)->AutoFitOnlyGrows = (byte) (value ? 1 : 0);
            }
        }

        public int AutoPosLastDirection
        {
            get
            {
                return ((__Internal*)__Instance)->AutoPosLastDirection;
            }

            set
            {
                ((__Internal*)__Instance)->AutoPosLastDirection = value;
            }
        }

        public sbyte HiddenFramesCanSkipItems
        {
            get
            {
                return ((__Internal*)__Instance)->HiddenFramesCanSkipItems;
            }

            set
            {
                ((__Internal*)__Instance)->HiddenFramesCanSkipItems = value;
            }
        }

        public sbyte HiddenFramesCannotSkipItems
        {
            get
            {
                return ((__Internal*)__Instance)->HiddenFramesCannotSkipItems;
            }

            set
            {
                ((__Internal*)__Instance)->HiddenFramesCannotSkipItems = value;
            }
        }

        public sbyte HiddenFramesForRenderOnly
        {
            get
            {
                return ((__Internal*)__Instance)->HiddenFramesForRenderOnly;
            }

            set
            {
                ((__Internal*)__Instance)->HiddenFramesForRenderOnly = value;
            }
        }

        public sbyte DisableInputsFrames
        {
            get
            {
                return ((__Internal*)__Instance)->DisableInputsFrames;
            }

            set
            {
                ((__Internal*)__Instance)->DisableInputsFrames = value;
            }
        }

        public int SetWindowPosAllowFlags
        {
            get
            {
                return ((__Internal*)__Instance)->SetWindowPosAllowFlags;
            }

            set
            {
                ((__Internal*)__Instance)->SetWindowPosAllowFlags = value;
            }
        }

        public int SetWindowSizeAllowFlags
        {
            get
            {
                return ((__Internal*)__Instance)->SetWindowSizeAllowFlags;
            }

            set
            {
                ((__Internal*)__Instance)->SetWindowSizeAllowFlags = value;
            }
        }

        public int SetWindowCollapsedAllowFlags
        {
            get
            {
                return ((__Internal*)__Instance)->SetWindowCollapsedAllowFlags;
            }

            set
            {
                ((__Internal*)__Instance)->SetWindowCollapsedAllowFlags = value;
            }
        }

        public global::ImGuiSharp.ImVec2 SetWindowPosVal
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->SetWindowPosVal));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->SetWindowPosVal = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 SetWindowPosPivot
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->SetWindowPosPivot));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->SetWindowPosPivot = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVectorImGuiID IDStack
        {
            get
            {
                return global::ImGuiSharp.ImVectorImGuiID.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->IDStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->IDStack = *(global::ImGuiSharp.ImVectorImGuiID.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiWindowTempData DC
        {
            get
            {
                return global::ImGuiSharp.ImGuiWindowTempData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DC));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DC = *(global::ImGuiSharp.ImGuiWindowTempData.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImRect OuterRectClipped
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->OuterRectClipped));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->OuterRectClipped = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImRect InnerRect
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->InnerRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->InnerRect = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImRect InnerClipRect
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->InnerClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->InnerClipRect = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImRect WorkRect
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WorkRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WorkRect = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImRect ParentWorkRect
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ParentWorkRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ParentWorkRect = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImRect ClipRect
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ClipRect = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImRect ContentRegionRect
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ContentRegionRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ContentRegionRect = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2ih HitTestHoleSize
        {
            get
            {
                return global::ImGuiSharp.ImVec2ih.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->HitTestHoleSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->HitTestHoleSize = *(global::ImGuiSharp.ImVec2ih.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2ih HitTestHoleOffset
        {
            get
            {
                return global::ImGuiSharp.ImVec2ih.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->HitTestHoleOffset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->HitTestHoleOffset = *(global::ImGuiSharp.ImVec2ih.__Internal*) value.__Instance;
            }
        }

        public int LastFrameActive
        {
            get
            {
                return ((__Internal*)__Instance)->LastFrameActive;
            }

            set
            {
                ((__Internal*)__Instance)->LastFrameActive = value;
            }
        }

        public float LastTimeActive
        {
            get
            {
                return ((__Internal*)__Instance)->LastTimeActive;
            }

            set
            {
                ((__Internal*)__Instance)->LastTimeActive = value;
            }
        }

        public float ItemWidthDefault
        {
            get
            {
                return ((__Internal*)__Instance)->ItemWidthDefault;
            }

            set
            {
                ((__Internal*)__Instance)->ItemWidthDefault = value;
            }
        }

        public global::ImGuiSharp.ImGuiStorage StateStorage
        {
            get
            {
                return global::ImGuiSharp.ImGuiStorage.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->StateStorage));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->StateStorage = *(global::ImGuiSharp.ImGuiStorage.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVectorImGuiOldColumns ColumnsStorage
        {
            get
            {
                return global::ImGuiSharp.ImVectorImGuiOldColumns.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ColumnsStorage));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ColumnsStorage = *(global::ImGuiSharp.ImVectorImGuiOldColumns.__Internal*) value.__Instance;
            }
        }

        public float FontWindowScale
        {
            get
            {
                return ((__Internal*)__Instance)->FontWindowScale;
            }

            set
            {
                ((__Internal*)__Instance)->FontWindowScale = value;
            }
        }

        public int SettingsOffset
        {
            get
            {
                return ((__Internal*)__Instance)->SettingsOffset;
            }

            set
            {
                ((__Internal*)__Instance)->SettingsOffset = value;
            }
        }

        public global::ImGuiSharp.ImDrawList DrawList
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImDrawList.__GetOrCreateInstance(((__Internal*)__Instance)->DrawList, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->DrawList = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGuiSharp.ImDrawList DrawListInst
        {
            get
            {
                return global::ImGuiSharp.ImDrawList.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DrawListInst));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DrawListInst = *(global::ImGuiSharp.ImDrawList.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiWindow ParentWindow
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->ParentWindow, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->ParentWindow = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiWindow ParentWindowInBeginStack
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->ParentWindowInBeginStack, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->ParentWindowInBeginStack = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiWindow RootWindow
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->RootWindow, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->RootWindow = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiWindow RootWindowPopupTree
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->RootWindowPopupTree, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->RootWindowPopupTree = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiWindow RootWindowForTitleBarHighlight
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->RootWindowForTitleBarHighlight, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->RootWindowForTitleBarHighlight = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiWindow RootWindowForNav
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->RootWindowForNav, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->RootWindowForNav = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiWindow NavLastChildNavWindow
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->NavLastChildNavWindow, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->NavLastChildNavWindow = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public uint[] NavLastIds
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->NavLastIds, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->NavLastIds[i] = value[i];
                }
            }
        }

        public global::ImGuiSharp.ImRect[] NavRectRel
        {
            get
            {
                global::ImGuiSharp.ImRect[] __value = null;
                if (((__Internal*)__Instance)->NavRectRel != null)
                {
                    __value = new global::ImGuiSharp.ImRect[2];
                    for (int i = 0; i < 2; i++)
                        __value[i] = global::ImGuiSharp.ImRect.__GetOrCreateInstance((IntPtr)((global::ImGuiSharp.ImRect.__Internal*)&(((__Internal*)__Instance)->NavRectRel[i * sizeof(global::ImGuiSharp.ImRect.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 2)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 2; i++)
                        *(global::ImGuiSharp.ImRect.__Internal*) &((__Internal*)__Instance)->NavRectRel[i * sizeof(global::ImGuiSharp.ImRect.__Internal)] = *(global::ImGuiSharp.ImRect.__Internal*)value[i].__Instance;
                }
            }
        }

        public int MemoryDrawListIdxCapacity
        {
            get
            {
                return ((__Internal*)__Instance)->MemoryDrawListIdxCapacity;
            }

            set
            {
                ((__Internal*)__Instance)->MemoryDrawListIdxCapacity = value;
            }
        }

        public int MemoryDrawListVtxCapacity
        {
            get
            {
                return ((__Internal*)__Instance)->MemoryDrawListVtxCapacity;
            }

            set
            {
                ((__Internal*)__Instance)->MemoryDrawListVtxCapacity = value;
            }
        }

        public bool MemoryCompacted
        {
            get
            {
                return ((__Internal*)__Instance)->MemoryCompacted != 0;
            }

            set
            {
                ((__Internal*)__Instance)->MemoryCompacted = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImGuiTabItem : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            public uint ID;
            public int Flags;
            public int LastFrameVisible;
            public int LastFrameSelected;
            public float Offset;
            public float Width;
            public float ContentWidth;
            public int NameOffset;
            public short BeginOrder;
            public short IndexDuringLayout;
            public byte WantClose;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiTabItem@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiTabItem> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiTabItem>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiTabItem managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiTabItem managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiTabItem __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTabItem(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTabItem __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiTabItem)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiTabItem __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTabItem(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTabItem(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTabItem(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTabItem()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiTabItem.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTabItem(global::ImGuiSharp.ImGuiTabItem _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiTabItem.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiTabItem.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiTabItem.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ID
        {
            get
            {
                return ((__Internal*)__Instance)->ID;
            }

            set
            {
                ((__Internal*)__Instance)->ID = value;
            }
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public int LastFrameVisible
        {
            get
            {
                return ((__Internal*)__Instance)->LastFrameVisible;
            }

            set
            {
                ((__Internal*)__Instance)->LastFrameVisible = value;
            }
        }

        public int LastFrameSelected
        {
            get
            {
                return ((__Internal*)__Instance)->LastFrameSelected;
            }

            set
            {
                ((__Internal*)__Instance)->LastFrameSelected = value;
            }
        }

        public float Offset
        {
            get
            {
                return ((__Internal*)__Instance)->Offset;
            }

            set
            {
                ((__Internal*)__Instance)->Offset = value;
            }
        }

        public float Width
        {
            get
            {
                return ((__Internal*)__Instance)->Width;
            }

            set
            {
                ((__Internal*)__Instance)->Width = value;
            }
        }

        public float ContentWidth
        {
            get
            {
                return ((__Internal*)__Instance)->ContentWidth;
            }

            set
            {
                ((__Internal*)__Instance)->ContentWidth = value;
            }
        }

        public int NameOffset
        {
            get
            {
                return ((__Internal*)__Instance)->NameOffset;
            }

            set
            {
                ((__Internal*)__Instance)->NameOffset = value;
            }
        }

        public short BeginOrder
        {
            get
            {
                return ((__Internal*)__Instance)->BeginOrder;
            }

            set
            {
                ((__Internal*)__Instance)->BeginOrder = value;
            }
        }

        public short IndexDuringLayout
        {
            get
            {
                return ((__Internal*)__Instance)->IndexDuringLayout;
            }

            set
            {
                ((__Internal*)__Instance)->IndexDuringLayout = value;
            }
        }

        public bool WantClose
        {
            get
            {
                return ((__Internal*)__Instance)->WantClose != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantClose = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImVectorImGuiTabItem : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiTabItem@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiTabItem> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiTabItem>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImGuiTabItem managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImGuiTabItem managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiTabItem __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiTabItem(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiTabItem __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiTabItem)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiTabItem __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiTabItem(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiTabItem(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiTabItem(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiTabItem()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiTabItem.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiTabItem(global::ImGuiSharp.ImVectorImGuiTabItem _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiTabItem.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImGuiTabItem.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImGuiTabItem.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImGuiTabItem Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiTabItem.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiTabBar : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 152)]
        public partial struct __Internal
        {
            public global::ImGuiSharp.ImVectorImGuiTabItem.__Internal Tabs;
            public int Flags;
            public uint ID;
            public uint SelectedTabId;
            public uint NextSelectedTabId;
            public uint VisibleTabId;
            public int CurrFrameVisible;
            public int PrevFrameVisible;
            public global::ImGuiSharp.ImRect.__Internal BarRect;
            public float CurrTabsContentsHeight;
            public float PrevTabsContentsHeight;
            public float WidthAllTabs;
            public float WidthAllTabsIdeal;
            public float ScrollingAnim;
            public float ScrollingTarget;
            public float ScrollingTargetDistToVisibility;
            public float ScrollingSpeed;
            public float ScrollingRectMinX;
            public float ScrollingRectMaxX;
            public uint ReorderRequestTabId;
            public short ReorderRequestOffset;
            public sbyte BeginCount;
            public byte WantLayout;
            public byte VisibleTabWasSubmitted;
            public byte TabsAddedNew;
            public short TabsActiveCount;
            public short LastTabItemIdx;
            public float ItemSpacingY;
            public global::ImGuiSharp.ImVec2.__Internal FramePadding;
            public global::ImGuiSharp.ImVec2.__Internal BackupCursorPos;
            public global::ImGuiSharp.ImGuiTextBuffer.__Internal TabsNames;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiTabBar@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiTabBar> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiTabBar>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiTabBar managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiTabBar managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiTabBar __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTabBar(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTabBar __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiTabBar)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiTabBar __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTabBar(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTabBar(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTabBar(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTabBar()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiTabBar.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTabBar(global::ImGuiSharp.ImGuiTabBar _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiTabBar.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiTabBar.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiTabBar.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGuiSharp.ImVectorImGuiTabItem Tabs
        {
            get
            {
                return global::ImGuiSharp.ImVectorImGuiTabItem.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Tabs));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Tabs = *(global::ImGuiSharp.ImVectorImGuiTabItem.__Internal*) value.__Instance;
            }
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public uint ID
        {
            get
            {
                return ((__Internal*)__Instance)->ID;
            }

            set
            {
                ((__Internal*)__Instance)->ID = value;
            }
        }

        public uint SelectedTabId
        {
            get
            {
                return ((__Internal*)__Instance)->SelectedTabId;
            }

            set
            {
                ((__Internal*)__Instance)->SelectedTabId = value;
            }
        }

        public uint NextSelectedTabId
        {
            get
            {
                return ((__Internal*)__Instance)->NextSelectedTabId;
            }

            set
            {
                ((__Internal*)__Instance)->NextSelectedTabId = value;
            }
        }

        public uint VisibleTabId
        {
            get
            {
                return ((__Internal*)__Instance)->VisibleTabId;
            }

            set
            {
                ((__Internal*)__Instance)->VisibleTabId = value;
            }
        }

        public int CurrFrameVisible
        {
            get
            {
                return ((__Internal*)__Instance)->CurrFrameVisible;
            }

            set
            {
                ((__Internal*)__Instance)->CurrFrameVisible = value;
            }
        }

        public int PrevFrameVisible
        {
            get
            {
                return ((__Internal*)__Instance)->PrevFrameVisible;
            }

            set
            {
                ((__Internal*)__Instance)->PrevFrameVisible = value;
            }
        }

        public global::ImGuiSharp.ImRect BarRect
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->BarRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->BarRect = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public float CurrTabsContentsHeight
        {
            get
            {
                return ((__Internal*)__Instance)->CurrTabsContentsHeight;
            }

            set
            {
                ((__Internal*)__Instance)->CurrTabsContentsHeight = value;
            }
        }

        public float PrevTabsContentsHeight
        {
            get
            {
                return ((__Internal*)__Instance)->PrevTabsContentsHeight;
            }

            set
            {
                ((__Internal*)__Instance)->PrevTabsContentsHeight = value;
            }
        }

        public float WidthAllTabs
        {
            get
            {
                return ((__Internal*)__Instance)->WidthAllTabs;
            }

            set
            {
                ((__Internal*)__Instance)->WidthAllTabs = value;
            }
        }

        public float WidthAllTabsIdeal
        {
            get
            {
                return ((__Internal*)__Instance)->WidthAllTabsIdeal;
            }

            set
            {
                ((__Internal*)__Instance)->WidthAllTabsIdeal = value;
            }
        }

        public float ScrollingAnim
        {
            get
            {
                return ((__Internal*)__Instance)->ScrollingAnim;
            }

            set
            {
                ((__Internal*)__Instance)->ScrollingAnim = value;
            }
        }

        public float ScrollingTarget
        {
            get
            {
                return ((__Internal*)__Instance)->ScrollingTarget;
            }

            set
            {
                ((__Internal*)__Instance)->ScrollingTarget = value;
            }
        }

        public float ScrollingTargetDistToVisibility
        {
            get
            {
                return ((__Internal*)__Instance)->ScrollingTargetDistToVisibility;
            }

            set
            {
                ((__Internal*)__Instance)->ScrollingTargetDistToVisibility = value;
            }
        }

        public float ScrollingSpeed
        {
            get
            {
                return ((__Internal*)__Instance)->ScrollingSpeed;
            }

            set
            {
                ((__Internal*)__Instance)->ScrollingSpeed = value;
            }
        }

        public float ScrollingRectMinX
        {
            get
            {
                return ((__Internal*)__Instance)->ScrollingRectMinX;
            }

            set
            {
                ((__Internal*)__Instance)->ScrollingRectMinX = value;
            }
        }

        public float ScrollingRectMaxX
        {
            get
            {
                return ((__Internal*)__Instance)->ScrollingRectMaxX;
            }

            set
            {
                ((__Internal*)__Instance)->ScrollingRectMaxX = value;
            }
        }

        public uint ReorderRequestTabId
        {
            get
            {
                return ((__Internal*)__Instance)->ReorderRequestTabId;
            }

            set
            {
                ((__Internal*)__Instance)->ReorderRequestTabId = value;
            }
        }

        public short ReorderRequestOffset
        {
            get
            {
                return ((__Internal*)__Instance)->ReorderRequestOffset;
            }

            set
            {
                ((__Internal*)__Instance)->ReorderRequestOffset = value;
            }
        }

        public sbyte BeginCount
        {
            get
            {
                return ((__Internal*)__Instance)->BeginCount;
            }

            set
            {
                ((__Internal*)__Instance)->BeginCount = value;
            }
        }

        public bool WantLayout
        {
            get
            {
                return ((__Internal*)__Instance)->WantLayout != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantLayout = (byte) (value ? 1 : 0);
            }
        }

        public bool VisibleTabWasSubmitted
        {
            get
            {
                return ((__Internal*)__Instance)->VisibleTabWasSubmitted != 0;
            }

            set
            {
                ((__Internal*)__Instance)->VisibleTabWasSubmitted = (byte) (value ? 1 : 0);
            }
        }

        public bool TabsAddedNew
        {
            get
            {
                return ((__Internal*)__Instance)->TabsAddedNew != 0;
            }

            set
            {
                ((__Internal*)__Instance)->TabsAddedNew = (byte) (value ? 1 : 0);
            }
        }

        public short TabsActiveCount
        {
            get
            {
                return ((__Internal*)__Instance)->TabsActiveCount;
            }

            set
            {
                ((__Internal*)__Instance)->TabsActiveCount = value;
            }
        }

        public short LastTabItemIdx
        {
            get
            {
                return ((__Internal*)__Instance)->LastTabItemIdx;
            }

            set
            {
                ((__Internal*)__Instance)->LastTabItemIdx = value;
            }
        }

        public float ItemSpacingY
        {
            get
            {
                return ((__Internal*)__Instance)->ItemSpacingY;
            }

            set
            {
                ((__Internal*)__Instance)->ItemSpacingY = value;
            }
        }

        public global::ImGuiSharp.ImVec2 FramePadding
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->FramePadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->FramePadding = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 BackupCursorPos
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->BackupCursorPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->BackupCursorPos = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiTextBuffer TabsNames
        {
            get
            {
                return global::ImGuiSharp.ImGuiTextBuffer.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->TabsNames));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->TabsNames = *(global::ImGuiSharp.ImGuiTextBuffer.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiTableColumn : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 104)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public int Flags;

            [FieldOffset(4)]
            public float WidthGiven;

            [FieldOffset(8)]
            public float MinX;

            [FieldOffset(12)]
            public float MaxX;

            [FieldOffset(16)]
            public float WidthRequest;

            [FieldOffset(20)]
            public float WidthAuto;

            [FieldOffset(24)]
            public float StretchWeight;

            [FieldOffset(28)]
            public float InitStretchWeightOrWidth;

            [FieldOffset(32)]
            public global::ImGuiSharp.ImRect.__Internal ClipRect;

            [FieldOffset(48)]
            public uint UserID;

            [FieldOffset(52)]
            public float WorkMinX;

            [FieldOffset(56)]
            public float WorkMaxX;

            [FieldOffset(60)]
            public float ItemWidth;

            [FieldOffset(64)]
            public float ContentMaxXFrozen;

            [FieldOffset(68)]
            public float ContentMaxXUnfrozen;

            [FieldOffset(72)]
            public float ContentMaxXHeadersUsed;

            [FieldOffset(76)]
            public float ContentMaxXHeadersIdeal;

            [FieldOffset(80)]
            public short NameOffset;

            [FieldOffset(82)]
            public sbyte DisplayOrder;

            [FieldOffset(83)]
            public sbyte IndexWithinEnabledSet;

            [FieldOffset(84)]
            public sbyte PrevEnabledColumn;

            [FieldOffset(85)]
            public sbyte NextEnabledColumn;

            [FieldOffset(86)]
            public sbyte SortOrder;

            [FieldOffset(87)]
            public byte DrawChannelCurrent;

            [FieldOffset(88)]
            public byte DrawChannelFrozen;

            [FieldOffset(89)]
            public byte DrawChannelUnfrozen;

            [FieldOffset(90)]
            public byte IsEnabled;

            [FieldOffset(91)]
            public byte IsUserEnabled;

            [FieldOffset(92)]
            public byte IsUserEnabledNextFrame;

            [FieldOffset(93)]
            public byte IsVisibleX;

            [FieldOffset(94)]
            public byte IsVisibleY;

            [FieldOffset(95)]
            public byte IsRequestOutput;

            [FieldOffset(96)]
            public byte IsSkipItems;

            [FieldOffset(97)]
            public byte IsPreserveWidthAuto;

            [FieldOffset(98)]
            public sbyte NavLayerCurrent;

            [FieldOffset(99)]
            public byte AutoFitQueue;

            [FieldOffset(100)]
            public byte CannotSkipItemsQueue;

            [FieldOffset(101)]
            public byte SortDirection;

            [FieldOffset(101)]
            public byte SortDirectionsAvailCount;

            [FieldOffset(101)]
            public byte SortDirectionsAvailMask;

            [FieldOffset(102)]
            public byte SortDirectionsAvailList;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiTableColumn@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiTableColumn> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiTableColumn>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiTableColumn managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiTableColumn managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiTableColumn __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTableColumn(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTableColumn __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiTableColumn)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiTableColumn __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTableColumn(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTableColumn(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTableColumn(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTableColumn()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiTableColumn.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTableColumn(global::ImGuiSharp.ImGuiTableColumn _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiTableColumn.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiTableColumn.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiTableColumn.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public float WidthGiven
        {
            get
            {
                return ((__Internal*)__Instance)->WidthGiven;
            }

            set
            {
                ((__Internal*)__Instance)->WidthGiven = value;
            }
        }

        public float MinX
        {
            get
            {
                return ((__Internal*)__Instance)->MinX;
            }

            set
            {
                ((__Internal*)__Instance)->MinX = value;
            }
        }

        public float MaxX
        {
            get
            {
                return ((__Internal*)__Instance)->MaxX;
            }

            set
            {
                ((__Internal*)__Instance)->MaxX = value;
            }
        }

        public float WidthRequest
        {
            get
            {
                return ((__Internal*)__Instance)->WidthRequest;
            }

            set
            {
                ((__Internal*)__Instance)->WidthRequest = value;
            }
        }

        public float WidthAuto
        {
            get
            {
                return ((__Internal*)__Instance)->WidthAuto;
            }

            set
            {
                ((__Internal*)__Instance)->WidthAuto = value;
            }
        }

        public float StretchWeight
        {
            get
            {
                return ((__Internal*)__Instance)->StretchWeight;
            }

            set
            {
                ((__Internal*)__Instance)->StretchWeight = value;
            }
        }

        public float InitStretchWeightOrWidth
        {
            get
            {
                return ((__Internal*)__Instance)->InitStretchWeightOrWidth;
            }

            set
            {
                ((__Internal*)__Instance)->InitStretchWeightOrWidth = value;
            }
        }

        public global::ImGuiSharp.ImRect ClipRect
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ClipRect = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public uint UserID
        {
            get
            {
                return ((__Internal*)__Instance)->UserID;
            }

            set
            {
                ((__Internal*)__Instance)->UserID = value;
            }
        }

        public float WorkMinX
        {
            get
            {
                return ((__Internal*)__Instance)->WorkMinX;
            }

            set
            {
                ((__Internal*)__Instance)->WorkMinX = value;
            }
        }

        public float WorkMaxX
        {
            get
            {
                return ((__Internal*)__Instance)->WorkMaxX;
            }

            set
            {
                ((__Internal*)__Instance)->WorkMaxX = value;
            }
        }

        public float ItemWidth
        {
            get
            {
                return ((__Internal*)__Instance)->ItemWidth;
            }

            set
            {
                ((__Internal*)__Instance)->ItemWidth = value;
            }
        }

        public float ContentMaxXFrozen
        {
            get
            {
                return ((__Internal*)__Instance)->ContentMaxXFrozen;
            }

            set
            {
                ((__Internal*)__Instance)->ContentMaxXFrozen = value;
            }
        }

        public float ContentMaxXUnfrozen
        {
            get
            {
                return ((__Internal*)__Instance)->ContentMaxXUnfrozen;
            }

            set
            {
                ((__Internal*)__Instance)->ContentMaxXUnfrozen = value;
            }
        }

        public float ContentMaxXHeadersUsed
        {
            get
            {
                return ((__Internal*)__Instance)->ContentMaxXHeadersUsed;
            }

            set
            {
                ((__Internal*)__Instance)->ContentMaxXHeadersUsed = value;
            }
        }

        public float ContentMaxXHeadersIdeal
        {
            get
            {
                return ((__Internal*)__Instance)->ContentMaxXHeadersIdeal;
            }

            set
            {
                ((__Internal*)__Instance)->ContentMaxXHeadersIdeal = value;
            }
        }

        public short NameOffset
        {
            get
            {
                return ((__Internal*)__Instance)->NameOffset;
            }

            set
            {
                ((__Internal*)__Instance)->NameOffset = value;
            }
        }

        public sbyte DisplayOrder
        {
            get
            {
                return ((__Internal*)__Instance)->DisplayOrder;
            }

            set
            {
                ((__Internal*)__Instance)->DisplayOrder = value;
            }
        }

        public sbyte IndexWithinEnabledSet
        {
            get
            {
                return ((__Internal*)__Instance)->IndexWithinEnabledSet;
            }

            set
            {
                ((__Internal*)__Instance)->IndexWithinEnabledSet = value;
            }
        }

        public sbyte PrevEnabledColumn
        {
            get
            {
                return ((__Internal*)__Instance)->PrevEnabledColumn;
            }

            set
            {
                ((__Internal*)__Instance)->PrevEnabledColumn = value;
            }
        }

        public sbyte NextEnabledColumn
        {
            get
            {
                return ((__Internal*)__Instance)->NextEnabledColumn;
            }

            set
            {
                ((__Internal*)__Instance)->NextEnabledColumn = value;
            }
        }

        public sbyte SortOrder
        {
            get
            {
                return ((__Internal*)__Instance)->SortOrder;
            }

            set
            {
                ((__Internal*)__Instance)->SortOrder = value;
            }
        }

        public byte DrawChannelCurrent
        {
            get
            {
                return ((__Internal*)__Instance)->DrawChannelCurrent;
            }

            set
            {
                ((__Internal*)__Instance)->DrawChannelCurrent = value;
            }
        }

        public byte DrawChannelFrozen
        {
            get
            {
                return ((__Internal*)__Instance)->DrawChannelFrozen;
            }

            set
            {
                ((__Internal*)__Instance)->DrawChannelFrozen = value;
            }
        }

        public byte DrawChannelUnfrozen
        {
            get
            {
                return ((__Internal*)__Instance)->DrawChannelUnfrozen;
            }

            set
            {
                ((__Internal*)__Instance)->DrawChannelUnfrozen = value;
            }
        }

        public bool IsEnabled
        {
            get
            {
                return ((__Internal*)__Instance)->IsEnabled != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsEnabled = (byte) (value ? 1 : 0);
            }
        }

        public bool IsUserEnabled
        {
            get
            {
                return ((__Internal*)__Instance)->IsUserEnabled != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsUserEnabled = (byte) (value ? 1 : 0);
            }
        }

        public bool IsUserEnabledNextFrame
        {
            get
            {
                return ((__Internal*)__Instance)->IsUserEnabledNextFrame != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsUserEnabledNextFrame = (byte) (value ? 1 : 0);
            }
        }

        public bool IsVisibleX
        {
            get
            {
                return ((__Internal*)__Instance)->IsVisibleX != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsVisibleX = (byte) (value ? 1 : 0);
            }
        }

        public bool IsVisibleY
        {
            get
            {
                return ((__Internal*)__Instance)->IsVisibleY != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsVisibleY = (byte) (value ? 1 : 0);
            }
        }

        public bool IsRequestOutput
        {
            get
            {
                return ((__Internal*)__Instance)->IsRequestOutput != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsRequestOutput = (byte) (value ? 1 : 0);
            }
        }

        public bool IsSkipItems
        {
            get
            {
                return ((__Internal*)__Instance)->IsSkipItems != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsSkipItems = (byte) (value ? 1 : 0);
            }
        }

        public bool IsPreserveWidthAuto
        {
            get
            {
                return ((__Internal*)__Instance)->IsPreserveWidthAuto != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsPreserveWidthAuto = (byte) (value ? 1 : 0);
            }
        }

        public sbyte NavLayerCurrent
        {
            get
            {
                return ((__Internal*)__Instance)->NavLayerCurrent;
            }

            set
            {
                ((__Internal*)__Instance)->NavLayerCurrent = value;
            }
        }

        public byte AutoFitQueue
        {
            get
            {
                return ((__Internal*)__Instance)->AutoFitQueue;
            }

            set
            {
                ((__Internal*)__Instance)->AutoFitQueue = value;
            }
        }

        public byte CannotSkipItemsQueue
        {
            get
            {
                return ((__Internal*)__Instance)->CannotSkipItemsQueue;
            }

            set
            {
                ((__Internal*)__Instance)->CannotSkipItemsQueue = value;
            }
        }

        public byte SortDirection
        {
            get
            {
                return ((__Internal*)__Instance)->SortDirection;
            }

            set
            {
                ((__Internal*)__Instance)->SortDirection = value;
            }
        }

        public byte SortDirectionsAvailCount
        {
            get
            {
                return ((__Internal*)__Instance)->SortDirectionsAvailCount;
            }

            set
            {
                ((__Internal*)__Instance)->SortDirectionsAvailCount = value;
            }
        }

        public byte SortDirectionsAvailMask
        {
            get
            {
                return ((__Internal*)__Instance)->SortDirectionsAvailMask;
            }

            set
            {
                ((__Internal*)__Instance)->SortDirectionsAvailMask = value;
            }
        }

        public byte SortDirectionsAvailList
        {
            get
            {
                return ((__Internal*)__Instance)->SortDirectionsAvailList;
            }

            set
            {
                ((__Internal*)__Instance)->SortDirectionsAvailList = value;
            }
        }
    }

    public unsafe partial class ImGuiTableCellData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            public uint BgColor;
            public sbyte Column;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiTableCellData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiTableCellData> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiTableCellData>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiTableCellData managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiTableCellData managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiTableCellData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTableCellData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTableCellData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiTableCellData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiTableCellData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTableCellData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTableCellData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTableCellData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTableCellData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiTableCellData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTableCellData(global::ImGuiSharp.ImGuiTableCellData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiTableCellData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiTableCellData.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiTableCellData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint BgColor
        {
            get
            {
                return ((__Internal*)__Instance)->BgColor;
            }

            set
            {
                ((__Internal*)__Instance)->BgColor = value;
            }
        }

        public sbyte Column
        {
            get
            {
                return ((__Internal*)__Instance)->Column;
            }

            set
            {
                ((__Internal*)__Instance)->Column = value;
            }
        }
    }

    public unsafe partial class ImSpanImGuiTableColumn : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public __IntPtr Data;
            public __IntPtr DataEnd;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImSpan_ImGuiTableColumn@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImSpanImGuiTableColumn> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImSpanImGuiTableColumn>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImSpanImGuiTableColumn managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImSpanImGuiTableColumn managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImSpanImGuiTableColumn __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImSpanImGuiTableColumn(native.ToPointer(), skipVTables);
        }

        internal static ImSpanImGuiTableColumn __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImSpanImGuiTableColumn)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImSpanImGuiTableColumn __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImSpanImGuiTableColumn(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImSpanImGuiTableColumn(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImSpanImGuiTableColumn(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImSpanImGuiTableColumn()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImSpanImGuiTableColumn.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImSpanImGuiTableColumn(global::ImGuiSharp.ImSpanImGuiTableColumn _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImSpanImGuiTableColumn.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImSpanImGuiTableColumn.__Internal*) __Instance) = *((global::ImGuiSharp.ImSpanImGuiTableColumn.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGuiSharp.ImGuiTableColumn Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiTableColumn.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiTableColumn DataEnd
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiTableColumn.__GetOrCreateInstance(((__Internal*)__Instance)->DataEnd, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->DataEnd = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImSpanImGuiTableColumnIdx : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public __IntPtr Data;
            public __IntPtr DataEnd;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImSpan_ImGuiTableColumnIdx@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImSpanImGuiTableColumnIdx> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImSpanImGuiTableColumnIdx>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImSpanImGuiTableColumnIdx managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImSpanImGuiTableColumnIdx managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImSpanImGuiTableColumnIdx __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImSpanImGuiTableColumnIdx(native.ToPointer(), skipVTables);
        }

        internal static ImSpanImGuiTableColumnIdx __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImSpanImGuiTableColumnIdx)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImSpanImGuiTableColumnIdx __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImSpanImGuiTableColumnIdx(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImSpanImGuiTableColumnIdx(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImSpanImGuiTableColumnIdx(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImSpanImGuiTableColumnIdx()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImSpanImGuiTableColumnIdx.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImSpanImGuiTableColumnIdx(global::ImGuiSharp.ImSpanImGuiTableColumnIdx _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImSpanImGuiTableColumnIdx.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImSpanImGuiTableColumnIdx.__Internal*) __Instance) = *((global::ImGuiSharp.ImSpanImGuiTableColumnIdx.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte* Data
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->Data;
            }

            set
            {
                ((__Internal*)__Instance)->Data = (__IntPtr) value;
            }
        }

        public sbyte* DataEnd
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->DataEnd;
            }

            set
            {
                ((__Internal*)__Instance)->DataEnd = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImSpanImGuiTableCellData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public __IntPtr Data;
            public __IntPtr DataEnd;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImSpan_ImGuiTableCellData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImSpanImGuiTableCellData> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImSpanImGuiTableCellData>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImSpanImGuiTableCellData managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImSpanImGuiTableCellData managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImSpanImGuiTableCellData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImSpanImGuiTableCellData(native.ToPointer(), skipVTables);
        }

        internal static ImSpanImGuiTableCellData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImSpanImGuiTableCellData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImSpanImGuiTableCellData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImSpanImGuiTableCellData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImSpanImGuiTableCellData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImSpanImGuiTableCellData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImSpanImGuiTableCellData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImSpanImGuiTableCellData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImSpanImGuiTableCellData(global::ImGuiSharp.ImSpanImGuiTableCellData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImSpanImGuiTableCellData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImSpanImGuiTableCellData.__Internal*) __Instance) = *((global::ImGuiSharp.ImSpanImGuiTableCellData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGuiSharp.ImGuiTableCellData Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiTableCellData.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiTableCellData DataEnd
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiTableCellData.__GetOrCreateInstance(((__Internal*)__Instance)->DataEnd, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->DataEnd = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiTableColumnSortSpecs : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiTableColumnSortSpecs@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiTableColumnSortSpecs> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImVectorImGuiTableColumnSortSpecs>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImVectorImGuiTableColumnSortSpecs managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImVectorImGuiTableColumnSortSpecs managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiTableColumnSortSpecs __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiTableColumnSortSpecs(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiTableColumnSortSpecs __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiTableColumnSortSpecs)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiTableColumnSortSpecs __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiTableColumnSortSpecs(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiTableColumnSortSpecs(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiTableColumnSortSpecs(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiTableColumnSortSpecs()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiTableColumnSortSpecs.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiTableColumnSortSpecs(global::ImGuiSharp.ImVectorImGuiTableColumnSortSpecs _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImVectorImGuiTableColumnSortSpecs.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImVectorImGuiTableColumnSortSpecs.__Internal*) __Instance) = *((global::ImGuiSharp.ImVectorImGuiTableColumnSortSpecs.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGuiSharp.ImGuiTableColumnSortSpecs Data
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiTableColumnSortSpecs.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiTable : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 520)]
        public partial struct __Internal
        {
            public uint ID;
            public int Flags;
            public __IntPtr RawData;
            public __IntPtr TempData;
            public global::ImGuiSharp.ImSpanImGuiTableColumn.__Internal Columns;
            public global::ImGuiSharp.ImSpanImGuiTableColumnIdx.__Internal DisplayOrderToIndex;
            public global::ImGuiSharp.ImSpanImGuiTableCellData.__Internal RowCellData;
            public ulong EnabledMaskByDisplayOrder;
            public ulong EnabledMaskByIndex;
            public ulong VisibleMaskByIndex;
            public ulong RequestOutputMaskByIndex;
            public int SettingsLoadedFlags;
            public int SettingsOffset;
            public int LastFrameActive;
            public int ColumnsCount;
            public int CurrentRow;
            public int CurrentColumn;
            public short InstanceCurrent;
            public short InstanceInteracted;
            public float RowPosY1;
            public float RowPosY2;
            public float RowMinHeight;
            public float RowTextBaseline;
            public float RowIndentOffsetX;
            public int RowFlags;
            public int LastRowFlags;
            public int RowBgColorCounter;
            public fixed uint RowBgColor[2];
            public uint BorderColorStrong;
            public uint BorderColorLight;
            public float BorderX1;
            public float BorderX2;
            public float HostIndentX;
            public float MinColumnWidth;
            public float OuterPaddingX;
            public float CellPaddingX;
            public float CellPaddingY;
            public float CellSpacingX1;
            public float CellSpacingX2;
            public float LastOuterHeight;
            public float LastFirstRowHeight;
            public float InnerWidth;
            public float ColumnsGivenWidth;
            public float ColumnsAutoFitWidth;
            public float ResizedColumnNextWidth;
            public float ResizeLockMinContentsX2;
            public float RefScale;
            public global::ImGuiSharp.ImRect.__Internal OuterRect;
            public global::ImGuiSharp.ImRect.__Internal InnerRect;
            public global::ImGuiSharp.ImRect.__Internal WorkRect;
            public global::ImGuiSharp.ImRect.__Internal InnerClipRect;
            public global::ImGuiSharp.ImRect.__Internal BgClipRect;
            public global::ImGuiSharp.ImRect.__Internal Bg0ClipRectForDrawCmd;
            public global::ImGuiSharp.ImRect.__Internal Bg2ClipRectForDrawCmd;
            public global::ImGuiSharp.ImRect.__Internal HostClipRect;
            public global::ImGuiSharp.ImRect.__Internal HostBackupInnerClipRect;
            public __IntPtr OuterWindow;
            public __IntPtr InnerWindow;
            public global::ImGuiSharp.ImGuiTextBuffer.__Internal ColumnsNames;
            public __IntPtr DrawSplitter;
            public global::ImGuiSharp.ImGuiTableColumnSortSpecs.__Internal SortSpecsSingle;
            public global::ImGuiSharp.ImVectorImGuiTableColumnSortSpecs.__Internal SortSpecsMulti;
            public global::ImGuiSharp.ImGuiTableSortSpecs.__Internal SortSpecs;
            public sbyte SortSpecsCount;
            public sbyte ColumnsEnabledCount;
            public sbyte ColumnsEnabledFixedCount;
            public sbyte DeclColumnsCount;
            public sbyte HoveredColumnBody;
            public sbyte HoveredColumnBorder;
            public sbyte AutoFitSingleColumn;
            public sbyte ResizedColumn;
            public sbyte LastResizedColumn;
            public sbyte HeldHeaderColumn;
            public sbyte ReorderColumn;
            public sbyte ReorderColumnDir;
            public sbyte LeftMostEnabledColumn;
            public sbyte RightMostEnabledColumn;
            public sbyte LeftMostStretchedColumn;
            public sbyte RightMostStretchedColumn;
            public sbyte ContextPopupColumn;
            public sbyte FreezeRowsRequest;
            public sbyte FreezeRowsCount;
            public sbyte FreezeColumnsRequest;
            public sbyte FreezeColumnsCount;
            public sbyte RowCellDataCurrent;
            public byte DummyDrawChannel;
            public byte Bg2DrawChannelCurrent;
            public byte Bg2DrawChannelUnfrozen;
            public byte IsLayoutLocked;
            public byte IsInsideRow;
            public byte IsInitializing;
            public byte IsSortSpecsDirty;
            public byte IsUsingHeaders;
            public byte IsContextPopupOpen;
            public byte IsSettingsRequestLoad;
            public byte IsSettingsDirty;
            public byte IsDefaultDisplayOrder;
            public byte IsResetAllRequest;
            public byte IsResetDisplayOrderRequest;
            public byte IsUnfrozenRows;
            public byte IsDefaultSizingPolicy;
            public byte MemoryCompacted;
            public byte HostSkipItems;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiTable@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiTable> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiTable>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiTable managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiTable managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiTable __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTable(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTable __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiTable)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiTable __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTable(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTable(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTable(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTable()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiTable.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTable(global::ImGuiSharp.ImGuiTable _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiTable.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiTable.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiTable.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ID
        {
            get
            {
                return ((__Internal*)__Instance)->ID;
            }

            set
            {
                ((__Internal*)__Instance)->ID = value;
            }
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public __IntPtr RawData
        {
            get
            {
                return ((__Internal*)__Instance)->RawData;
            }

            set
            {
                ((__Internal*)__Instance)->RawData = (__IntPtr) value;
            }
        }

        public global::ImGuiSharp.ImGuiTableTempData TempData
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiTableTempData.__GetOrCreateInstance(((__Internal*)__Instance)->TempData, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->TempData = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGuiSharp.ImSpanImGuiTableColumn Columns
        {
            get
            {
                return global::ImGuiSharp.ImSpanImGuiTableColumn.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Columns));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Columns = *(global::ImGuiSharp.ImSpanImGuiTableColumn.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImSpanImGuiTableColumnIdx DisplayOrderToIndex
        {
            get
            {
                return global::ImGuiSharp.ImSpanImGuiTableColumnIdx.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DisplayOrderToIndex));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DisplayOrderToIndex = *(global::ImGuiSharp.ImSpanImGuiTableColumnIdx.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImSpanImGuiTableCellData RowCellData
        {
            get
            {
                return global::ImGuiSharp.ImSpanImGuiTableCellData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->RowCellData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->RowCellData = *(global::ImGuiSharp.ImSpanImGuiTableCellData.__Internal*) value.__Instance;
            }
        }

        public ulong EnabledMaskByDisplayOrder
        {
            get
            {
                return ((__Internal*)__Instance)->EnabledMaskByDisplayOrder;
            }

            set
            {
                ((__Internal*)__Instance)->EnabledMaskByDisplayOrder = value;
            }
        }

        public ulong EnabledMaskByIndex
        {
            get
            {
                return ((__Internal*)__Instance)->EnabledMaskByIndex;
            }

            set
            {
                ((__Internal*)__Instance)->EnabledMaskByIndex = value;
            }
        }

        public ulong VisibleMaskByIndex
        {
            get
            {
                return ((__Internal*)__Instance)->VisibleMaskByIndex;
            }

            set
            {
                ((__Internal*)__Instance)->VisibleMaskByIndex = value;
            }
        }

        public ulong RequestOutputMaskByIndex
        {
            get
            {
                return ((__Internal*)__Instance)->RequestOutputMaskByIndex;
            }

            set
            {
                ((__Internal*)__Instance)->RequestOutputMaskByIndex = value;
            }
        }

        public int SettingsLoadedFlags
        {
            get
            {
                return ((__Internal*)__Instance)->SettingsLoadedFlags;
            }

            set
            {
                ((__Internal*)__Instance)->SettingsLoadedFlags = value;
            }
        }

        public int SettingsOffset
        {
            get
            {
                return ((__Internal*)__Instance)->SettingsOffset;
            }

            set
            {
                ((__Internal*)__Instance)->SettingsOffset = value;
            }
        }

        public int LastFrameActive
        {
            get
            {
                return ((__Internal*)__Instance)->LastFrameActive;
            }

            set
            {
                ((__Internal*)__Instance)->LastFrameActive = value;
            }
        }

        public int ColumnsCount
        {
            get
            {
                return ((__Internal*)__Instance)->ColumnsCount;
            }

            set
            {
                ((__Internal*)__Instance)->ColumnsCount = value;
            }
        }

        public int CurrentRow
        {
            get
            {
                return ((__Internal*)__Instance)->CurrentRow;
            }

            set
            {
                ((__Internal*)__Instance)->CurrentRow = value;
            }
        }

        public int CurrentColumn
        {
            get
            {
                return ((__Internal*)__Instance)->CurrentColumn;
            }

            set
            {
                ((__Internal*)__Instance)->CurrentColumn = value;
            }
        }

        public short InstanceCurrent
        {
            get
            {
                return ((__Internal*)__Instance)->InstanceCurrent;
            }

            set
            {
                ((__Internal*)__Instance)->InstanceCurrent = value;
            }
        }

        public short InstanceInteracted
        {
            get
            {
                return ((__Internal*)__Instance)->InstanceInteracted;
            }

            set
            {
                ((__Internal*)__Instance)->InstanceInteracted = value;
            }
        }

        public float RowPosY1
        {
            get
            {
                return ((__Internal*)__Instance)->RowPosY1;
            }

            set
            {
                ((__Internal*)__Instance)->RowPosY1 = value;
            }
        }

        public float RowPosY2
        {
            get
            {
                return ((__Internal*)__Instance)->RowPosY2;
            }

            set
            {
                ((__Internal*)__Instance)->RowPosY2 = value;
            }
        }

        public float RowMinHeight
        {
            get
            {
                return ((__Internal*)__Instance)->RowMinHeight;
            }

            set
            {
                ((__Internal*)__Instance)->RowMinHeight = value;
            }
        }

        public float RowTextBaseline
        {
            get
            {
                return ((__Internal*)__Instance)->RowTextBaseline;
            }

            set
            {
                ((__Internal*)__Instance)->RowTextBaseline = value;
            }
        }

        public float RowIndentOffsetX
        {
            get
            {
                return ((__Internal*)__Instance)->RowIndentOffsetX;
            }

            set
            {
                ((__Internal*)__Instance)->RowIndentOffsetX = value;
            }
        }

        public int RowFlags
        {
            get
            {
                return ((__Internal*)__Instance)->RowFlags;
            }

            set
            {
                ((__Internal*)__Instance)->RowFlags = value;
            }
        }

        public int LastRowFlags
        {
            get
            {
                return ((__Internal*)__Instance)->LastRowFlags;
            }

            set
            {
                ((__Internal*)__Instance)->LastRowFlags = value;
            }
        }

        public int RowBgColorCounter
        {
            get
            {
                return ((__Internal*)__Instance)->RowBgColorCounter;
            }

            set
            {
                ((__Internal*)__Instance)->RowBgColorCounter = value;
            }
        }

        public uint[] RowBgColor
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->RowBgColor, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->RowBgColor[i] = value[i];
                }
            }
        }

        public uint BorderColorStrong
        {
            get
            {
                return ((__Internal*)__Instance)->BorderColorStrong;
            }

            set
            {
                ((__Internal*)__Instance)->BorderColorStrong = value;
            }
        }

        public uint BorderColorLight
        {
            get
            {
                return ((__Internal*)__Instance)->BorderColorLight;
            }

            set
            {
                ((__Internal*)__Instance)->BorderColorLight = value;
            }
        }

        public float BorderX1
        {
            get
            {
                return ((__Internal*)__Instance)->BorderX1;
            }

            set
            {
                ((__Internal*)__Instance)->BorderX1 = value;
            }
        }

        public float BorderX2
        {
            get
            {
                return ((__Internal*)__Instance)->BorderX2;
            }

            set
            {
                ((__Internal*)__Instance)->BorderX2 = value;
            }
        }

        public float HostIndentX
        {
            get
            {
                return ((__Internal*)__Instance)->HostIndentX;
            }

            set
            {
                ((__Internal*)__Instance)->HostIndentX = value;
            }
        }

        public float MinColumnWidth
        {
            get
            {
                return ((__Internal*)__Instance)->MinColumnWidth;
            }

            set
            {
                ((__Internal*)__Instance)->MinColumnWidth = value;
            }
        }

        public float OuterPaddingX
        {
            get
            {
                return ((__Internal*)__Instance)->OuterPaddingX;
            }

            set
            {
                ((__Internal*)__Instance)->OuterPaddingX = value;
            }
        }

        public float CellPaddingX
        {
            get
            {
                return ((__Internal*)__Instance)->CellPaddingX;
            }

            set
            {
                ((__Internal*)__Instance)->CellPaddingX = value;
            }
        }

        public float CellPaddingY
        {
            get
            {
                return ((__Internal*)__Instance)->CellPaddingY;
            }

            set
            {
                ((__Internal*)__Instance)->CellPaddingY = value;
            }
        }

        public float CellSpacingX1
        {
            get
            {
                return ((__Internal*)__Instance)->CellSpacingX1;
            }

            set
            {
                ((__Internal*)__Instance)->CellSpacingX1 = value;
            }
        }

        public float CellSpacingX2
        {
            get
            {
                return ((__Internal*)__Instance)->CellSpacingX2;
            }

            set
            {
                ((__Internal*)__Instance)->CellSpacingX2 = value;
            }
        }

        public float LastOuterHeight
        {
            get
            {
                return ((__Internal*)__Instance)->LastOuterHeight;
            }

            set
            {
                ((__Internal*)__Instance)->LastOuterHeight = value;
            }
        }

        public float LastFirstRowHeight
        {
            get
            {
                return ((__Internal*)__Instance)->LastFirstRowHeight;
            }

            set
            {
                ((__Internal*)__Instance)->LastFirstRowHeight = value;
            }
        }

        public float InnerWidth
        {
            get
            {
                return ((__Internal*)__Instance)->InnerWidth;
            }

            set
            {
                ((__Internal*)__Instance)->InnerWidth = value;
            }
        }

        public float ColumnsGivenWidth
        {
            get
            {
                return ((__Internal*)__Instance)->ColumnsGivenWidth;
            }

            set
            {
                ((__Internal*)__Instance)->ColumnsGivenWidth = value;
            }
        }

        public float ColumnsAutoFitWidth
        {
            get
            {
                return ((__Internal*)__Instance)->ColumnsAutoFitWidth;
            }

            set
            {
                ((__Internal*)__Instance)->ColumnsAutoFitWidth = value;
            }
        }

        public float ResizedColumnNextWidth
        {
            get
            {
                return ((__Internal*)__Instance)->ResizedColumnNextWidth;
            }

            set
            {
                ((__Internal*)__Instance)->ResizedColumnNextWidth = value;
            }
        }

        public float ResizeLockMinContentsX2
        {
            get
            {
                return ((__Internal*)__Instance)->ResizeLockMinContentsX2;
            }

            set
            {
                ((__Internal*)__Instance)->ResizeLockMinContentsX2 = value;
            }
        }

        public float RefScale
        {
            get
            {
                return ((__Internal*)__Instance)->RefScale;
            }

            set
            {
                ((__Internal*)__Instance)->RefScale = value;
            }
        }

        public global::ImGuiSharp.ImRect OuterRect
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->OuterRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->OuterRect = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImRect InnerRect
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->InnerRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->InnerRect = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImRect WorkRect
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WorkRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WorkRect = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImRect InnerClipRect
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->InnerClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->InnerClipRect = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImRect BgClipRect
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->BgClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->BgClipRect = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImRect Bg0ClipRectForDrawCmd
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Bg0ClipRectForDrawCmd));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Bg0ClipRectForDrawCmd = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImRect Bg2ClipRectForDrawCmd
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Bg2ClipRectForDrawCmd));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Bg2ClipRectForDrawCmd = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImRect HostClipRect
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->HostClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->HostClipRect = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImRect HostBackupInnerClipRect
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->HostBackupInnerClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->HostBackupInnerClipRect = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiWindow OuterWindow
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->OuterWindow, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->OuterWindow = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiWindow InnerWindow
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->InnerWindow, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->InnerWindow = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiTextBuffer ColumnsNames
        {
            get
            {
                return global::ImGuiSharp.ImGuiTextBuffer.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ColumnsNames));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ColumnsNames = *(global::ImGuiSharp.ImGuiTextBuffer.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImDrawListSplitter DrawSplitter
        {
            get
            {
                var __result0 = global::ImGuiSharp.ImDrawListSplitter.__GetOrCreateInstance(((__Internal*)__Instance)->DrawSplitter, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->DrawSplitter = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiTableColumnSortSpecs SortSpecsSingle
        {
            get
            {
                return global::ImGuiSharp.ImGuiTableColumnSortSpecs.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->SortSpecsSingle));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->SortSpecsSingle = *(global::ImGuiSharp.ImGuiTableColumnSortSpecs.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVectorImGuiTableColumnSortSpecs SortSpecsMulti
        {
            get
            {
                return global::ImGuiSharp.ImVectorImGuiTableColumnSortSpecs.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->SortSpecsMulti));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->SortSpecsMulti = *(global::ImGuiSharp.ImVectorImGuiTableColumnSortSpecs.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImGuiTableSortSpecs SortSpecs
        {
            get
            {
                return global::ImGuiSharp.ImGuiTableSortSpecs.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->SortSpecs));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->SortSpecs = *(global::ImGuiSharp.ImGuiTableSortSpecs.__Internal*) value.__Instance;
            }
        }

        public sbyte SortSpecsCount
        {
            get
            {
                return ((__Internal*)__Instance)->SortSpecsCount;
            }

            set
            {
                ((__Internal*)__Instance)->SortSpecsCount = value;
            }
        }

        public sbyte ColumnsEnabledCount
        {
            get
            {
                return ((__Internal*)__Instance)->ColumnsEnabledCount;
            }

            set
            {
                ((__Internal*)__Instance)->ColumnsEnabledCount = value;
            }
        }

        public sbyte ColumnsEnabledFixedCount
        {
            get
            {
                return ((__Internal*)__Instance)->ColumnsEnabledFixedCount;
            }

            set
            {
                ((__Internal*)__Instance)->ColumnsEnabledFixedCount = value;
            }
        }

        public sbyte DeclColumnsCount
        {
            get
            {
                return ((__Internal*)__Instance)->DeclColumnsCount;
            }

            set
            {
                ((__Internal*)__Instance)->DeclColumnsCount = value;
            }
        }

        public sbyte HoveredColumnBody
        {
            get
            {
                return ((__Internal*)__Instance)->HoveredColumnBody;
            }

            set
            {
                ((__Internal*)__Instance)->HoveredColumnBody = value;
            }
        }

        public sbyte HoveredColumnBorder
        {
            get
            {
                return ((__Internal*)__Instance)->HoveredColumnBorder;
            }

            set
            {
                ((__Internal*)__Instance)->HoveredColumnBorder = value;
            }
        }

        public sbyte AutoFitSingleColumn
        {
            get
            {
                return ((__Internal*)__Instance)->AutoFitSingleColumn;
            }

            set
            {
                ((__Internal*)__Instance)->AutoFitSingleColumn = value;
            }
        }

        public sbyte ResizedColumn
        {
            get
            {
                return ((__Internal*)__Instance)->ResizedColumn;
            }

            set
            {
                ((__Internal*)__Instance)->ResizedColumn = value;
            }
        }

        public sbyte LastResizedColumn
        {
            get
            {
                return ((__Internal*)__Instance)->LastResizedColumn;
            }

            set
            {
                ((__Internal*)__Instance)->LastResizedColumn = value;
            }
        }

        public sbyte HeldHeaderColumn
        {
            get
            {
                return ((__Internal*)__Instance)->HeldHeaderColumn;
            }

            set
            {
                ((__Internal*)__Instance)->HeldHeaderColumn = value;
            }
        }

        public sbyte ReorderColumn
        {
            get
            {
                return ((__Internal*)__Instance)->ReorderColumn;
            }

            set
            {
                ((__Internal*)__Instance)->ReorderColumn = value;
            }
        }

        public sbyte ReorderColumnDir
        {
            get
            {
                return ((__Internal*)__Instance)->ReorderColumnDir;
            }

            set
            {
                ((__Internal*)__Instance)->ReorderColumnDir = value;
            }
        }

        public sbyte LeftMostEnabledColumn
        {
            get
            {
                return ((__Internal*)__Instance)->LeftMostEnabledColumn;
            }

            set
            {
                ((__Internal*)__Instance)->LeftMostEnabledColumn = value;
            }
        }

        public sbyte RightMostEnabledColumn
        {
            get
            {
                return ((__Internal*)__Instance)->RightMostEnabledColumn;
            }

            set
            {
                ((__Internal*)__Instance)->RightMostEnabledColumn = value;
            }
        }

        public sbyte LeftMostStretchedColumn
        {
            get
            {
                return ((__Internal*)__Instance)->LeftMostStretchedColumn;
            }

            set
            {
                ((__Internal*)__Instance)->LeftMostStretchedColumn = value;
            }
        }

        public sbyte RightMostStretchedColumn
        {
            get
            {
                return ((__Internal*)__Instance)->RightMostStretchedColumn;
            }

            set
            {
                ((__Internal*)__Instance)->RightMostStretchedColumn = value;
            }
        }

        public sbyte ContextPopupColumn
        {
            get
            {
                return ((__Internal*)__Instance)->ContextPopupColumn;
            }

            set
            {
                ((__Internal*)__Instance)->ContextPopupColumn = value;
            }
        }

        public sbyte FreezeRowsRequest
        {
            get
            {
                return ((__Internal*)__Instance)->FreezeRowsRequest;
            }

            set
            {
                ((__Internal*)__Instance)->FreezeRowsRequest = value;
            }
        }

        public sbyte FreezeRowsCount
        {
            get
            {
                return ((__Internal*)__Instance)->FreezeRowsCount;
            }

            set
            {
                ((__Internal*)__Instance)->FreezeRowsCount = value;
            }
        }

        public sbyte FreezeColumnsRequest
        {
            get
            {
                return ((__Internal*)__Instance)->FreezeColumnsRequest;
            }

            set
            {
                ((__Internal*)__Instance)->FreezeColumnsRequest = value;
            }
        }

        public sbyte FreezeColumnsCount
        {
            get
            {
                return ((__Internal*)__Instance)->FreezeColumnsCount;
            }

            set
            {
                ((__Internal*)__Instance)->FreezeColumnsCount = value;
            }
        }

        public sbyte RowCellDataCurrent
        {
            get
            {
                return ((__Internal*)__Instance)->RowCellDataCurrent;
            }

            set
            {
                ((__Internal*)__Instance)->RowCellDataCurrent = value;
            }
        }

        public byte DummyDrawChannel
        {
            get
            {
                return ((__Internal*)__Instance)->DummyDrawChannel;
            }

            set
            {
                ((__Internal*)__Instance)->DummyDrawChannel = value;
            }
        }

        public byte Bg2DrawChannelCurrent
        {
            get
            {
                return ((__Internal*)__Instance)->Bg2DrawChannelCurrent;
            }

            set
            {
                ((__Internal*)__Instance)->Bg2DrawChannelCurrent = value;
            }
        }

        public byte Bg2DrawChannelUnfrozen
        {
            get
            {
                return ((__Internal*)__Instance)->Bg2DrawChannelUnfrozen;
            }

            set
            {
                ((__Internal*)__Instance)->Bg2DrawChannelUnfrozen = value;
            }
        }

        public bool IsLayoutLocked
        {
            get
            {
                return ((__Internal*)__Instance)->IsLayoutLocked != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsLayoutLocked = (byte) (value ? 1 : 0);
            }
        }

        public bool IsInsideRow
        {
            get
            {
                return ((__Internal*)__Instance)->IsInsideRow != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsInsideRow = (byte) (value ? 1 : 0);
            }
        }

        public bool IsInitializing
        {
            get
            {
                return ((__Internal*)__Instance)->IsInitializing != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsInitializing = (byte) (value ? 1 : 0);
            }
        }

        public bool IsSortSpecsDirty
        {
            get
            {
                return ((__Internal*)__Instance)->IsSortSpecsDirty != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsSortSpecsDirty = (byte) (value ? 1 : 0);
            }
        }

        public bool IsUsingHeaders
        {
            get
            {
                return ((__Internal*)__Instance)->IsUsingHeaders != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsUsingHeaders = (byte) (value ? 1 : 0);
            }
        }

        public bool IsContextPopupOpen
        {
            get
            {
                return ((__Internal*)__Instance)->IsContextPopupOpen != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsContextPopupOpen = (byte) (value ? 1 : 0);
            }
        }

        public bool IsSettingsRequestLoad
        {
            get
            {
                return ((__Internal*)__Instance)->IsSettingsRequestLoad != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsSettingsRequestLoad = (byte) (value ? 1 : 0);
            }
        }

        public bool IsSettingsDirty
        {
            get
            {
                return ((__Internal*)__Instance)->IsSettingsDirty != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsSettingsDirty = (byte) (value ? 1 : 0);
            }
        }

        public bool IsDefaultDisplayOrder
        {
            get
            {
                return ((__Internal*)__Instance)->IsDefaultDisplayOrder != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsDefaultDisplayOrder = (byte) (value ? 1 : 0);
            }
        }

        public bool IsResetAllRequest
        {
            get
            {
                return ((__Internal*)__Instance)->IsResetAllRequest != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsResetAllRequest = (byte) (value ? 1 : 0);
            }
        }

        public bool IsResetDisplayOrderRequest
        {
            get
            {
                return ((__Internal*)__Instance)->IsResetDisplayOrderRequest != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsResetDisplayOrderRequest = (byte) (value ? 1 : 0);
            }
        }

        public bool IsUnfrozenRows
        {
            get
            {
                return ((__Internal*)__Instance)->IsUnfrozenRows != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsUnfrozenRows = (byte) (value ? 1 : 0);
            }
        }

        public bool IsDefaultSizingPolicy
        {
            get
            {
                return ((__Internal*)__Instance)->IsDefaultSizingPolicy != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsDefaultSizingPolicy = (byte) (value ? 1 : 0);
            }
        }

        public bool MemoryCompacted
        {
            get
            {
                return ((__Internal*)__Instance)->MemoryCompacted != 0;
            }

            set
            {
                ((__Internal*)__Instance)->MemoryCompacted = (byte) (value ? 1 : 0);
            }
        }

        public bool HostSkipItems
        {
            get
            {
                return ((__Internal*)__Instance)->HostSkipItems != 0;
            }

            set
            {
                ((__Internal*)__Instance)->HostSkipItems = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImGuiTableTempData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 112)]
        public partial struct __Internal
        {
            public int TableIndex;
            public float LastTimeActive;
            public global::ImGuiSharp.ImVec2.__Internal UserOuterSize;
            public global::ImGuiSharp.ImDrawListSplitter.__Internal DrawSplitter;
            public global::ImGuiSharp.ImRect.__Internal HostBackupWorkRect;
            public global::ImGuiSharp.ImRect.__Internal HostBackupParentWorkRect;
            public global::ImGuiSharp.ImVec2.__Internal HostBackupPrevLineSize;
            public global::ImGuiSharp.ImVec2.__Internal HostBackupCurrLineSize;
            public global::ImGuiSharp.ImVec2.__Internal HostBackupCursorMaxPos;
            public global::ImGuiSharp.ImVec1.__Internal HostBackupColumnsOffset;
            public float HostBackupItemWidth;
            public int HostBackupItemWidthStackSize;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiTableTempData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiTableTempData> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiTableTempData>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiTableTempData managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiTableTempData managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiTableTempData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTableTempData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTableTempData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiTableTempData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiTableTempData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTableTempData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTableTempData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTableTempData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTableTempData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiTableTempData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTableTempData(global::ImGuiSharp.ImGuiTableTempData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiTableTempData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiTableTempData.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiTableTempData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int TableIndex
        {
            get
            {
                return ((__Internal*)__Instance)->TableIndex;
            }

            set
            {
                ((__Internal*)__Instance)->TableIndex = value;
            }
        }

        public float LastTimeActive
        {
            get
            {
                return ((__Internal*)__Instance)->LastTimeActive;
            }

            set
            {
                ((__Internal*)__Instance)->LastTimeActive = value;
            }
        }

        public global::ImGuiSharp.ImVec2 UserOuterSize
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->UserOuterSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->UserOuterSize = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImDrawListSplitter DrawSplitter
        {
            get
            {
                return global::ImGuiSharp.ImDrawListSplitter.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DrawSplitter));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DrawSplitter = *(global::ImGuiSharp.ImDrawListSplitter.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImRect HostBackupWorkRect
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->HostBackupWorkRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->HostBackupWorkRect = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImRect HostBackupParentWorkRect
        {
            get
            {
                return global::ImGuiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->HostBackupParentWorkRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->HostBackupParentWorkRect = *(global::ImGuiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 HostBackupPrevLineSize
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->HostBackupPrevLineSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->HostBackupPrevLineSize = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 HostBackupCurrLineSize
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->HostBackupCurrLineSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->HostBackupCurrLineSize = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec2 HostBackupCursorMaxPos
        {
            get
            {
                return global::ImGuiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->HostBackupCursorMaxPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->HostBackupCursorMaxPos = *(global::ImGuiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGuiSharp.ImVec1 HostBackupColumnsOffset
        {
            get
            {
                return global::ImGuiSharp.ImVec1.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->HostBackupColumnsOffset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->HostBackupColumnsOffset = *(global::ImGuiSharp.ImVec1.__Internal*) value.__Instance;
            }
        }

        public float HostBackupItemWidth
        {
            get
            {
                return ((__Internal*)__Instance)->HostBackupItemWidth;
            }

            set
            {
                ((__Internal*)__Instance)->HostBackupItemWidth = value;
            }
        }

        public int HostBackupItemWidthStackSize
        {
            get
            {
                return ((__Internal*)__Instance)->HostBackupItemWidthStackSize;
            }

            set
            {
                ((__Internal*)__Instance)->HostBackupItemWidthStackSize = value;
            }
        }
    }

    public unsafe partial class ImGuiTableColumnSettings : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public float WidthOrWeight;

            [FieldOffset(4)]
            public uint UserID;

            [FieldOffset(8)]
            public sbyte Index;

            [FieldOffset(9)]
            public sbyte DisplayOrder;

            [FieldOffset(10)]
            public sbyte SortOrder;

            [FieldOffset(11)]
            public byte SortDirection;

            [FieldOffset(11)]
            public byte IsEnabled;

            [FieldOffset(11)]
            public byte IsStretch;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiTableColumnSettings@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiTableColumnSettings> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiTableColumnSettings>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiTableColumnSettings managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiTableColumnSettings managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiTableColumnSettings __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTableColumnSettings(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTableColumnSettings __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiTableColumnSettings)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiTableColumnSettings __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTableColumnSettings(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTableColumnSettings(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTableColumnSettings(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTableColumnSettings()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiTableColumnSettings.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTableColumnSettings(global::ImGuiSharp.ImGuiTableColumnSettings _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiTableColumnSettings.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiTableColumnSettings.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiTableColumnSettings.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float WidthOrWeight
        {
            get
            {
                return ((__Internal*)__Instance)->WidthOrWeight;
            }

            set
            {
                ((__Internal*)__Instance)->WidthOrWeight = value;
            }
        }

        public uint UserID
        {
            get
            {
                return ((__Internal*)__Instance)->UserID;
            }

            set
            {
                ((__Internal*)__Instance)->UserID = value;
            }
        }

        public sbyte Index
        {
            get
            {
                return ((__Internal*)__Instance)->Index;
            }

            set
            {
                ((__Internal*)__Instance)->Index = value;
            }
        }

        public sbyte DisplayOrder
        {
            get
            {
                return ((__Internal*)__Instance)->DisplayOrder;
            }

            set
            {
                ((__Internal*)__Instance)->DisplayOrder = value;
            }
        }

        public sbyte SortOrder
        {
            get
            {
                return ((__Internal*)__Instance)->SortOrder;
            }

            set
            {
                ((__Internal*)__Instance)->SortOrder = value;
            }
        }

        public byte SortDirection
        {
            get
            {
                return ((__Internal*)__Instance)->SortDirection;
            }

            set
            {
                ((__Internal*)__Instance)->SortDirection = value;
            }
        }

        public byte IsEnabled
        {
            get
            {
                return ((__Internal*)__Instance)->IsEnabled;
            }

            set
            {
                ((__Internal*)__Instance)->IsEnabled = value;
            }
        }

        public byte IsStretch
        {
            get
            {
                return ((__Internal*)__Instance)->IsStretch;
            }

            set
            {
                ((__Internal*)__Instance)->IsStretch = value;
            }
        }
    }

    public unsafe partial class ImGuiTableSettings : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public uint ID;
            public int SaveFlags;
            public float RefScale;
            public sbyte ColumnsCount;
            public sbyte ColumnsCountMax;
            public byte WantApply;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiTableSettings@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiTableSettings> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImGuiTableSettings>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImGuiTableSettings managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImGuiTableSettings managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiTableSettings __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTableSettings(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTableSettings __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiTableSettings)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiTableSettings __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTableSettings(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTableSettings(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTableSettings(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTableSettings()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiTableSettings.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTableSettings(global::ImGuiSharp.ImGuiTableSettings _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImGuiTableSettings.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImGuiTableSettings.__Internal*) __Instance) = *((global::ImGuiSharp.ImGuiTableSettings.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ID
        {
            get
            {
                return ((__Internal*)__Instance)->ID;
            }

            set
            {
                ((__Internal*)__Instance)->ID = value;
            }
        }

        public int SaveFlags
        {
            get
            {
                return ((__Internal*)__Instance)->SaveFlags;
            }

            set
            {
                ((__Internal*)__Instance)->SaveFlags = value;
            }
        }

        public float RefScale
        {
            get
            {
                return ((__Internal*)__Instance)->RefScale;
            }

            set
            {
                ((__Internal*)__Instance)->RefScale = value;
            }
        }

        public sbyte ColumnsCount
        {
            get
            {
                return ((__Internal*)__Instance)->ColumnsCount;
            }

            set
            {
                ((__Internal*)__Instance)->ColumnsCount = value;
            }
        }

        public sbyte ColumnsCountMax
        {
            get
            {
                return ((__Internal*)__Instance)->ColumnsCountMax;
            }

            set
            {
                ((__Internal*)__Instance)->ColumnsCountMax = value;
            }
        }

        public bool WantApply
        {
            get
            {
                return ((__Internal*)__Instance)->WantApply != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantApply = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImFontBuilderIO : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            public __IntPtr FontBuilder_Build;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImFontBuilderIO@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImFontBuilderIO> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGuiSharp.ImFontBuilderIO>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ImGuiSharp.ImFontBuilderIO managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ImGuiSharp.ImFontBuilderIO managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImFontBuilderIO __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImFontBuilderIO(native.ToPointer(), skipVTables);
        }

        internal static ImFontBuilderIO __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImFontBuilderIO)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImFontBuilderIO __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImFontBuilderIO(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImFontBuilderIO(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImFontBuilderIO(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImFontBuilderIO()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImFontBuilderIO.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImFontBuilderIO(global::ImGuiSharp.ImFontBuilderIO _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGuiSharp.ImFontBuilderIO.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ImGuiSharp.ImFontBuilderIO.__Internal*) __Instance) = *((global::ImGuiSharp.ImFontBuilderIO.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGuiSharp.Delegates.Func_bool___IntPtr FontBuilderBuild
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->FontBuilder_Build;
                return __ptr0 == IntPtr.Zero? null : (global::ImGuiSharp.Delegates.Func_bool___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ImGuiSharp.Delegates.Func_bool___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->FontBuilder_Build = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class ImGui
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVec2_ImVec2_Nil", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImVec2ImVec2Nil();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVec2_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImVec2_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVec2_ImVec2_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImVec2ImVec2Float(float _x, float _y);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVec4_ImVec4_Nil", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImVec4ImVec4Nil();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVec4_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImVec4_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVec4_ImVec4_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImVec4ImVec4Float(float _x, float _y, float _z, float _w);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCreateContext", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr CreateContext(__IntPtr shared_font_atlas);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDestroyContext", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DestroyContext(__IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetCurrentContext", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetCurrentContext();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetCurrentContext", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetCurrentContext(__IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetIO", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetIO();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetStyle", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetStyle();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igNewFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void NewFrame();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndFrame();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRender", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Render();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetDrawData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetDrawData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igShowDemoWindow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ShowDemoWindow(bool* p_open);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igShowMetricsWindow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ShowMetricsWindow(bool* p_open);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igShowStackToolWindow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ShowStackToolWindow(bool* p_open);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igShowAboutWindow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ShowAboutWindow(bool* p_open);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igShowStyleEditor", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ShowStyleEditor(__IntPtr @ref);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igShowStyleSelector", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ShowStyleSelector([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igShowFontSelector", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ShowFontSelector([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igShowUserGuide", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ShowUserGuide();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetVersion", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetVersion();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igStyleColorsDark", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void StyleColorsDark(__IntPtr dst);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igStyleColorsLight", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void StyleColorsLight(__IntPtr dst);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igStyleColorsClassic", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void StyleColorsClassic(__IntPtr dst);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBegin", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool Begin([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, bool* p_open, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEnd", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void End();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginChild_Str", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginChildStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, global::ImGuiSharp.ImVec2.__Internal size, bool border, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginChild_ID", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginChildID(uint id, global::ImGuiSharp.ImVec2.__Internal size, bool border, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndChild", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndChild();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsWindowAppearing", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsWindowAppearing();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsWindowCollapsed", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsWindowCollapsed();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsWindowFocused", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsWindowFocused(int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsWindowHovered", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsWindowHovered(int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetWindowDrawList", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetWindowDrawList();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetWindowPos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetWindowPos(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetWindowSize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetWindowSize(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetWindowWidth", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetWindowWidth();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetWindowHeight", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetWindowHeight();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetNextWindowPos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextWindowPos(global::ImGuiSharp.ImVec2.__Internal pos, int cond, global::ImGuiSharp.ImVec2.__Internal pivot);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetNextWindowSize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextWindowSize(global::ImGuiSharp.ImVec2.__Internal size, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetNextWindowSizeConstraints", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextWindowSizeConstraints(global::ImGuiSharp.ImVec2.__Internal size_min, global::ImGuiSharp.ImVec2.__Internal size_max, __IntPtr custom_callback, __IntPtr custom_callback_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetNextWindowContentSize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextWindowContentSize(global::ImGuiSharp.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetNextWindowCollapsed", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextWindowCollapsed(bool collapsed, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetNextWindowFocus", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextWindowFocus();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetNextWindowBgAlpha", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextWindowBgAlpha(float alpha);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetWindowPos_Vec2", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowPosVec2(global::ImGuiSharp.ImVec2.__Internal pos, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetWindowSize_Vec2", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowSizeVec2(global::ImGuiSharp.ImVec2.__Internal size, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetWindowCollapsed_Bool", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowCollapsedBool(bool collapsed, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetWindowFocus_Nil", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowFocusNil();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetWindowFontScale", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowFontScale(float scale);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetWindowPos_Str", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowPosStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, global::ImGuiSharp.ImVec2.__Internal pos, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetWindowSize_Str", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowSizeStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, global::ImGuiSharp.ImVec2.__Internal size, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetWindowCollapsed_Str", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowCollapsedStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, bool collapsed, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetWindowFocus_Str", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowFocusStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetContentRegionAvail", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetContentRegionAvail(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetContentRegionMax", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetContentRegionMax(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetWindowContentRegionMin", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetWindowContentRegionMin(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetWindowContentRegionMax", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetWindowContentRegionMax(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetScrollX", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetScrollX();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetScrollY", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetScrollY();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetScrollX_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetScrollX_Float(float scroll_x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetScrollY_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetScrollY_Float(float scroll_y);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetScrollMaxX", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetScrollMaxX();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetScrollMaxY", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetScrollMaxY();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetScrollHereX", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetScrollHereX(float center_x_ratio);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetScrollHereY", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetScrollHereY(float center_y_ratio);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetScrollFromPosX_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetScrollFromPosX_Float(float local_x, float center_x_ratio);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetScrollFromPosY_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetScrollFromPosY_Float(float local_y, float center_y_ratio);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushFont", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushFont(__IntPtr font);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPopFont", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PopFont();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushStyleColor_U32", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushStyleColorU32(int idx, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushStyleColor_Vec4", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushStyleColorVec4(int idx, global::ImGuiSharp.ImVec4.__Internal col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPopStyleColor", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PopStyleColor(int count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushStyleVar_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushStyleVarFloat(int idx, float val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushStyleVar_Vec2", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushStyleVarVec2(int idx, global::ImGuiSharp.ImVec2.__Internal val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPopStyleVar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PopStyleVar(int count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushAllowKeyboardFocus", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushAllowKeyboardFocus(bool allow_keyboard_focus);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPopAllowKeyboardFocus", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PopAllowKeyboardFocus();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushButtonRepeat", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushButtonRepeat(bool repeat);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPopButtonRepeat", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PopButtonRepeat();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushItemWidth", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushItemWidth(float item_width);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPopItemWidth", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PopItemWidth();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetNextItemWidth", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextItemWidth(float item_width);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCalcItemWidth", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float CalcItemWidth();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushTextWrapPos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushTextWrapPos(float wrap_local_pos_x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPopTextWrapPos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PopTextWrapPos();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetFont", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetFont();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetFontSize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetFontSize();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetFontTexUvWhitePixel", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetFontTexUvWhitePixel(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetColorU32_Col", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetColorU32Col(int idx, float alpha_mul);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetColorU32_Vec4", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetColorU32Vec4(global::ImGuiSharp.ImVec4.__Internal col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetColorU32_U32", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetColorU32U32(uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetStyleColorVec4", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetStyleColorVec4(int idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSeparator", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Separator();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSameLine", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SameLine(float offset_from_start_x, float spacing);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igNewLine", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void NewLine();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSpacing", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Spacing();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDummy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Dummy(global::ImGuiSharp.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIndent", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Indent(float indent_w);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igUnindent", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Unindent(float indent_w);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginGroup", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void BeginGroup();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndGroup", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndGroup();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetCursorPos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetCursorPos(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetCursorPosX", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetCursorPosX();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetCursorPosY", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetCursorPosY();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetCursorPos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetCursorPos(global::ImGuiSharp.ImVec2.__Internal local_pos);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetCursorPosX", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetCursorPosX(float local_x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetCursorPosY", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetCursorPosY(float local_y);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetCursorStartPos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetCursorStartPos(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetCursorScreenPos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetCursorScreenPos(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetCursorScreenPos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetCursorScreenPos(global::ImGuiSharp.ImVec2.__Internal pos);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igAlignTextToFramePadding", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void AlignTextToFramePadding();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetTextLineHeight", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetTextLineHeight();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetTextLineHeightWithSpacing", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetTextLineHeightWithSpacing();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetFrameHeight", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetFrameHeight();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetFrameHeightWithSpacing", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetFrameHeightWithSpacing();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushID_Str", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushID_Str([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushID_StrStr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushID_StrStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id_begin, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushID_Ptr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushID_Ptr(__IntPtr ptr_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushID_Int", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushID_Int(int int_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPopID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PopID();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetID_Str", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetID_Str([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetID_StrStr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetID_StrStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id_begin, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetID_Ptr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetID_Ptr(__IntPtr ptr_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTextUnformatted", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TextUnformatted([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igText", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Text([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTextColored", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TextColored(global::ImGuiSharp.ImVec4.__Internal col, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTextDisabled", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TextDisabled([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTextWrapped", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TextWrapped([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igLabelText", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LabelText([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBulletText", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void BulletText([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igButton", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool Button([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, global::ImGuiSharp.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSmallButton", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SmallButton([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInvisibleButton", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InvisibleButton([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, global::ImGuiSharp.ImVec2.__Internal size, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igArrowButton", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ArrowButton([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int dir);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImage", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Image(__IntPtr user_texture_id, global::ImGuiSharp.ImVec2.__Internal size, global::ImGuiSharp.ImVec2.__Internal uv0, global::ImGuiSharp.ImVec2.__Internal uv1, global::ImGuiSharp.ImVec4.__Internal tint_col, global::ImGuiSharp.ImVec4.__Internal border_col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImageButton", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImageButton(__IntPtr user_texture_id, global::ImGuiSharp.ImVec2.__Internal size, global::ImGuiSharp.ImVec2.__Internal uv0, global::ImGuiSharp.ImVec2.__Internal uv1, int frame_padding, global::ImGuiSharp.ImVec4.__Internal bg_col, global::ImGuiSharp.ImVec4.__Internal tint_col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCheckbox", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool Checkbox([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, bool* v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCheckboxFlags_IntPtr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool CheckboxFlagsIntPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* flags, int flags_value);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCheckboxFlags_UintPtr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool CheckboxFlagsUintPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, uint* flags, uint flags_value);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRadioButton_Bool", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool RadioButtonBool([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, bool active);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRadioButton_IntPtr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool RadioButtonIntPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* v, int v_button);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igProgressBar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ProgressBar(float fraction, global::ImGuiSharp.ImVec2.__Internal size_arg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string overlay);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBullet", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Bullet();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginCombo", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginCombo([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string preview_value, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndCombo", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndCombo();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCombo_Str_arr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ComboStr_arr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* current_item, [MarshalAs(UnmanagedType.LPArray)] string[] items, int items_count, int popup_max_height_in_items);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCombo_Str", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ComboStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* current_item, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string items_separated_by_zeros, int popup_max_height_in_items);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCombo_FnBoolPtr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ComboFnBoolPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* current_item, __IntPtr items_getter, __IntPtr data, int items_count, int popup_max_height_in_items);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDragFloat", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragFloat([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float* v, float v_speed, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDragFloat2", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragFloat2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, float v_speed, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDragFloat3", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragFloat3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, float v_speed, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDragFloat4", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragFloat4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, float v_speed, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDragFloatRange2", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragFloatRange2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float* v_current_min, float* v_current_max, float v_speed, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format_max, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDragInt", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragInt([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* v, float v_speed, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDragInt2", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragInt2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, float v_speed, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDragInt3", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragInt3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, float v_speed, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDragInt4", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragInt4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, float v_speed, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDragIntRange2", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragIntRange2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* v_current_min, int* v_current_max, float v_speed, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format_max, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDragScalar", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragScalar([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int data_type, __IntPtr p_data, float v_speed, __IntPtr p_min, __IntPtr p_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDragScalarN", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragScalarN([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int data_type, __IntPtr p_data, int components, float v_speed, __IntPtr p_min, __IntPtr p_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSliderFloat", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderFloat([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float* v, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSliderFloat2", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderFloat2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSliderFloat3", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderFloat3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSliderFloat4", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderFloat4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSliderAngle", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderAngle([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float* v_rad, float v_degrees_min, float v_degrees_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSliderInt", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderInt([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* v, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSliderInt2", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderInt2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSliderInt3", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderInt3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSliderInt4", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderInt4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSliderScalar", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderScalar([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int data_type, __IntPtr p_data, __IntPtr p_min, __IntPtr p_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSliderScalarN", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderScalarN([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int data_type, __IntPtr p_data, int components, __IntPtr p_min, __IntPtr p_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igVSliderFloat", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool VSliderFloat([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, global::ImGuiSharp.ImVec2.__Internal size, float* v, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igVSliderInt", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool VSliderInt([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, global::ImGuiSharp.ImVec2.__Internal size, int* v, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igVSliderScalar", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool VSliderScalar([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, global::ImGuiSharp.ImVec2.__Internal size, int data_type, __IntPtr p_data, __IntPtr p_min, __IntPtr p_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInputText", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputText([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, sbyte* buf, IntPtr buf_size, int flags, __IntPtr callback, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInputTextMultiline", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputTextMultiline([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, sbyte* buf, IntPtr buf_size, global::ImGuiSharp.ImVec2.__Internal size, int flags, __IntPtr callback, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInputTextWithHint", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputTextWithHint([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string hint, sbyte* buf, IntPtr buf_size, int flags, __IntPtr callback, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInputFloat", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputFloat([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float* v, float step, float step_fast, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInputFloat2", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputFloat2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInputFloat3", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputFloat3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInputFloat4", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputFloat4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInputInt", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputInt([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* v, int step, int step_fast, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInputInt2", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputInt2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInputInt3", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputInt3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInputInt4", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputInt4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInputDouble", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputDouble([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, double* v, double step, double step_fast, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInputScalar", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputScalar([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int data_type, __IntPtr p_data, __IntPtr p_step, __IntPtr p_step_fast, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInputScalarN", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputScalarN([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int data_type, __IntPtr p_data, int components, __IntPtr p_step, __IntPtr p_step_fast, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igColorEdit3", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ColorEdit3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] col, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igColorEdit4", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ColorEdit4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] col, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igColorPicker3", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ColorPicker3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] col, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igColorPicker4", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ColorPicker4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] col, int flags, float* ref_col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igColorButton", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ColorButton([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string desc_id, global::ImGuiSharp.ImVec4.__Internal col, int flags, global::ImGuiSharp.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetColorEditOptions", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetColorEditOptions(int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTreeNode_Str", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TreeNodeStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTreeNode_StrStr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TreeNodeStrStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTreeNode_Ptr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TreeNodePtr(__IntPtr ptr_id, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTreeNodeEx_Str", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TreeNodeExStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTreeNodeEx_StrStr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TreeNodeExStrStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int flags, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTreeNodeEx_Ptr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TreeNodeExPtr(__IntPtr ptr_id, int flags, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTreePush_Str", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TreePushStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTreePush_Ptr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TreePushPtr(__IntPtr ptr_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTreePop", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TreePop();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetTreeNodeToLabelSpacing", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetTreeNodeToLabelSpacing();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCollapsingHeader_TreeNodeFlags", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool CollapsingHeaderTreeNodeFlags([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCollapsingHeader_BoolPtr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool CollapsingHeaderBoolPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, bool* p_visible, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetNextItemOpen", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextItemOpen(bool is_open, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSelectable_Bool", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SelectableBool([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, bool selected, int flags, global::ImGuiSharp.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSelectable_BoolPtr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SelectableBoolPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, bool* p_selected, int flags, global::ImGuiSharp.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginListBox", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginListBox([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, global::ImGuiSharp.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndListBox", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndListBox();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igListBox_Str_arr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ListBoxStr_arr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* current_item, [MarshalAs(UnmanagedType.LPArray)] string[] items, int items_count, int height_in_items);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igListBox_FnBoolPtr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ListBoxFnBoolPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* current_item, __IntPtr items_getter, __IntPtr data, int items_count, int height_in_items);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPlotLines_FloatPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PlotLinesFloatPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float* values, int values_count, int values_offset, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string overlay_text, float scale_min, float scale_max, global::ImGuiSharp.ImVec2.__Internal graph_size, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPlotLines_FnFloatPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PlotLinesFnFloatPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, __IntPtr values_getter, __IntPtr data, int values_count, int values_offset, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string overlay_text, float scale_min, float scale_max, global::ImGuiSharp.ImVec2.__Internal graph_size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPlotHistogram_FloatPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PlotHistogramFloatPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float* values, int values_count, int values_offset, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string overlay_text, float scale_min, float scale_max, global::ImGuiSharp.ImVec2.__Internal graph_size, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPlotHistogram_FnFloatPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PlotHistogramFnFloatPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, __IntPtr values_getter, __IntPtr data, int values_count, int values_offset, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string overlay_text, float scale_min, float scale_max, global::ImGuiSharp.ImVec2.__Internal graph_size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igValue_Bool", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ValueBool([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string prefix, bool b);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igValue_Int", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ValueInt([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string prefix, int v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igValue_Uint", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ValueUint([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string prefix, uint v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igValue_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ValueFloat([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string prefix, float v, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string float_format);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginMenuBar", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginMenuBar();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndMenuBar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndMenuBar();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginMainMenuBar", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginMainMenuBar();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndMainMenuBar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndMainMenuBar();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginMenu", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginMenu([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, bool enabled);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndMenu", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndMenu();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igMenuItem_Bool", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool MenuItemBool([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string shortcut, bool selected, bool enabled);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igMenuItem_BoolPtr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool MenuItemBoolPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string shortcut, bool* p_selected, bool enabled);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginTooltip", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void BeginTooltip();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndTooltip", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndTooltip();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetTooltip", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetTooltip([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginPopup", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginPopup([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginPopupModal", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginPopupModal([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, bool* p_open, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndPopup", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndPopup();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igOpenPopup_Str", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void OpenPopupStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int popup_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igOpenPopup_ID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void OpenPopupID(uint id, int popup_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igOpenPopupOnItemClick", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void OpenPopupOnItemClick([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int popup_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCloseCurrentPopup", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void CloseCurrentPopup();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginPopupContextItem", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginPopupContextItem([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int popup_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginPopupContextWindow", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginPopupContextWindow([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int popup_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginPopupContextVoid", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginPopupContextVoid([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int popup_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsPopupOpen_Str", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsPopupOpenStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginTable", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginTable([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int column, int flags, global::ImGuiSharp.ImVec2.__Internal outer_size, float inner_width);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndTable", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndTable();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableNextRow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableNextRow(int row_flags, float min_row_height);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableNextColumn", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TableNextColumn();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableSetColumnIndex", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TableSetColumnIndex(int column_n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableSetupColumn", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableSetupColumn([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int flags, float init_width_or_weight, uint user_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableSetupScrollFreeze", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableSetupScrollFreeze(int cols, int rows);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableHeadersRow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableHeadersRow();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableHeader", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableHeader([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGetSortSpecs", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr TableGetSortSpecs();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGetColumnCount", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int TableGetColumnCount();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGetColumnIndex", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int TableGetColumnIndex();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGetRowIndex", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int TableGetRowIndex();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGetColumnName_Int", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr TableGetColumnNameInt(int column_n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGetColumnFlags", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int TableGetColumnFlags(int column_n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableSetColumnEnabled", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableSetColumnEnabled(int column_n, bool v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableSetBgColor", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableSetBgColor(int target, uint color, int column_n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igColumns", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Columns(int count, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string id, bool border);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igNextColumn", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void NextColumn();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetColumnIndex", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int GetColumnIndex();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetColumnWidth", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetColumnWidth(int column_index);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetColumnWidth", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetColumnWidth(int column_index, float width);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetColumnOffset", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetColumnOffset(int column_index);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetColumnOffset", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetColumnOffset(int column_index, float offset_x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetColumnsCount", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int GetColumnsCount();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginTabBar", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginTabBar([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndTabBar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndTabBar();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginTabItem", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginTabItem([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, bool* p_open, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndTabItem", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndTabItem();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTabItemButton", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TabItemButton([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetTabItemClosed", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetTabItemClosed([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string tab_or_docked_window_label);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igLogToTTY", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LogToTTY(int auto_open_depth);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igLogToFile", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LogToFile(int auto_open_depth, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string filename);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igLogToClipboard", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LogToClipboard(int auto_open_depth);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igLogFinish", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LogFinish();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igLogButtons", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LogButtons();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginDragDropSource", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginDragDropSource(int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetDragDropPayload", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SetDragDropPayload([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string type, __IntPtr data, IntPtr sz, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndDragDropSource", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndDragDropSource();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginDragDropTarget", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginDragDropTarget();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igAcceptDragDropPayload", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr AcceptDragDropPayload([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string type, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndDragDropTarget", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndDragDropTarget();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetDragDropPayload", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetDragDropPayload();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginDisabled", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void BeginDisabled(bool disabled);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndDisabled", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndDisabled();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushClipRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushClipRect(global::ImGuiSharp.ImVec2.__Internal clip_rect_min, global::ImGuiSharp.ImVec2.__Internal clip_rect_max, bool intersect_with_current_clip_rect);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPopClipRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PopClipRect();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetItemDefaultFocus", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetItemDefaultFocus();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetKeyboardFocusHere", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetKeyboardFocusHere(int offset);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsItemHovered", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsItemHovered(int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsItemActive", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsItemActive();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsItemFocused", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsItemFocused();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsItemClicked", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsItemClicked(int mouse_button);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsItemVisible", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsItemVisible();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsItemEdited", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsItemEdited();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsItemActivated", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsItemActivated();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsItemDeactivated", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsItemDeactivated();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsItemDeactivatedAfterEdit", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsItemDeactivatedAfterEdit();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsItemToggledOpen", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsItemToggledOpen();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsAnyItemHovered", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsAnyItemHovered();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsAnyItemActive", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsAnyItemActive();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsAnyItemFocused", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsAnyItemFocused();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetItemRectMin", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetItemRectMin(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetItemRectMax", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetItemRectMax(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetItemRectSize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetItemRectSize(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetItemAllowOverlap", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetItemAllowOverlap();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetMainViewport", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetMainViewport();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsRectVisible_Nil", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsRectVisibleNil(global::ImGuiSharp.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsRectVisible_Vec2", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsRectVisibleVec2(global::ImGuiSharp.ImVec2.__Internal rect_min, global::ImGuiSharp.ImVec2.__Internal rect_max);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetTime", CallingConvention = __CallingConvention.Cdecl)]
            public static extern double GetTime();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetFrameCount", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int GetFrameCount();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetBackgroundDrawList_Nil", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetBackgroundDrawListNil();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetForegroundDrawList_Nil", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetForegroundDrawListNil();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetDrawListSharedData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetDrawListSharedData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetStyleColorName", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetStyleColorName(int idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetStateStorage", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetStateStorage(__IntPtr storage);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetStateStorage", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetStateStorage();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginChildFrame", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginChildFrame(uint id, global::ImGuiSharp.ImVec2.__Internal size, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndChildFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndChildFrame();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCalcTextSize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void CalcTextSize(__IntPtr pOut, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end, bool hide_text_after_double_hash, float wrap_width);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igColorConvertU32ToFloat4", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ColorConvertU32ToFloat4(__IntPtr pOut, uint @in);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igColorConvertFloat4ToU32", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint ColorConvertFloat4ToU32(global::ImGuiSharp.ImVec4.__Internal @in);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igColorConvertRGBtoHSV", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ColorConvertRGBtoHSV(float r, float g, float b, float* out_h, float* out_s, float* out_v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igColorConvertHSVtoRGB", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ColorConvertHSVtoRGB(float h, float s, float v, float* out_r, float* out_g, float* out_b);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsKeyDown", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsKeyDown(int key);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsKeyPressed", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsKeyPressed(int key, bool repeat);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsKeyReleased", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsKeyReleased(int key);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetKeyPressedAmount", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int GetKeyPressedAmount(int key, float repeat_delay, float rate);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetKeyName", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetKeyName(int key);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCaptureKeyboardFromApp", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void CaptureKeyboardFromApp(bool want_capture_keyboard_value);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsMouseDown", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsMouseDown(int button);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsMouseClicked", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsMouseClicked(int button, bool repeat);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsMouseReleased", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsMouseReleased(int button);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsMouseDoubleClicked", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsMouseDoubleClicked(int button);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetMouseClickedCount", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int GetMouseClickedCount(int button);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsMouseHoveringRect", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsMouseHoveringRect(global::ImGuiSharp.ImVec2.__Internal r_min, global::ImGuiSharp.ImVec2.__Internal r_max, bool clip);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsMousePosValid", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsMousePosValid(__IntPtr mouse_pos);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsAnyMouseDown", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsAnyMouseDown();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetMousePos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetMousePos(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetMousePosOnOpeningCurrentPopup", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetMousePosOnOpeningCurrentPopup(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsMouseDragging", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsMouseDragging(int button, float lock_threshold);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetMouseDragDelta", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetMouseDragDelta(__IntPtr pOut, int button, float lock_threshold);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igResetMouseDragDelta", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ResetMouseDragDelta(int button);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetMouseCursor", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int GetMouseCursor();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetMouseCursor", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetMouseCursor(int cursor_type);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCaptureMouseFromApp", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void CaptureMouseFromApp(bool want_capture_mouse_value);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetClipboardText", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetClipboardText();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetClipboardText", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetClipboardText([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igLoadIniSettingsFromDisk", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LoadIniSettingsFromDisk([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string ini_filename);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igLoadIniSettingsFromMemory", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LoadIniSettingsFromMemory([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string ini_data, IntPtr ini_size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSaveIniSettingsToDisk", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SaveIniSettingsToDisk([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string ini_filename);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSaveIniSettingsToMemory", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr SaveIniSettingsToMemory(IntPtr* out_ini_size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugCheckVersionAndDataLayout", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DebugCheckVersionAndDataLayout([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string version_str, IntPtr sz_io, IntPtr sz_style, IntPtr sz_vec2, IntPtr sz_vec4, IntPtr sz_drawvert, IntPtr sz_drawidx);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetAllocatorFunctions", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetAllocatorFunctions(__IntPtr alloc_func, __IntPtr free_func, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetAllocatorFunctions", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetAllocatorFunctions(__IntPtr p_alloc_func, __IntPtr p_free_func, __IntPtr* p_user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igMemAlloc", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr MemAlloc(IntPtr size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igMemFree", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void MemFree(__IntPtr ptr);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStyle_ImGuiStyle", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiStyleImGuiStyle();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStyle_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStyle_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStyle_ScaleAllSizes", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStyleScaleAllSizes(__IntPtr self, float scale_factor);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiIO_AddKeyEvent", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiIO_AddKeyEvent(__IntPtr self, int key, bool down);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiIO_AddKeyAnalogEvent", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiIO_AddKeyAnalogEvent(__IntPtr self, int key, bool down, float v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiIO_AddMousePosEvent", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiIO_AddMousePosEvent(__IntPtr self, float x, float y);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiIO_AddMouseButtonEvent", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiIO_AddMouseButtonEvent(__IntPtr self, int button, bool down);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiIO_AddMouseWheelEvent", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiIO_AddMouseWheelEvent(__IntPtr self, float wh_x, float wh_y);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiIO_AddFocusEvent", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiIO_AddFocusEvent(__IntPtr self, bool focused);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiIO_AddInputCharacter", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiIO_AddInputCharacter(__IntPtr self, uint c);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiIO_AddInputCharacterUTF16", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiIO_AddInputCharacterUTF16(__IntPtr self, ushort c);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiIO_AddInputCharactersUTF8", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiIO_AddInputCharactersUTF8(__IntPtr self, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiIO_ClearInputCharacters", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiIO_ClearInputCharacters(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiIO_ClearInputKeys", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiIO_ClearInputKeys(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiIO_SetKeyEventNativeData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiIO_SetKeyEventNativeData(__IntPtr self, int key, int native_keycode, int native_scancode, int native_legacy_index);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiIO_ImGuiIO", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiIO_ImGuiIO();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiIO_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiIO_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextCallbackData_ImGuiInputTextCallbackData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiInputTextCallbackDataImGuiInputTextCallbackData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextCallbackData_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiInputTextCallbackData_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextCallbackData_DeleteChars", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiInputTextCallbackDataDeleteChars(__IntPtr self, int pos, int bytes_count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextCallbackData_InsertChars", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiInputTextCallbackDataInsertChars(__IntPtr self, int pos, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextCallbackData_SelectAll", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiInputTextCallbackDataSelectAll(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextCallbackData_ClearSelection", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiInputTextCallbackDataClearSelection(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextCallbackData_HasSelection", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiInputTextCallbackDataHasSelection(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiPayload_ImGuiPayload", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiPayloadImGuiPayload();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiPayload_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiPayload_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiPayload_Clear", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiPayloadClear(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiPayload_IsDataType", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiPayloadIsDataType(__IntPtr self, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string type);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiPayload_IsPreview", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiPayloadIsPreview(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiPayload_IsDelivery", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiPayloadIsDelivery(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTableColumnSortSpecs_ImGuiTableColumnSortSpecs", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTableColumnSortSpecsImGuiTableColumnSortSpecs();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTableColumnSortSpecs_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTableColumnSortSpecs_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTableSortSpecs_ImGuiTableSortSpecs", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTableSortSpecsImGuiTableSortSpecs();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTableSortSpecs_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTableSortSpecs_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiOnceUponAFrame_ImGuiOnceUponAFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiOnceUponAFrameImGuiOnceUponAFrame();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiOnceUponAFrame_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiOnceUponAFrame_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextFilter_ImGuiTextFilter", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTextFilterImGuiTextFilter([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string default_filter);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextFilter_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTextFilter_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextFilter_Draw", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiTextFilterDraw(__IntPtr self, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float width);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextFilter_PassFilter", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiTextFilterPassFilter(__IntPtr self, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextFilter_Build", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTextFilterBuild(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextFilter_Clear", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTextFilterClear(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextFilter_IsActive", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiTextFilterIsActive(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextRange_ImGuiTextRange_Nil", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTextRangeImGuiTextRangeNil();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextRange_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTextRange_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextRange_ImGuiTextRange_Str", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTextRangeImGuiTextRangeStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string _b, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string _e);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextRange_empty", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiTextRange_empty(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextRange_split", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTextRange_split(__IntPtr self, sbyte separator, __IntPtr @out);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextBuffer_ImGuiTextBuffer", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTextBufferImGuiTextBuffer();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextBuffer_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTextBuffer_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextBuffer_begin", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTextBuffer_begin(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextBuffer_end", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTextBuffer_end(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextBuffer_size", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImGuiTextBuffer_size(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextBuffer_empty", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiTextBuffer_empty(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextBuffer_clear", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTextBuffer_clear(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextBuffer_reserve", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTextBuffer_reserve(__IntPtr self, int capacity);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextBuffer_c_str", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTextBuffer_c_str(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextBuffer_append", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTextBuffer_append(__IntPtr self, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStoragePair_ImGuiStoragePair_Int", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiStoragePairImGuiStoragePairInt(uint _key, int _val_i);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStoragePair_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStoragePair_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStoragePair_ImGuiStoragePair_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiStoragePairImGuiStoragePairFloat(uint _key, float _val_f);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStoragePair_ImGuiStoragePair_Ptr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiStoragePairImGuiStoragePairPtr(uint _key, __IntPtr _val_p);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStorage_Clear", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStorageClear(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStorage_GetInt", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImGuiStorageGetInt(__IntPtr self, uint key, int default_val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStorage_SetInt", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStorageSetInt(__IntPtr self, uint key, int val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStorage_GetBool", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiStorageGetBool(__IntPtr self, uint key, bool default_val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStorage_SetBool", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStorageSetBool(__IntPtr self, uint key, bool val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStorage_GetFloat", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImGuiStorageGetFloat(__IntPtr self, uint key, float default_val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStorage_SetFloat", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStorageSetFloat(__IntPtr self, uint key, float val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStorage_GetVoidPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiStorageGetVoidPtr(__IntPtr self, uint key);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStorage_SetVoidPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStorageSetVoidPtr(__IntPtr self, uint key, __IntPtr val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStorage_GetIntRef", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int* ImGuiStorageGetIntRef(__IntPtr self, uint key, int default_val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStorage_GetBoolRef", CallingConvention = __CallingConvention.Cdecl)]
            public static extern bool* ImGuiStorageGetBoolRef(__IntPtr self, uint key, bool default_val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStorage_GetFloatRef", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float* ImGuiStorageGetFloatRef(__IntPtr self, uint key, float default_val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStorage_GetVoidPtrRef", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr* ImGuiStorageGetVoidPtrRef(__IntPtr self, uint key, __IntPtr default_val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStorage_SetAllInt", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStorageSetAllInt(__IntPtr self, int val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStorage_BuildSortByKey", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStorageBuildSortByKey(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiListClipper_ImGuiListClipper", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiListClipperImGuiListClipper();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiListClipper_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiListClipper_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiListClipper_Begin", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiListClipperBegin(__IntPtr self, int items_count, float items_height);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiListClipper_End", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiListClipperEnd(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiListClipper_Step", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiListClipperStep(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiListClipper_ForceDisplayRangeByIndices", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiListClipperForceDisplayRangeByIndices(__IntPtr self, int item_min, int item_max);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImColor_ImColor_Nil", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImColorImColorNil();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImColor_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImColor_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImColor_ImColor_Int", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImColorImColorInt(int r, int g, int b, int a);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImColor_ImColor_U32", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImColorImColorU32(uint rgba);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImColor_ImColor_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImColorImColorFloat(float r, float g, float b, float a);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImColor_ImColor_Vec4", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImColorImColorVec4(global::ImGuiSharp.ImVec4.__Internal col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImColor_SetHSV", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImColorSetHSV(__IntPtr self, float h, float s, float v, float a);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImColor_HSV", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImColorHSV(__IntPtr pOut, float h, float s, float v, float a);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawCmd_ImDrawCmd", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImDrawCmdImDrawCmd();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawCmd_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawCmd_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawCmd_GetTexID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImDrawCmdGetTexID(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawListSplitter_ImDrawListSplitter", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImDrawListSplitterImDrawListSplitter();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawListSplitter_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListSplitter_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawListSplitter_Clear", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListSplitterClear(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawListSplitter_ClearFreeMemory", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListSplitterClearFreeMemory(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawListSplitter_Split", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListSplitterSplit(__IntPtr self, __IntPtr draw_list, int count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawListSplitter_Merge", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListSplitterMerge(__IntPtr self, __IntPtr draw_list);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawListSplitter_SetCurrentChannel", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListSplitterSetCurrentChannel(__IntPtr self, __IntPtr draw_list, int channel_idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_ImDrawList", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImDrawListImDrawList(__IntPtr shared_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawList_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PushClipRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPushClipRect(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal clip_rect_min, global::ImGuiSharp.ImVec2.__Internal clip_rect_max, bool intersect_with_current_clip_rect);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PushClipRectFullScreen", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPushClipRectFullScreen(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PopClipRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPopClipRect(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PushTextureID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPushTextureID(__IntPtr self, __IntPtr texture_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PopTextureID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPopTextureID(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_GetClipRectMin", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListGetClipRectMin(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_GetClipRectMax", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListGetClipRectMax(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddLine", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddLine(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal p1, global::ImGuiSharp.ImVec2.__Internal p2, uint col, float thickness);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddRect(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal p_min, global::ImGuiSharp.ImVec2.__Internal p_max, uint col, float rounding, int flags, float thickness);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddRectFilled", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddRectFilled(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal p_min, global::ImGuiSharp.ImVec2.__Internal p_max, uint col, float rounding, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddRectFilledMultiColor", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddRectFilledMultiColor(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal p_min, global::ImGuiSharp.ImVec2.__Internal p_max, uint col_upr_left, uint col_upr_right, uint col_bot_right, uint col_bot_left);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddQuad", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddQuad(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal p1, global::ImGuiSharp.ImVec2.__Internal p2, global::ImGuiSharp.ImVec2.__Internal p3, global::ImGuiSharp.ImVec2.__Internal p4, uint col, float thickness);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddQuadFilled", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddQuadFilled(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal p1, global::ImGuiSharp.ImVec2.__Internal p2, global::ImGuiSharp.ImVec2.__Internal p3, global::ImGuiSharp.ImVec2.__Internal p4, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddTriangle", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddTriangle(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal p1, global::ImGuiSharp.ImVec2.__Internal p2, global::ImGuiSharp.ImVec2.__Internal p3, uint col, float thickness);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddTriangleFilled", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddTriangleFilled(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal p1, global::ImGuiSharp.ImVec2.__Internal p2, global::ImGuiSharp.ImVec2.__Internal p3, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddCircle", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddCircle(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal center, float radius, uint col, int num_segments, float thickness);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddCircleFilled", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddCircleFilled(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal center, float radius, uint col, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddNgon", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddNgon(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal center, float radius, uint col, int num_segments, float thickness);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddNgonFilled", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddNgonFilled(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal center, float radius, uint col, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddText_Vec2", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddTextVec2(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal pos, uint col, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_begin, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddText_FontPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddTextFontPtr(__IntPtr self, __IntPtr font, float font_size, global::ImGuiSharp.ImVec2.__Internal pos, uint col, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_begin, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end, float wrap_width, __IntPtr cpu_fine_clip_rect);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddPolyline", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddPolyline(__IntPtr self, __IntPtr points, int num_points, uint col, int flags, float thickness);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddConvexPolyFilled", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddConvexPolyFilled(__IntPtr self, __IntPtr points, int num_points, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddBezierCubic", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddBezierCubic(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal p1, global::ImGuiSharp.ImVec2.__Internal p2, global::ImGuiSharp.ImVec2.__Internal p3, global::ImGuiSharp.ImVec2.__Internal p4, uint col, float thickness, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddBezierQuadratic", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddBezierQuadratic(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal p1, global::ImGuiSharp.ImVec2.__Internal p2, global::ImGuiSharp.ImVec2.__Internal p3, uint col, float thickness, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddImage", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddImage(__IntPtr self, __IntPtr user_texture_id, global::ImGuiSharp.ImVec2.__Internal p_min, global::ImGuiSharp.ImVec2.__Internal p_max, global::ImGuiSharp.ImVec2.__Internal uv_min, global::ImGuiSharp.ImVec2.__Internal uv_max, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddImageQuad", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddImageQuad(__IntPtr self, __IntPtr user_texture_id, global::ImGuiSharp.ImVec2.__Internal p1, global::ImGuiSharp.ImVec2.__Internal p2, global::ImGuiSharp.ImVec2.__Internal p3, global::ImGuiSharp.ImVec2.__Internal p4, global::ImGuiSharp.ImVec2.__Internal uv1, global::ImGuiSharp.ImVec2.__Internal uv2, global::ImGuiSharp.ImVec2.__Internal uv3, global::ImGuiSharp.ImVec2.__Internal uv4, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddImageRounded", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddImageRounded(__IntPtr self, __IntPtr user_texture_id, global::ImGuiSharp.ImVec2.__Internal p_min, global::ImGuiSharp.ImVec2.__Internal p_max, global::ImGuiSharp.ImVec2.__Internal uv_min, global::ImGuiSharp.ImVec2.__Internal uv_max, uint col, float rounding, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PathClear", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathClear(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PathLineTo", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathLineTo(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal pos);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PathLineToMergeDuplicate", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathLineToMergeDuplicate(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal pos);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PathFillConvex", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathFillConvex(__IntPtr self, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PathStroke", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathStroke(__IntPtr self, uint col, int flags, float thickness);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PathArcTo", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathArcTo(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal center, float radius, float a_min, float a_max, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PathArcToFast", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathArcToFast(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal center, float radius, int a_min_of_12, int a_max_of_12);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PathBezierCubicCurveTo", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathBezierCubicCurveTo(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal p2, global::ImGuiSharp.ImVec2.__Internal p3, global::ImGuiSharp.ImVec2.__Internal p4, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PathBezierQuadraticCurveTo", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathBezierQuadraticCurveTo(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal p2, global::ImGuiSharp.ImVec2.__Internal p3, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PathRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathRect(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal rect_min, global::ImGuiSharp.ImVec2.__Internal rect_max, float rounding, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddCallback", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddCallback(__IntPtr self, __IntPtr callback, __IntPtr callback_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddDrawCmd", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddDrawCmd(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_CloneOutput", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImDrawListCloneOutput(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_ChannelsSplit", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListChannelsSplit(__IntPtr self, int count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_ChannelsMerge", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListChannelsMerge(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_ChannelsSetCurrent", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListChannelsSetCurrent(__IntPtr self, int n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PrimReserve", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPrimReserve(__IntPtr self, int idx_count, int vtx_count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PrimUnreserve", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPrimUnreserve(__IntPtr self, int idx_count, int vtx_count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PrimRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPrimRect(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal a, global::ImGuiSharp.ImVec2.__Internal b, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PrimRectUV", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPrimRectUV(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal a, global::ImGuiSharp.ImVec2.__Internal b, global::ImGuiSharp.ImVec2.__Internal uv_a, global::ImGuiSharp.ImVec2.__Internal uv_b, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PrimQuadUV", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPrimQuadUV(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal a, global::ImGuiSharp.ImVec2.__Internal b, global::ImGuiSharp.ImVec2.__Internal c, global::ImGuiSharp.ImVec2.__Internal d, global::ImGuiSharp.ImVec2.__Internal uv_a, global::ImGuiSharp.ImVec2.__Internal uv_b, global::ImGuiSharp.ImVec2.__Internal uv_c, global::ImGuiSharp.ImVec2.__Internal uv_d, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PrimWriteVtx", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPrimWriteVtx(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal pos, global::ImGuiSharp.ImVec2.__Internal uv, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PrimWriteIdx", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPrimWriteIdx(__IntPtr self, ushort idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PrimVtx", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPrimVtx(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal pos, global::ImGuiSharp.ImVec2.__Internal uv, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList__ResetForNewFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListResetForNewFrame(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList__ClearFreeMemory", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListClearFreeMemory(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList__PopUnusedDrawCmd", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPopUnusedDrawCmd(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList__TryMergeDrawCmds", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListTryMergeDrawCmds(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList__OnChangedClipRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListOnChangedClipRect(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList__OnChangedTextureID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListOnChangedTextureID(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList__OnChangedVtxOffset", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListOnChangedVtxOffset(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList__CalcCircleAutoSegmentCount", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImDrawListCalcCircleAutoSegmentCount(__IntPtr self, float radius);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList__PathArcToFastEx", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathArcToFastEx(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal center, float radius, int a_min_sample, int a_max_sample, int a_step);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList__PathArcToN", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathArcToN(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal center, float radius, float a_min, float a_max, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawData_ImDrawData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImDrawDataImDrawData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawData_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawData_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawData_Clear", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawDataClear(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawData_DeIndexAllBuffers", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawDataDeIndexAllBuffers(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawData_ScaleClipRects", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawDataScaleClipRects(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal fb_scale);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontConfig_ImFontConfig", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontConfigImFontConfig();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontConfig_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontConfig_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontGlyphRangesBuilder_ImFontGlyphRangesBuilder", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontGlyphRangesBuilderImFontGlyphRangesBuilder();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontGlyphRangesBuilder_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontGlyphRangesBuilder_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontGlyphRangesBuilder_Clear", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontGlyphRangesBuilderClear(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontGlyphRangesBuilder_GetBit", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImFontGlyphRangesBuilderGetBit(__IntPtr self, IntPtr n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontGlyphRangesBuilder_SetBit", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontGlyphRangesBuilderSetBit(__IntPtr self, IntPtr n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontGlyphRangesBuilder_AddChar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontGlyphRangesBuilderAddChar(__IntPtr self, ushort c);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontGlyphRangesBuilder_AddText", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontGlyphRangesBuilderAddText(__IntPtr self, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontGlyphRangesBuilder_AddRanges", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontGlyphRangesBuilderAddRanges(__IntPtr self, ushort* ranges);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontGlyphRangesBuilder_BuildRanges", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontGlyphRangesBuilderBuildRanges(__IntPtr self, __IntPtr out_ranges);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlasCustomRect_ImFontAtlasCustomRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontAtlasCustomRectImFontAtlasCustomRect();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlasCustomRect_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasCustomRect_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlasCustomRect_IsPacked", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImFontAtlasCustomRectIsPacked(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_ImFontAtlas", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontAtlasImFontAtlas();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlas_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_AddFont", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontAtlasAddFont(__IntPtr self, __IntPtr font_cfg);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_AddFontDefault", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontAtlasAddFontDefault(__IntPtr self, __IntPtr font_cfg);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_AddFontFromFileTTF", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontAtlasAddFontFromFileTTF(__IntPtr self, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string filename, float size_pixels, __IntPtr font_cfg, ushort* glyph_ranges);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_AddFontFromMemoryTTF", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontAtlasAddFontFromMemoryTTF(__IntPtr self, __IntPtr font_data, int font_size, float size_pixels, __IntPtr font_cfg, ushort* glyph_ranges);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_AddFontFromMemoryCompressedTTF", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontAtlasAddFontFromMemoryCompressedTTF(__IntPtr self, __IntPtr compressed_font_data, int compressed_font_size, float size_pixels, __IntPtr font_cfg, ushort* glyph_ranges);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_AddFontFromMemoryCompressedBase85TTF", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontAtlasAddFontFromMemoryCompressedBase85TTF(__IntPtr self, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string compressed_font_data_base85, float size_pixels, __IntPtr font_cfg, ushort* glyph_ranges);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_ClearInputData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasClearInputData(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_ClearTexData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasClearTexData(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_ClearFonts", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasClearFonts(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_Clear", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasClear(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_Build", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImFontAtlasBuild(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_GetTexDataAsAlpha8", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasGetTexDataAsAlpha8(__IntPtr self, byte** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_GetTexDataAsRGBA32", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasGetTexDataAsRGBA32(__IntPtr self, byte** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_IsBuilt", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImFontAtlasIsBuilt(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_SetTexID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasSetTexID(__IntPtr self, __IntPtr id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_GetGlyphRangesDefault", CallingConvention = __CallingConvention.Cdecl)]
            public static extern ushort* ImFontAtlasGetGlyphRangesDefault(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_GetGlyphRangesKorean", CallingConvention = __CallingConvention.Cdecl)]
            public static extern ushort* ImFontAtlasGetGlyphRangesKorean(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_GetGlyphRangesJapanese", CallingConvention = __CallingConvention.Cdecl)]
            public static extern ushort* ImFontAtlasGetGlyphRangesJapanese(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_GetGlyphRangesChineseFull", CallingConvention = __CallingConvention.Cdecl)]
            public static extern ushort* ImFontAtlasGetGlyphRangesChineseFull(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_GetGlyphRangesChineseSimplifiedCommon", CallingConvention = __CallingConvention.Cdecl)]
            public static extern ushort* ImFontAtlasGetGlyphRangesChineseSimplifiedCommon(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_GetGlyphRangesCyrillic", CallingConvention = __CallingConvention.Cdecl)]
            public static extern ushort* ImFontAtlasGetGlyphRangesCyrillic(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_GetGlyphRangesThai", CallingConvention = __CallingConvention.Cdecl)]
            public static extern ushort* ImFontAtlasGetGlyphRangesThai(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_GetGlyphRangesVietnamese", CallingConvention = __CallingConvention.Cdecl)]
            public static extern ushort* ImFontAtlasGetGlyphRangesVietnamese(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_AddCustomRectRegular", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImFontAtlasAddCustomRectRegular(__IntPtr self, int width, int height);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_AddCustomRectFontGlyph", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImFontAtlasAddCustomRectFontGlyph(__IntPtr self, __IntPtr font, ushort id, int width, int height, float advance_x, global::ImGuiSharp.ImVec2.__Internal offset);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_GetCustomRectByIndex", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontAtlasGetCustomRectByIndex(__IntPtr self, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_CalcCustomRectUV", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasCalcCustomRectUV(__IntPtr self, __IntPtr rect, __IntPtr out_uv_min, __IntPtr out_uv_max);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_GetMouseCursorTexData", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImFontAtlasGetMouseCursorTexData(__IntPtr self, int cursor, __IntPtr out_offset, __IntPtr out_size, global::ImGuiSharp.ImVec2.__Internal[] out_uv_border, global::ImGuiSharp.ImVec2.__Internal[] out_uv_fill);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_ImFont", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontImFont();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFont_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_FindGlyph", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontFindGlyph(__IntPtr self, ushort c);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_FindGlyphNoFallback", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontFindGlyphNoFallback(__IntPtr self, ushort c);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_GetCharAdvance", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImFontGetCharAdvance(__IntPtr self, ushort c);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_IsLoaded", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImFontIsLoaded(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_GetDebugName", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontGetDebugName(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_CalcTextSizeA", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontCalcTextSizeA(__IntPtr pOut, __IntPtr self, float size, float max_width, float wrap_width, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_begin, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end, sbyte** remaining);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_CalcWordWrapPositionA", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontCalcWordWrapPositionA(__IntPtr self, float scale, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end, float wrap_width);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_RenderChar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontRenderChar(__IntPtr self, __IntPtr draw_list, float size, global::ImGuiSharp.ImVec2.__Internal pos, uint col, ushort c);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_RenderText", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontRenderText(__IntPtr self, __IntPtr draw_list, float size, global::ImGuiSharp.ImVec2.__Internal pos, uint col, global::ImGuiSharp.ImVec4.__Internal clip_rect, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_begin, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end, float wrap_width, bool cpu_fine_clip);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_BuildLookupTable", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontBuildLookupTable(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_ClearOutputData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontClearOutputData(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_GrowIndex", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontGrowIndex(__IntPtr self, int new_size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_AddGlyph", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAddGlyph(__IntPtr self, __IntPtr src_cfg, ushort c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_AddRemapChar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAddRemapChar(__IntPtr self, ushort dst, ushort src, bool overwrite_dst);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_SetGlyphVisible", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontSetGlyphVisible(__IntPtr self, ushort c, bool visible);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_IsGlyphRangeUnused", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImFontIsGlyphRangeUnused(__IntPtr self, uint c_begin, uint c_last);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiViewport_ImGuiViewport", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiViewportImGuiViewport();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiViewport_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiViewport_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiViewport_GetCenter", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiViewportGetCenter(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiViewport_GetWorkCenter", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiViewportGetWorkCenter(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiPlatformImeData_ImGuiPlatformImeData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiPlatformImeDataImGuiPlatformImeData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiPlatformImeData_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiPlatformImeData_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetKeyIndex", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int GetKeyIndex(int key);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImHashData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint ImHashData(__IntPtr data, IntPtr data_size, uint seed);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImHashStr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint ImHashStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string data, IntPtr data_size, uint seed);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImQsort", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImQsort(__IntPtr @base, IntPtr count, IntPtr size_of_element, __IntPtr compare_func);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImAlphaBlendColors", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint ImAlphaBlendColors(uint col_a, uint col_b);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImIsPowerOfTwo_Int", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImIsPowerOfTwoInt(int v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImIsPowerOfTwo_U64", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImIsPowerOfTwoU64(ulong v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImUpperPowerOfTwo", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImUpperPowerOfTwo(int v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImStricmp", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImStricmp([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str2);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImStrnicmp", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImStrnicmp([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str2, IntPtr count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImStrncpy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImStrncpy(sbyte* dst, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string src, IntPtr count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImStrdup", CallingConvention = __CallingConvention.Cdecl)]
            public static extern sbyte* ImStrdup([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImStrdupcpy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern sbyte* ImStrdupcpy(sbyte* dst, IntPtr* p_dst_size, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImStrchrRange", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImStrchrRange([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_begin, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_end, sbyte c);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImStrlenW", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImStrlenW(ushort* str);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImStreolRange", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImStreolRange([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImStrbolW", CallingConvention = __CallingConvention.Cdecl)]
            public static extern ushort* ImStrbolW(ushort* buf_mid_line, ushort* buf_begin);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImStristr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImStristr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string haystack, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string haystack_end, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string needle, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string needle_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImStrTrimBlanks", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImStrTrimBlanks(sbyte* str);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImStrSkipBlank", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImStrSkipBlank([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFormatString", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImFormatString(sbyte* buf, IntPtr buf_size, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImParseFormatFindStart", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImParseFormatFindStart([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImParseFormatFindEnd", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImParseFormatFindEnd([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImParseFormatTrimDecorations", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImParseFormatTrimDecorations([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, sbyte* buf, IntPtr buf_size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImParseFormatPrecision", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImParseFormatPrecision([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int default_value);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImCharIsBlankA", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImCharIsBlankA(sbyte c);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImCharIsBlankW", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImCharIsBlankW(uint c);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImTextCharToUtf8", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImTextCharToUtf8(sbyte[] out_buf, uint c);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImTextStrToUtf8", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImTextStrToUtf8(sbyte* out_buf, int out_buf_size, ushort* in_text, ushort* in_text_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImTextCharFromUtf8", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImTextCharFromUtf8(uint* out_char, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string in_text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string in_text_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImTextStrFromUtf8", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImTextStrFromUtf8(ushort* out_buf, int out_buf_size, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string in_text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string in_text_end, sbyte** in_remaining);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImTextCountCharsFromUtf8", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImTextCountCharsFromUtf8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string in_text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string in_text_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImTextCountUtf8BytesFromChar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImTextCountUtf8BytesFromChar([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string in_text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string in_text_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImTextCountUtf8BytesFromStr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImTextCountUtf8BytesFromStr(ushort* in_text, ushort* in_text_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFileOpen", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFileOpen([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string filename, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string mode);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFileClose", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImFileClose(__IntPtr file);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFileGetSize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern ulong ImFileGetSize(__IntPtr file);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFileRead", CallingConvention = __CallingConvention.Cdecl)]
            public static extern ulong ImFileRead(__IntPtr data, ulong size, ulong count, __IntPtr file);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFileWrite", CallingConvention = __CallingConvention.Cdecl)]
            public static extern ulong ImFileWrite(__IntPtr data, ulong size, ulong count, __IntPtr file);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFileLoadToMemory", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFileLoadToMemory([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string filename, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string mode, IntPtr* out_file_size, int padding_bytes);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImPow_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImPowFloat(float x, float y);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImPow_double", CallingConvention = __CallingConvention.Cdecl)]
            public static extern double ImPow_double(double x, double y);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImLog_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImLogFloat(float x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImLog_double", CallingConvention = __CallingConvention.Cdecl)]
            public static extern double ImLog_double(double x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImAbs_Int", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImAbsInt(int x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImAbs_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImAbsFloat(float x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImAbs_double", CallingConvention = __CallingConvention.Cdecl)]
            public static extern double ImAbs_double(double x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImSign_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImSignFloat(float x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImSign_double", CallingConvention = __CallingConvention.Cdecl)]
            public static extern double ImSign_double(double x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImRsqrt_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImRsqrtFloat(float x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImRsqrt_double", CallingConvention = __CallingConvention.Cdecl)]
            public static extern double ImRsqrt_double(double x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImMin", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImMin(__IntPtr pOut, global::ImGuiSharp.ImVec2.__Internal lhs, global::ImGuiSharp.ImVec2.__Internal rhs);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImMax", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImMax(__IntPtr pOut, global::ImGuiSharp.ImVec2.__Internal lhs, global::ImGuiSharp.ImVec2.__Internal rhs);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImClamp", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImClamp(__IntPtr pOut, global::ImGuiSharp.ImVec2.__Internal v, global::ImGuiSharp.ImVec2.__Internal mn, global::ImGuiSharp.ImVec2.__Internal mx);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImLerp_Vec2Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImLerpVec2Float(__IntPtr pOut, global::ImGuiSharp.ImVec2.__Internal a, global::ImGuiSharp.ImVec2.__Internal b, float t);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImLerp_Vec2Vec2", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImLerpVec2Vec2(__IntPtr pOut, global::ImGuiSharp.ImVec2.__Internal a, global::ImGuiSharp.ImVec2.__Internal b, global::ImGuiSharp.ImVec2.__Internal t);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImLerp_Vec4", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImLerpVec4(__IntPtr pOut, global::ImGuiSharp.ImVec4.__Internal a, global::ImGuiSharp.ImVec4.__Internal b, float t);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImSaturate", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImSaturate(float f);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImLengthSqr_Vec2", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImLengthSqrVec2(global::ImGuiSharp.ImVec2.__Internal lhs);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImLengthSqr_Vec4", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImLengthSqrVec4(global::ImGuiSharp.ImVec4.__Internal lhs);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImInvLength", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImInvLength(global::ImGuiSharp.ImVec2.__Internal lhs, float fail_value);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFloor_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImFloorFloat(float f);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFloorSigned_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImFloorSignedFloat(float f);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFloor_Vec2", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFloorVec2(__IntPtr pOut, global::ImGuiSharp.ImVec2.__Internal v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFloorSigned_Vec2", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFloorSignedVec2(__IntPtr pOut, global::ImGuiSharp.ImVec2.__Internal v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImModPositive", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImModPositive(int a, int b);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImDot", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImDot(global::ImGuiSharp.ImVec2.__Internal a, global::ImGuiSharp.ImVec2.__Internal b);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImRotate", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRotate(__IntPtr pOut, global::ImGuiSharp.ImVec2.__Internal v, float cos_a, float sin_a);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImLinearSweep", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImLinearSweep(float current, float target, float speed);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImMul", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImMul(__IntPtr pOut, global::ImGuiSharp.ImVec2.__Internal lhs, global::ImGuiSharp.ImVec2.__Internal rhs);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImIsFloatAboveGuaranteedIntegerPrecision", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImIsFloatAboveGuaranteedIntegerPrecision(float f);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImBezierCubicCalc", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImBezierCubicCalc(__IntPtr pOut, global::ImGuiSharp.ImVec2.__Internal p1, global::ImGuiSharp.ImVec2.__Internal p2, global::ImGuiSharp.ImVec2.__Internal p3, global::ImGuiSharp.ImVec2.__Internal p4, float t);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImBezierCubicClosestPoint", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImBezierCubicClosestPoint(__IntPtr pOut, global::ImGuiSharp.ImVec2.__Internal p1, global::ImGuiSharp.ImVec2.__Internal p2, global::ImGuiSharp.ImVec2.__Internal p3, global::ImGuiSharp.ImVec2.__Internal p4, global::ImGuiSharp.ImVec2.__Internal p, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImBezierCubicClosestPointCasteljau", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImBezierCubicClosestPointCasteljau(__IntPtr pOut, global::ImGuiSharp.ImVec2.__Internal p1, global::ImGuiSharp.ImVec2.__Internal p2, global::ImGuiSharp.ImVec2.__Internal p3, global::ImGuiSharp.ImVec2.__Internal p4, global::ImGuiSharp.ImVec2.__Internal p, float tess_tol);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImBezierQuadraticCalc", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImBezierQuadraticCalc(__IntPtr pOut, global::ImGuiSharp.ImVec2.__Internal p1, global::ImGuiSharp.ImVec2.__Internal p2, global::ImGuiSharp.ImVec2.__Internal p3, float t);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImLineClosestPoint", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImLineClosestPoint(__IntPtr pOut, global::ImGuiSharp.ImVec2.__Internal a, global::ImGuiSharp.ImVec2.__Internal b, global::ImGuiSharp.ImVec2.__Internal p);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImTriangleContainsPoint", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImTriangleContainsPoint(global::ImGuiSharp.ImVec2.__Internal a, global::ImGuiSharp.ImVec2.__Internal b, global::ImGuiSharp.ImVec2.__Internal c, global::ImGuiSharp.ImVec2.__Internal p);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImTriangleClosestPoint", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImTriangleClosestPoint(__IntPtr pOut, global::ImGuiSharp.ImVec2.__Internal a, global::ImGuiSharp.ImVec2.__Internal b, global::ImGuiSharp.ImVec2.__Internal c, global::ImGuiSharp.ImVec2.__Internal p);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImTriangleBarycentricCoords", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImTriangleBarycentricCoords(global::ImGuiSharp.ImVec2.__Internal a, global::ImGuiSharp.ImVec2.__Internal b, global::ImGuiSharp.ImVec2.__Internal c, global::ImGuiSharp.ImVec2.__Internal p, float* out_u, float* out_v, float* out_w);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImTriangleArea", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImTriangleArea(global::ImGuiSharp.ImVec2.__Internal a, global::ImGuiSharp.ImVec2.__Internal b, global::ImGuiSharp.ImVec2.__Internal c);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImGetDirQuadrantFromDelta", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImGetDirQuadrantFromDelta(float dx, float dy);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVec1_ImVec1_Nil", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImVec1ImVec1Nil();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVec1_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImVec1_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVec1_ImVec1_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImVec1ImVec1Float(float _x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVec2ih_ImVec2ih_Nil", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImVec2ihImVec2ihNil();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVec2ih_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImVec2ih_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVec2ih_ImVec2ih_short", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImVec2ihImVec2ih_short(short _x, short _y);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_ImRect_Nil", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImRectImRectNil();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRect_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_ImRect_Vec2", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImRectImRectVec2(global::ImGuiSharp.ImVec2.__Internal min, global::ImGuiSharp.ImVec2.__Internal max);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_ImRect_Vec4", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImRectImRectVec4(global::ImGuiSharp.ImVec4.__Internal v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_ImRect_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImRectImRectFloat(float x1, float y1, float x2, float y2);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_GetCenter", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectGetCenter(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_GetSize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectGetSize(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_GetWidth", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImRectGetWidth(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_GetHeight", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImRectGetHeight(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_GetArea", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImRectGetArea(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_GetTL", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectGetTL(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_GetTR", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectGetTR(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_GetBL", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectGetBL(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_GetBR", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectGetBR(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_Contains_Vec2", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImRectContainsVec2(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal p);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_Contains_Rect", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImRectContainsRect(__IntPtr self, __IntPtr r);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_Overlaps", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImRectOverlaps(__IntPtr self, __IntPtr r);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_Add_Vec2", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectAddVec2(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal p);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_Add_Rect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectAddRect(__IntPtr self, __IntPtr r);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_Expand_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectExpandFloat(__IntPtr self, float amount);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_Expand_Vec2", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectExpandVec2(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal amount);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_Translate", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectTranslate(__IntPtr self, global::ImGuiSharp.ImVec2.__Internal d);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_TranslateX", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectTranslateX(__IntPtr self, float dx);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_TranslateY", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectTranslateY(__IntPtr self, float dy);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_ClipWith", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectClipWith(__IntPtr self, __IntPtr r);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_ClipWithFull", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectClipWithFull(__IntPtr self, __IntPtr r);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_Floor", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectFloor(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_IsInverted", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImRectIsInverted(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_ToVec4", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectToVec4(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImBitArrayTestBit", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImBitArrayTestBit(uint* arr, int n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImBitArrayClearBit", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImBitArrayClearBit(uint* arr, int n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImBitArraySetBit", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImBitArraySetBit(uint* arr, int n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImBitArraySetBitRange", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImBitArraySetBitRange(uint* arr, int n, int n2);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImBitVector_Create", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImBitVectorCreate(__IntPtr self, int sz);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImBitVector_Clear", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImBitVectorClear(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImBitVector_TestBit", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImBitVectorTestBit(__IntPtr self, int n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImBitVector_SetBit", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImBitVectorSetBit(__IntPtr self, int n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImBitVector_ClearBit", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImBitVectorClearBit(__IntPtr self, int n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawListSharedData_ImDrawListSharedData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImDrawListSharedDataImDrawListSharedData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawListSharedData_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListSharedData_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawListSharedData_SetCircleTessellationMaxError", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListSharedDataSetCircleTessellationMaxError(__IntPtr self, float max_error);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawDataBuilder_Clear", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawDataBuilderClear(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawDataBuilder_ClearFreeMemory", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawDataBuilderClearFreeMemory(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawDataBuilder_GetDrawListCount", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImDrawDataBuilderGetDrawListCount(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawDataBuilder_FlattenIntoSingleLayer", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawDataBuilderFlattenIntoSingleLayer(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStyleMod_ImGuiStyleMod_Int", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiStyleModImGuiStyleModInt(int idx, int v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStyleMod_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStyleMod_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStyleMod_ImGuiStyleMod_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiStyleModImGuiStyleModFloat(int idx, float v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStyleMod_ImGuiStyleMod_Vec2", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiStyleModImGuiStyleModVec2(int idx, global::ImGuiSharp.ImVec2.__Internal v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiComboPreviewData_ImGuiComboPreviewData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiComboPreviewDataImGuiComboPreviewData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiComboPreviewData_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiComboPreviewData_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiMenuColumns_ImGuiMenuColumns", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiMenuColumnsImGuiMenuColumns();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiMenuColumns_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiMenuColumns_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiMenuColumns_Update", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiMenuColumnsUpdate(__IntPtr self, float spacing, bool window_reappearing);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiMenuColumns_DeclColumns", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImGuiMenuColumnsDeclColumns(__IntPtr self, float w_icon, float w_label, float w_shortcut, float w_mark);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiMenuColumns_CalcNextTotalWidth", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiMenuColumnsCalcNextTotalWidth(__IntPtr self, bool update_offsets);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextState_ImGuiInputTextState", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiInputTextStateImGuiInputTextState();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextState_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiInputTextState_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextState_ClearText", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiInputTextStateClearText(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextState_ClearFreeMemory", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiInputTextStateClearFreeMemory(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextState_GetUndoAvailCount", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImGuiInputTextStateGetUndoAvailCount(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextState_GetRedoAvailCount", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImGuiInputTextStateGetRedoAvailCount(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextState_OnKeyPressed", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiInputTextStateOnKeyPressed(__IntPtr self, int key);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextState_CursorAnimReset", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiInputTextStateCursorAnimReset(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextState_CursorClamp", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiInputTextStateCursorClamp(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextState_HasSelection", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiInputTextStateHasSelection(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextState_ClearSelection", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiInputTextStateClearSelection(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextState_GetCursorPos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImGuiInputTextStateGetCursorPos(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextState_GetSelectionStart", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImGuiInputTextStateGetSelectionStart(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextState_GetSelectionEnd", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImGuiInputTextStateGetSelectionEnd(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextState_SelectAll", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiInputTextStateSelectAll(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiPopupData_ImGuiPopupData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiPopupDataImGuiPopupData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiPopupData_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiPopupData_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiNextWindowData_ImGuiNextWindowData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiNextWindowDataImGuiNextWindowData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiNextWindowData_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiNextWindowData_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiNextWindowData_ClearFlags", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiNextWindowDataClearFlags(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiNextItemData_ImGuiNextItemData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiNextItemDataImGuiNextItemData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiNextItemData_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiNextItemData_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiNextItemData_ClearFlags", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiNextItemDataClearFlags(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiLastItemData_ImGuiLastItemData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiLastItemDataImGuiLastItemData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiLastItemData_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiLastItemData_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStackSizes_ImGuiStackSizes", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiStackSizesImGuiStackSizes();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStackSizes_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStackSizes_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStackSizes_SetToCurrentState", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStackSizesSetToCurrentState(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStackSizes_CompareWithCurrentState", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStackSizesCompareWithCurrentState(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiPtrOrIndex_ImGuiPtrOrIndex_Ptr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiPtrOrIndexImGuiPtrOrIndexPtr(__IntPtr ptr);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiPtrOrIndex_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiPtrOrIndex_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiPtrOrIndex_ImGuiPtrOrIndex_Int", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiPtrOrIndexImGuiPtrOrIndexInt(int index);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputEvent_ImGuiInputEvent", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiInputEventImGuiInputEvent();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputEvent_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiInputEvent_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiListClipperRange_FromIndices", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiListClipperRangeFromIndices(__IntPtr @return, int min, int max);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiListClipperRange_FromPositions", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiListClipperRangeFromPositions(__IntPtr @return, float y1, float y2, int off_min, int off_max);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiListClipperData_ImGuiListClipperData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiListClipperDataImGuiListClipperData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiListClipperData_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiListClipperData_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiListClipperData_Reset", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiListClipperDataReset(__IntPtr self, __IntPtr clipper);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiNavItemData_ImGuiNavItemData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiNavItemDataImGuiNavItemData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiNavItemData_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiNavItemData_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiNavItemData_Clear", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiNavItemDataClear(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiOldColumnData_ImGuiOldColumnData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiOldColumnDataImGuiOldColumnData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiOldColumnData_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiOldColumnData_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiOldColumns_ImGuiOldColumns", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiOldColumnsImGuiOldColumns();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiOldColumns_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiOldColumns_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiViewportP_ImGuiViewportP", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiViewportP_ImGuiViewportP();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiViewportP_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiViewportP_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiViewportP_CalcWorkRectPos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiViewportP_CalcWorkRectPos(__IntPtr pOut, __IntPtr self, global::ImGuiSharp.ImVec2.__Internal off_min);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiViewportP_CalcWorkRectSize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiViewportP_CalcWorkRectSize(__IntPtr pOut, __IntPtr self, global::ImGuiSharp.ImVec2.__Internal off_min, global::ImGuiSharp.ImVec2.__Internal off_max);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiViewportP_UpdateWorkRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiViewportP_UpdateWorkRect(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiViewportP_GetMainRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiViewportP_GetMainRect(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiViewportP_GetWorkRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiViewportP_GetWorkRect(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiViewportP_GetBuildWorkRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiViewportP_GetBuildWorkRect(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindowSettings_ImGuiWindowSettings", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiWindowSettingsImGuiWindowSettings();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindowSettings_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiWindowSettings_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindowSettings_GetName", CallingConvention = __CallingConvention.Cdecl)]
            public static extern sbyte* ImGuiWindowSettingsGetName(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiSettingsHandler_ImGuiSettingsHandler", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiSettingsHandlerImGuiSettingsHandler();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiSettingsHandler_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiSettingsHandler_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiMetricsConfig_ImGuiMetricsConfig", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiMetricsConfigImGuiMetricsConfig();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiMetricsConfig_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiMetricsConfig_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStackLevelInfo_ImGuiStackLevelInfo", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiStackLevelInfoImGuiStackLevelInfo();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStackLevelInfo_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStackLevelInfo_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStackTool_ImGuiStackTool", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiStackToolImGuiStackTool();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStackTool_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStackTool_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiContextHook_ImGuiContextHook", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiContextHookImGuiContextHook();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiContextHook_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiContextHook_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiContext_ImGuiContext", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiContextImGuiContext(__IntPtr shared_font_atlas);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiContext_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiContext_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindow_ImGuiWindow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiWindowImGuiWindow(__IntPtr context, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindow_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiWindow_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindow_GetID_Str", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint ImGuiWindowGetID_Str(__IntPtr self, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindow_GetID_Ptr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint ImGuiWindowGetID_Ptr(__IntPtr self, __IntPtr ptr);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindow_GetID_Int", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint ImGuiWindowGetID_Int(__IntPtr self, int n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindow_GetIDNoKeepAlive_Str", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint ImGuiWindowGetIDNoKeepAliveStr(__IntPtr self, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindow_GetIDNoKeepAlive_Ptr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint ImGuiWindowGetIDNoKeepAlivePtr(__IntPtr self, __IntPtr ptr);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindow_GetIDNoKeepAlive_Int", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint ImGuiWindowGetIDNoKeepAliveInt(__IntPtr self, int n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindow_GetIDFromRectangle", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint ImGuiWindowGetIDFromRectangle(__IntPtr self, __IntPtr r_abs);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindow_Rect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiWindowRect(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindow_CalcFontSize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImGuiWindowCalcFontSize(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindow_TitleBarHeight", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImGuiWindowTitleBarHeight(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindow_TitleBarRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiWindowTitleBarRect(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindow_MenuBarHeight", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImGuiWindowMenuBarHeight(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindow_MenuBarRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiWindowMenuBarRect(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTabItem_ImGuiTabItem", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTabItemImGuiTabItem();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTabItem_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTabItem_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTabBar_ImGuiTabBar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTabBarImGuiTabBar();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTabBar_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTabBar_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTabBar_GetTabOrder", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImGuiTabBarGetTabOrder(__IntPtr self, __IntPtr tab);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTabBar_GetTabName", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTabBarGetTabName(__IntPtr self, __IntPtr tab);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTableColumn_ImGuiTableColumn", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTableColumnImGuiTableColumn();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTableColumn_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTableColumn_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTable_ImGuiTable", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTableImGuiTable();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTable_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTable_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTableTempData_ImGuiTableTempData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTableTempDataImGuiTableTempData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTableTempData_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTableTempData_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTableColumnSettings_ImGuiTableColumnSettings", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTableColumnSettingsImGuiTableColumnSettings();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTableColumnSettings_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTableColumnSettings_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTableSettings_ImGuiTableSettings", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTableSettingsImGuiTableSettings();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTableSettings_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTableSettings_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTableSettings_GetColumnSettings", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTableSettingsGetColumnSettings(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetCurrentWindowRead", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetCurrentWindowRead();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetCurrentWindow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetCurrentWindow();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igFindWindowByID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr FindWindowByID(uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igFindWindowByName", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr FindWindowByName([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igUpdateWindowParentAndRootLinks", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void UpdateWindowParentAndRootLinks(__IntPtr window, int flags, __IntPtr parent_window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCalcWindowNextAutoFitSize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void CalcWindowNextAutoFitSize(__IntPtr pOut, __IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsWindowChildOf", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsWindowChildOf(__IntPtr window, __IntPtr potential_parent, bool popup_hierarchy);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsWindowWithinBeginStackOf", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsWindowWithinBeginStackOf(__IntPtr window, __IntPtr potential_parent);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsWindowAbove", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsWindowAbove(__IntPtr potential_above, __IntPtr potential_below);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsWindowNavFocusable", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsWindowNavFocusable(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetWindowPos_WindowPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowPosWindowPtr(__IntPtr window, global::ImGuiSharp.ImVec2.__Internal pos, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetWindowSize_WindowPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowSizeWindowPtr(__IntPtr window, global::ImGuiSharp.ImVec2.__Internal size, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetWindowCollapsed_WindowPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowCollapsedWindowPtr(__IntPtr window, bool collapsed, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetWindowHitTestHole", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowHitTestHole(__IntPtr window, global::ImGuiSharp.ImVec2.__Internal pos, global::ImGuiSharp.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igWindowRectAbsToRel", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void WindowRectAbsToRel(__IntPtr pOut, __IntPtr window, __IntPtr r);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igWindowRectRelToAbs", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void WindowRectRelToAbs(__IntPtr pOut, __IntPtr window, __IntPtr r);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igFocusWindow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void FocusWindow(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igFocusTopMostWindowUnderOne", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void FocusTopMostWindowUnderOne(__IntPtr under_this_window, __IntPtr ignore_window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBringWindowToFocusFront", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void BringWindowToFocusFront(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBringWindowToDisplayFront", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void BringWindowToDisplayFront(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBringWindowToDisplayBack", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void BringWindowToDisplayBack(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBringWindowToDisplayBehind", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void BringWindowToDisplayBehind(__IntPtr window, __IntPtr above_window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igFindWindowDisplayIndex", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int FindWindowDisplayIndex(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igFindBottomMostVisibleWindowWithinBeginStack", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr FindBottomMostVisibleWindowWithinBeginStack(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetCurrentFont", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetCurrentFont(__IntPtr font);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetDefaultFont", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetDefaultFont();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetForegroundDrawList_WindowPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetForegroundDrawListWindowPtr(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetBackgroundDrawList_ViewportPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetBackgroundDrawListViewportPtr(__IntPtr viewport);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetForegroundDrawList_ViewportPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetForegroundDrawListViewportPtr(__IntPtr viewport);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInitialize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Initialize(__IntPtr context);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igShutdown", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Shutdown(__IntPtr context);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igUpdateInputEvents", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void UpdateInputEvents(bool trickle_fast_inputs);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igUpdateHoveredWindowAndCaptureFlags", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void UpdateHoveredWindowAndCaptureFlags();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igStartMouseMovingWindow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void StartMouseMovingWindow(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igUpdateMouseMovingWindowNewFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void UpdateMouseMovingWindowNewFrame();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igUpdateMouseMovingWindowEndFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void UpdateMouseMovingWindowEndFrame();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igAddContextHook", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint AddContextHook(__IntPtr context, __IntPtr hook);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRemoveContextHook", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RemoveContextHook(__IntPtr context, uint hook_to_remove);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCallContextHooks", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void CallContextHooks(__IntPtr context, global::ImGuiSharp.ImGuiContextHookType type);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igMarkIniSettingsDirty_Nil", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void MarkIniSettingsDirtyNil();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igMarkIniSettingsDirty_WindowPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void MarkIniSettingsDirtyWindowPtr(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igClearIniSettings", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ClearIniSettings();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCreateNewWindowSettings", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr CreateNewWindowSettings([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igFindWindowSettings", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr FindWindowSettings(uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igFindOrCreateWindowSettings", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr FindOrCreateWindowSettings([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igFindSettingsHandler", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr FindSettingsHandler([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string type_name);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetNextWindowScroll", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextWindowScroll(global::ImGuiSharp.ImVec2.__Internal scroll);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetScrollX_WindowPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetScrollX_WindowPtr(__IntPtr window, float scroll_x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetScrollY_WindowPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetScrollY_WindowPtr(__IntPtr window, float scroll_y);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetScrollFromPosX_WindowPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetScrollFromPosX_WindowPtr(__IntPtr window, float local_x, float center_x_ratio);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetScrollFromPosY_WindowPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetScrollFromPosY_WindowPtr(__IntPtr window, float local_y, float center_y_ratio);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igScrollToItem", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ScrollToItem(int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igScrollToRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ScrollToRect(__IntPtr window, __IntPtr rect, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igScrollToRectEx", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ScrollToRectEx(__IntPtr pOut, __IntPtr window, __IntPtr rect, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igScrollToBringRectIntoView", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ScrollToBringRectIntoView(__IntPtr window, __IntPtr rect);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetItemID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetItemID();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetItemStatusFlags", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int GetItemStatusFlags();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetItemFlags", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int GetItemFlags();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetActiveID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetActiveID();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetFocusID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetFocusID();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetActiveID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetActiveID(uint id, __IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetFocusID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetFocusID(uint id, __IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igClearActiveID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ClearActiveID();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetHoveredID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetHoveredID();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetHoveredID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetHoveredID(uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igKeepAliveID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void KeepAliveID(uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igMarkItemEdited", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void MarkItemEdited(uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushOverrideID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushOverrideID(uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetIDWithSeed", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetIDWithSeed([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id_begin, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id_end, uint seed);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igItemSize_Vec2", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ItemSizeVec2(global::ImGuiSharp.ImVec2.__Internal size, float text_baseline_y);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igItemSize_Rect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ItemSizeRect(__IntPtr bb, float text_baseline_y);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igItemAdd", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ItemAdd(__IntPtr bb, uint id, __IntPtr nav_bb, int extra_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igItemHoverable", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ItemHoverable(__IntPtr bb, uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsClippedEx", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsClippedEx(__IntPtr bb, uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetLastItemData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetLastItemData(uint item_id, int in_flags, int status_flags, __IntPtr item_rect);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCalcItemSize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void CalcItemSize(__IntPtr pOut, global::ImGuiSharp.ImVec2.__Internal size, float default_w, float default_h);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCalcWrapWidthForPos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float CalcWrapWidthForPos(global::ImGuiSharp.ImVec2.__Internal pos, float wrap_pos_x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushMultiItemsWidths", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushMultiItemsWidths(int components, float width_full);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsItemToggledSelection", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsItemToggledSelection();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetContentRegionMaxAbs", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetContentRegionMaxAbs(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igShrinkWidths", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ShrinkWidths(__IntPtr items, int count, float width_excess);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushItemFlag", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushItemFlag(int option, bool enabled);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPopItemFlag", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PopItemFlag();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igLogBegin", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LogBegin(global::ImGuiSharp.ImGuiLogType type, int auto_open_depth);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igLogToBuffer", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LogToBuffer(int auto_open_depth);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igLogRenderedText", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LogRenderedText(__IntPtr ref_pos, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igLogSetNextTextDecoration", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LogSetNextTextDecoration([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string prefix, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string suffix);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginChildEx", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginChildEx([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, uint id, global::ImGuiSharp.ImVec2.__Internal size_arg, bool border, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igOpenPopupEx", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void OpenPopupEx(uint id, int popup_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igClosePopupToLevel", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ClosePopupToLevel(int remaining, bool restore_focus_to_window_under_popup);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igClosePopupsOverWindow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ClosePopupsOverWindow(__IntPtr ref_window, bool restore_focus_to_window_under_popup);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igClosePopupsExceptModals", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ClosePopupsExceptModals();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsPopupOpen_ID", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsPopupOpenID(uint id, int popup_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginPopupEx", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginPopupEx(uint id, int extra_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginTooltipEx", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void BeginTooltipEx(int tooltip_flags, int extra_window_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetPopupAllowedExtentRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetPopupAllowedExtentRect(__IntPtr pOut, __IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetTopMostPopupModal", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetTopMostPopupModal();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetTopMostAndVisiblePopupModal", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetTopMostAndVisiblePopupModal();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igFindBestWindowPosForPopup", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void FindBestWindowPosForPopup(__IntPtr pOut, __IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igFindBestWindowPosForPopupEx", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void FindBestWindowPosForPopupEx(__IntPtr pOut, global::ImGuiSharp.ImVec2.__Internal ref_pos, global::ImGuiSharp.ImVec2.__Internal size, int* last_dir, __IntPtr r_outer, __IntPtr r_avoid, global::ImGuiSharp.ImGuiPopupPositionPolicy policy);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginViewportSideBar", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginViewportSideBar([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, __IntPtr viewport, int dir, float size, int window_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginMenuEx", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginMenuEx([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string icon, bool enabled);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igMenuItemEx", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool MenuItemEx([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string icon, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string shortcut, bool selected, bool enabled);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginComboPopup", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginComboPopup(uint popup_id, __IntPtr bb, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginComboPreview", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginComboPreview();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndComboPreview", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndComboPreview();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igNavInitWindow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void NavInitWindow(__IntPtr window, bool force_reinit);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igNavInitRequestApplyResult", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void NavInitRequestApplyResult();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igNavMoveRequestButNoResultYet", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool NavMoveRequestButNoResultYet();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igNavMoveRequestSubmit", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void NavMoveRequestSubmit(int move_dir, int clip_dir, int move_flags, int scroll_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igNavMoveRequestForward", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void NavMoveRequestForward(int move_dir, int clip_dir, int move_flags, int scroll_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igNavMoveRequestResolveWithLastItem", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void NavMoveRequestResolveWithLastItem(__IntPtr result);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igNavMoveRequestCancel", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void NavMoveRequestCancel();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igNavMoveRequestApplyResult", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void NavMoveRequestApplyResult();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igNavMoveRequestTryWrapping", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void NavMoveRequestTryWrapping(__IntPtr window, int move_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetNavInputName", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetNavInputName(int n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetNavInputAmount", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetNavInputAmount(int n, global::ImGuiSharp.ImGuiInputReadMode mode);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetNavInputAmount2d", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetNavInputAmount2d(__IntPtr pOut, int dir_sources, global::ImGuiSharp.ImGuiInputReadMode mode, float slow_factor, float fast_factor);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCalcTypematicRepeatAmount", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int CalcTypematicRepeatAmount(float t0, float t1, float repeat_delay, float repeat_rate);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igActivateItem", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ActivateItem(uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetNavID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNavID(uint id, global::ImGuiSharp.ImGuiNavLayer nav_layer, uint focus_scope_id, __IntPtr rect_rel);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushFocusScope", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushFocusScope(uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPopFocusScope", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PopFocusScope();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetFocusedFocusScope", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetFocusedFocusScope();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetFocusScope", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetFocusScope();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsNamedKey", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsNamedKey(int key);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsLegacyKey", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsLegacyKey(int key);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsGamepadKey", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsGamepadKey(int key);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetKeyData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetKeyData(int key);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetItemUsingMouseWheel", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetItemUsingMouseWheel();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetActiveIdUsingNavAndKeys", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetActiveIdUsingNavAndKeys();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsActiveIdUsingNavDir", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsActiveIdUsingNavDir(int dir);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsActiveIdUsingNavInput", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsActiveIdUsingNavInput(int input);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsActiveIdUsingKey", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsActiveIdUsingKey(int key);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetActiveIdUsingKey", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetActiveIdUsingKey(int key);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsMouseDragPastThreshold", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsMouseDragPastThreshold(int button, float lock_threshold);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsNavInputDown", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsNavInputDown(int n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsNavInputTest", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsNavInputTest(int n, global::ImGuiSharp.ImGuiInputReadMode rm);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetMergedKeyModFlags", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int GetMergedKeyModFlags();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsKeyPressedMap", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsKeyPressedMap(int key, bool repeat);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginDragDropTargetCustom", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginDragDropTargetCustom(__IntPtr bb, uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igClearDragDrop", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ClearDragDrop();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsDragDropPayloadBeingAccepted", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsDragDropPayloadBeingAccepted();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetWindowClipRectBeforeSetChannel", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowClipRectBeforeSetChannel(__IntPtr window, __IntPtr clip_rect);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginColumns", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void BeginColumns([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int count, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndColumns", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndColumns();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushColumnClipRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushColumnClipRect(int column_index);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushColumnsBackground", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushColumnsBackground();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPopColumnsBackground", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PopColumnsBackground();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetColumnsID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetColumnsID([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igFindOrCreateColumns", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr FindOrCreateColumns(__IntPtr window, uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetColumnOffsetFromNorm", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetColumnOffsetFromNorm(__IntPtr columns, float offset_norm);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetColumnNormFromOffset", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetColumnNormFromOffset(__IntPtr columns, float offset);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableOpenContextMenu", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableOpenContextMenu(int column_n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableSetColumnWidth", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableSetColumnWidth(int column_n, float width);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableSetColumnSortDirection", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableSetColumnSortDirection(int column_n, int sort_direction, bool append_to_sort_specs);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGetHoveredColumn", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int TableGetHoveredColumn();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGetHeaderRowHeight", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float TableGetHeaderRowHeight();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTablePushBackgroundChannel", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TablePushBackgroundChannel();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTablePopBackgroundChannel", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TablePopBackgroundChannel();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetCurrentTable", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetCurrentTable();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableFindByID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr TableFindByID(uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginTableEx", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginTableEx([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, uint id, int columns_count, int flags, global::ImGuiSharp.ImVec2.__Internal outer_size, float inner_width);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableBeginInitMemory", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableBeginInitMemory(__IntPtr table, int columns_count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableBeginApplyRequests", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableBeginApplyRequests(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableSetupDrawChannels", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableSetupDrawChannels(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableUpdateLayout", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableUpdateLayout(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableUpdateBorders", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableUpdateBorders(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableUpdateColumnsWeightFromWidth", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableUpdateColumnsWeightFromWidth(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableDrawBorders", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableDrawBorders(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableDrawContextMenu", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableDrawContextMenu(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableMergeDrawChannels", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableMergeDrawChannels(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableSortSpecsSanitize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableSortSpecsSanitize(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableSortSpecsBuild", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableSortSpecsBuild(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGetColumnNextSortDirection", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int TableGetColumnNextSortDirection(__IntPtr column);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableFixColumnSortDirection", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableFixColumnSortDirection(__IntPtr table, __IntPtr column);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGetColumnWidthAuto", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float TableGetColumnWidthAuto(__IntPtr table, __IntPtr column);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableBeginRow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableBeginRow(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableEndRow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableEndRow(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableBeginCell", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableBeginCell(__IntPtr table, int column_n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableEndCell", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableEndCell(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGetCellBgRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableGetCellBgRect(__IntPtr pOut, __IntPtr table, int column_n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGetColumnName_TablePtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr TableGetColumnNameTablePtr(__IntPtr table, int column_n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGetColumnResizeID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint TableGetColumnResizeID(__IntPtr table, int column_n, int instance_no);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGetMaxColumnWidth", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float TableGetMaxColumnWidth(__IntPtr table, int column_n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableSetColumnWidthAutoSingle", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableSetColumnWidthAutoSingle(__IntPtr table, int column_n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableSetColumnWidthAutoAll", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableSetColumnWidthAutoAll(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableRemove", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableRemove(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGcCompactTransientBuffers_TablePtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableGcCompactTransientBuffersTablePtr(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGcCompactTransientBuffers_TableTempDataPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableGcCompactTransientBuffersTableTempDataPtr(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGcCompactSettings", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableGcCompactSettings();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableLoadSettings", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableLoadSettings(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableSaveSettings", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableSaveSettings(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableResetSettings", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableResetSettings(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGetBoundSettings", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr TableGetBoundSettings(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableSettingsInstallHandler", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableSettingsInstallHandler(__IntPtr context);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableSettingsCreate", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr TableSettingsCreate(uint id, int columns_count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableSettingsFindByID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr TableSettingsFindByID(uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginTabBarEx", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginTabBarEx(__IntPtr tab_bar, __IntPtr bb, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTabBarFindTabByID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr TabBarFindTabByID(__IntPtr tab_bar, uint tab_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTabBarRemoveTab", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TabBarRemoveTab(__IntPtr tab_bar, uint tab_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTabBarCloseTab", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TabBarCloseTab(__IntPtr tab_bar, __IntPtr tab);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTabBarQueueReorder", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TabBarQueueReorder(__IntPtr tab_bar, __IntPtr tab, int offset);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTabBarQueueReorderFromMousePos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TabBarQueueReorderFromMousePos(__IntPtr tab_bar, __IntPtr tab, global::ImGuiSharp.ImVec2.__Internal mouse_pos);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTabBarProcessReorder", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TabBarProcessReorder(__IntPtr tab_bar);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTabItemEx", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TabItemEx(__IntPtr tab_bar, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, bool* p_open, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTabItemCalcSize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TabItemCalcSize(__IntPtr pOut, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, bool has_close_button);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTabItemBackground", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TabItemBackground(__IntPtr draw_list, __IntPtr bb, int flags, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTabItemLabelAndCloseButton", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TabItemLabelAndCloseButton(__IntPtr draw_list, __IntPtr bb, int flags, global::ImGuiSharp.ImVec2.__Internal frame_padding, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, uint tab_id, uint close_button_id, bool is_contents_visible, bool* out_just_closed, bool* out_text_clipped);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderText", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderText(global::ImGuiSharp.ImVec2.__Internal pos, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end, bool hide_text_after_hash);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderTextWrapped", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderTextWrapped(global::ImGuiSharp.ImVec2.__Internal pos, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end, float wrap_width);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderTextClipped", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderTextClipped(global::ImGuiSharp.ImVec2.__Internal pos_min, global::ImGuiSharp.ImVec2.__Internal pos_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end, __IntPtr text_size_if_known, global::ImGuiSharp.ImVec2.__Internal align, __IntPtr clip_rect);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderTextClippedEx", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderTextClippedEx(__IntPtr draw_list, global::ImGuiSharp.ImVec2.__Internal pos_min, global::ImGuiSharp.ImVec2.__Internal pos_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end, __IntPtr text_size_if_known, global::ImGuiSharp.ImVec2.__Internal align, __IntPtr clip_rect);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderTextEllipsis", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderTextEllipsis(__IntPtr draw_list, global::ImGuiSharp.ImVec2.__Internal pos_min, global::ImGuiSharp.ImVec2.__Internal pos_max, float clip_max_x, float ellipsis_max_x, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end, __IntPtr text_size_if_known);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderFrame(global::ImGuiSharp.ImVec2.__Internal p_min, global::ImGuiSharp.ImVec2.__Internal p_max, uint fill_col, bool border, float rounding);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderFrameBorder", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderFrameBorder(global::ImGuiSharp.ImVec2.__Internal p_min, global::ImGuiSharp.ImVec2.__Internal p_max, float rounding);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderColorRectWithAlphaCheckerboard", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderColorRectWithAlphaCheckerboard(__IntPtr draw_list, global::ImGuiSharp.ImVec2.__Internal p_min, global::ImGuiSharp.ImVec2.__Internal p_max, uint fill_col, float grid_step, global::ImGuiSharp.ImVec2.__Internal grid_off, float rounding, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderNavHighlight", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderNavHighlight(__IntPtr bb, uint id, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igFindRenderedTextEnd", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr FindRenderedTextEnd([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderArrow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderArrow(__IntPtr draw_list, global::ImGuiSharp.ImVec2.__Internal pos, uint col, int dir, float scale);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderBullet", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderBullet(__IntPtr draw_list, global::ImGuiSharp.ImVec2.__Internal pos, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderCheckMark", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderCheckMark(__IntPtr draw_list, global::ImGuiSharp.ImVec2.__Internal pos, uint col, float sz);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderMouseCursor", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderMouseCursor(__IntPtr draw_list, global::ImGuiSharp.ImVec2.__Internal pos, float scale, int mouse_cursor, uint col_fill, uint col_border, uint col_shadow);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderArrowPointingAt", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderArrowPointingAt(__IntPtr draw_list, global::ImGuiSharp.ImVec2.__Internal pos, global::ImGuiSharp.ImVec2.__Internal half_sz, int direction, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderRectFilledRangeH", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderRectFilledRangeH(__IntPtr draw_list, __IntPtr rect, uint col, float x_start_norm, float x_end_norm, float rounding);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderRectFilledWithHole", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderRectFilledWithHole(__IntPtr draw_list, __IntPtr outer, __IntPtr inner, uint col, float rounding);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTextEx", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TextEx([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igButtonEx", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ButtonEx([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, global::ImGuiSharp.ImVec2.__Internal size_arg, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCloseButton", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool CloseButton(uint id, global::ImGuiSharp.ImVec2.__Internal pos);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCollapseButton", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool CollapseButton(uint id, global::ImGuiSharp.ImVec2.__Internal pos);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igArrowButtonEx", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ArrowButtonEx([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int dir, global::ImGuiSharp.ImVec2.__Internal size_arg, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igScrollbar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Scrollbar(global::ImGuiSharp.ImGuiAxis axis);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igScrollbarEx", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ScrollbarEx(__IntPtr bb, uint id, global::ImGuiSharp.ImGuiAxis axis, long* p_scroll_v, long avail_v, long contents_v, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImageButtonEx", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImageButtonEx(uint id, __IntPtr texture_id, global::ImGuiSharp.ImVec2.__Internal size, global::ImGuiSharp.ImVec2.__Internal uv0, global::ImGuiSharp.ImVec2.__Internal uv1, global::ImGuiSharp.ImVec2.__Internal padding, global::ImGuiSharp.ImVec4.__Internal bg_col, global::ImGuiSharp.ImVec4.__Internal tint_col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetWindowScrollbarRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetWindowScrollbarRect(__IntPtr pOut, __IntPtr window, global::ImGuiSharp.ImGuiAxis axis);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetWindowScrollbarID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetWindowScrollbarID(__IntPtr window, global::ImGuiSharp.ImGuiAxis axis);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetWindowResizeCornerID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetWindowResizeCornerID(__IntPtr window, int n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetWindowResizeBorderID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetWindowResizeBorderID(__IntPtr window, int dir);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSeparatorEx", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SeparatorEx(int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCheckboxFlags_S64Ptr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool CheckboxFlagsS64Ptr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, long* flags, long flags_value);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCheckboxFlags_U64Ptr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool CheckboxFlagsU64Ptr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, ulong* flags, ulong flags_value);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igButtonBehavior", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ButtonBehavior(__IntPtr bb, uint id, bool* out_hovered, bool* out_held, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDragBehavior", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragBehavior(uint id, int data_type, __IntPtr p_v, float v_speed, __IntPtr p_min, __IntPtr p_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSliderBehavior", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderBehavior(__IntPtr bb, uint id, int data_type, __IntPtr p_v, __IntPtr p_min, __IntPtr p_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags, __IntPtr out_grab_bb);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSplitterBehavior", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SplitterBehavior(__IntPtr bb, uint id, global::ImGuiSharp.ImGuiAxis axis, float* size1, float* size2, float min_size1, float min_size2, float hover_extend, float hover_visibility_delay);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTreeNodeBehavior", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TreeNodeBehavior(uint id, int flags, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTreeNodeBehaviorIsOpen", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TreeNodeBehaviorIsOpen(uint id, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTreePushOverrideID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TreePushOverrideID(uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDataTypeGetInfo", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr DataTypeGetInfo(int data_type);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDataTypeFormatString", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int DataTypeFormatString(sbyte* buf, int buf_size, int data_type, __IntPtr p_data, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDataTypeApplyOp", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DataTypeApplyOp(int data_type, int op, __IntPtr output, __IntPtr arg_1, __IntPtr arg_2);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDataTypeApplyFromText", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DataTypeApplyFromText([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string buf, int data_type, __IntPtr p_data, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDataTypeCompare", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int DataTypeCompare(int data_type, __IntPtr arg_1, __IntPtr arg_2);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDataTypeClamp", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DataTypeClamp(int data_type, __IntPtr p_data, __IntPtr p_min, __IntPtr p_max);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInputTextEx", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputTextEx([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string hint, sbyte* buf, int buf_size, global::ImGuiSharp.ImVec2.__Internal size_arg, int flags, __IntPtr callback, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTempInputText", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TempInputText(__IntPtr bb, uint id, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, sbyte* buf, int buf_size, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTempInputScalar", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TempInputScalar(__IntPtr bb, uint id, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int data_type, __IntPtr p_data, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, __IntPtr p_clamp_min, __IntPtr p_clamp_max);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTempInputIsActive", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TempInputIsActive(uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetInputTextState", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetInputTextState(uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igColorTooltip", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ColorTooltip([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, float* col, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igColorEditOptionsPopup", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ColorEditOptionsPopup(float* col, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igColorPickerOptionsPopup", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ColorPickerOptionsPopup(float* ref_col, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPlotEx", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int PlotEx(global::ImGuiSharp.ImGuiPlotType plot_type, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, __IntPtr values_getter, __IntPtr data, int values_count, int values_offset, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string overlay_text, float scale_min, float scale_max, global::ImGuiSharp.ImVec2.__Internal frame_size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igShadeVertsLinearColorGradientKeepAlpha", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ShadeVertsLinearColorGradientKeepAlpha(__IntPtr draw_list, int vert_start_idx, int vert_end_idx, global::ImGuiSharp.ImVec2.__Internal gradient_p0, global::ImGuiSharp.ImVec2.__Internal gradient_p1, uint col0, uint col1);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igShadeVertsLinearUV", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ShadeVertsLinearUV(__IntPtr draw_list, int vert_start_idx, int vert_end_idx, global::ImGuiSharp.ImVec2.__Internal a, global::ImGuiSharp.ImVec2.__Internal b, global::ImGuiSharp.ImVec2.__Internal uv_a, global::ImGuiSharp.ImVec2.__Internal uv_b, bool clamp);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGcCompactTransientMiscBuffers", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GcCompactTransientMiscBuffers();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGcCompactTransientWindowBuffers", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GcCompactTransientWindowBuffers(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGcAwakeTransientWindowBuffers", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GcAwakeTransientWindowBuffers(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igErrorCheckEndFrameRecover", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ErrorCheckEndFrameRecover(__IntPtr log_callback, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igErrorCheckEndWindowRecover", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ErrorCheckEndWindowRecover(__IntPtr log_callback, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugDrawItemRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugDrawItemRect(uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugStartItemPicker", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugStartItemPicker();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igShowFontAtlas", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ShowFontAtlas(__IntPtr atlas);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugHookIdInfo", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugHookIdInfo(uint id, int data_type, __IntPtr data_id, __IntPtr data_id_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugNodeColumns", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugNodeColumns(__IntPtr columns);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugNodeDrawList", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugNodeDrawList(__IntPtr window, __IntPtr draw_list, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugNodeDrawCmdShowMeshAndBoundingBox", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugNodeDrawCmdShowMeshAndBoundingBox(__IntPtr out_draw_list, __IntPtr draw_list, __IntPtr draw_cmd, bool show_mesh, bool show_aabb);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugNodeFont", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugNodeFont(__IntPtr font);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugNodeStorage", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugNodeStorage(__IntPtr storage, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugNodeTabBar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugNodeTabBar(__IntPtr tab_bar, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugNodeTable", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugNodeTable(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugNodeTableSettings", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugNodeTableSettings(__IntPtr settings);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugNodeWindow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugNodeWindow(__IntPtr window, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugNodeWindowSettings", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugNodeWindowSettings(__IntPtr settings);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugNodeWindowsList", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugNodeWindowsList(__IntPtr windows, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugNodeWindowsListByBeginStackParent", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugNodeWindowsListByBeginStackParent(__IntPtr windows, int windows_size, __IntPtr parent_in_begin_stack);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugNodeViewport", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugNodeViewport(__IntPtr viewport);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugRenderViewportThumbnail", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugRenderViewportThumbnail(__IntPtr draw_list, __IntPtr viewport, __IntPtr bb);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFontAtlasGetBuilderForStbTruetype", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontAtlasGetBuilderForStbTruetype();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFontAtlasBuildInit", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasBuildInit(__IntPtr atlas);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFontAtlasBuildSetupFont", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasBuildSetupFont(__IntPtr atlas, __IntPtr font, __IntPtr font_config, float ascent, float descent);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFontAtlasBuildPackCustomRects", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasBuildPackCustomRects(__IntPtr atlas, __IntPtr stbrp_context_opaque);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFontAtlasBuildFinish", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasBuildFinish(__IntPtr atlas);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFontAtlasBuildRender8bppRectFromString", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasBuildRender8bppRectFromString(__IntPtr atlas, int x, int y, int w, int h, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string in_str, sbyte in_marker_char, byte in_marker_pixel_value);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFontAtlasBuildRender32bppRectFromString", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasBuildRender32bppRectFromString(__IntPtr atlas, int x, int y, int w, int h, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string in_str, sbyte in_marker_char, uint in_marker_pixel_value);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFontAtlasBuildMultiplyCalcLookupTable", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasBuildMultiplyCalcLookupTable(byte[] out_table, float in_multiply_factor);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFontAtlasBuildMultiplyRectAlpha8", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasBuildMultiplyRectAlpha8(byte[] table, byte* pixels, int x, int y, int w, int h, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igLogText", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LogText([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGET_FLT_MAX", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GET_FLT_MAX();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGET_FLT_MIN", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GET_FLT_MIN();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVector_ImWchar_create", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImVectorImWchar_create();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVector_ImWchar_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImVectorImWchar_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVector_ImWchar_Init", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImVectorImWcharInit(__IntPtr p);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVector_ImWchar_UnInit", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImVectorImWcharUnInit(__IntPtr p);
        }

        public static global::ImGuiSharp.ImVec2 ImVec2ImVec2Nil()
        {
            var __ret = __Internal.ImVec2ImVec2Nil();
            var __result0 = global::ImGuiSharp.ImVec2.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImVec2_destroy(global::ImGuiSharp.ImVec2 self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImVec2_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImVec2 ImVec2ImVec2Float(float _x, float _y)
        {
            var __ret = __Internal.ImVec2ImVec2Float(_x, _y);
            var __result0 = global::ImGuiSharp.ImVec2.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::ImGuiSharp.ImVec4 ImVec4ImVec4Nil()
        {
            var __ret = __Internal.ImVec4ImVec4Nil();
            var __result0 = global::ImGuiSharp.ImVec4.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImVec4_destroy(global::ImGuiSharp.ImVec4 self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImVec4_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImVec4 ImVec4ImVec4Float(float _x, float _y, float _z, float _w)
        {
            var __ret = __Internal.ImVec4ImVec4Float(_x, _y, _z, _w);
            var __result0 = global::ImGuiSharp.ImVec4.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::ImGuiSharp.ImGuiContext CreateContext(global::ImGuiSharp.ImFontAtlas shared_font_atlas)
        {
            var __arg0 = shared_font_atlas is null ? __IntPtr.Zero : shared_font_atlas.__Instance;
            var __ret = __Internal.CreateContext(__arg0);
            var __result0 = global::ImGuiSharp.ImGuiContext.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void DestroyContext(global::ImGuiSharp.ImGuiContext ctx)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            __Internal.DestroyContext(__arg0);
        }

        public static global::ImGuiSharp.ImGuiContext GetCurrentContext()
        {
            var __ret = __Internal.GetCurrentContext();
            var __result0 = global::ImGuiSharp.ImGuiContext.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void SetCurrentContext(global::ImGuiSharp.ImGuiContext ctx)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            __Internal.SetCurrentContext(__arg0);
        }

        public static global::ImGuiSharp.ImGuiIO GetIO()
        {
            var __ret = __Internal.GetIO();
            var __result0 = global::ImGuiSharp.ImGuiIO.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::ImGuiSharp.ImGuiStyle GetStyle()
        {
            var __ret = __Internal.GetStyle();
            var __result0 = global::ImGuiSharp.ImGuiStyle.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void NewFrame()
        {
            __Internal.NewFrame();
        }

        public static void EndFrame()
        {
            __Internal.EndFrame();
        }

        public static void Render()
        {
            __Internal.Render();
        }

        public static global::ImGuiSharp.ImDrawData GetDrawData()
        {
            var __ret = __Internal.GetDrawData();
            var __result0 = global::ImGuiSharp.ImDrawData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ShowDemoWindow(ref bool p_open)
        {
            fixed (bool* __p_open0 = &p_open)
            {
                var __arg0 = __p_open0;
                __Internal.ShowDemoWindow(__arg0);
            }
        }

        public static void ShowMetricsWindow(ref bool p_open)
        {
            fixed (bool* __p_open0 = &p_open)
            {
                var __arg0 = __p_open0;
                __Internal.ShowMetricsWindow(__arg0);
            }
        }

        public static void ShowStackToolWindow(ref bool p_open)
        {
            fixed (bool* __p_open0 = &p_open)
            {
                var __arg0 = __p_open0;
                __Internal.ShowStackToolWindow(__arg0);
            }
        }

        public static void ShowAboutWindow(ref bool p_open)
        {
            fixed (bool* __p_open0 = &p_open)
            {
                var __arg0 = __p_open0;
                __Internal.ShowAboutWindow(__arg0);
            }
        }

        public static void ShowStyleEditor(global::ImGuiSharp.ImGuiStyle @ref)
        {
            var __arg0 = @ref is null ? __IntPtr.Zero : @ref.__Instance;
            __Internal.ShowStyleEditor(__arg0);
        }

        public static bool ShowStyleSelector(string label)
        {
            var __ret = __Internal.ShowStyleSelector(label);
            return __ret;
        }

        public static void ShowFontSelector(string label)
        {
            __Internal.ShowFontSelector(label);
        }

        public static void ShowUserGuide()
        {
            __Internal.ShowUserGuide();
        }

        public static string GetVersion()
        {
            var __ret = __Internal.GetVersion();
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static void StyleColorsDark(global::ImGuiSharp.ImGuiStyle dst)
        {
            var __arg0 = dst is null ? __IntPtr.Zero : dst.__Instance;
            __Internal.StyleColorsDark(__arg0);
        }

        public static void StyleColorsLight(global::ImGuiSharp.ImGuiStyle dst)
        {
            var __arg0 = dst is null ? __IntPtr.Zero : dst.__Instance;
            __Internal.StyleColorsLight(__arg0);
        }

        public static void StyleColorsClassic(global::ImGuiSharp.ImGuiStyle dst)
        {
            var __arg0 = dst is null ? __IntPtr.Zero : dst.__Instance;
            __Internal.StyleColorsClassic(__arg0);
        }

        public static bool Begin(string name, ref bool p_open, int flags)
        {
            fixed (bool* __p_open1 = &p_open)
            {
                var __arg1 = __p_open1;
                var __ret = __Internal.Begin(name, __arg1, flags);
                return __ret;
            }
        }

        public static void End()
        {
            __Internal.End();
        }

        public static bool BeginChildStr(string str_id, global::ImGuiSharp.ImVec2 size, bool border, int flags)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            var __ret = __Internal.BeginChildStr(str_id, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, border, flags);
            return __ret;
        }

        public static bool BeginChildID(uint id, global::ImGuiSharp.ImVec2 size, bool border, int flags)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            var __ret = __Internal.BeginChildID(id, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, border, flags);
            return __ret;
        }

        public static void EndChild()
        {
            __Internal.EndChild();
        }

        public static bool IsWindowAppearing()
        {
            var __ret = __Internal.IsWindowAppearing();
            return __ret;
        }

        public static bool IsWindowCollapsed()
        {
            var __ret = __Internal.IsWindowCollapsed();
            return __ret;
        }

        public static bool IsWindowFocused(int flags)
        {
            var __ret = __Internal.IsWindowFocused(flags);
            return __ret;
        }

        public static bool IsWindowHovered(int flags)
        {
            var __ret = __Internal.IsWindowHovered(flags);
            return __ret;
        }

        public static global::ImGuiSharp.ImDrawList GetWindowDrawList()
        {
            var __ret = __Internal.GetWindowDrawList();
            var __result0 = global::ImGuiSharp.ImDrawList.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void GetWindowPos(global::ImGuiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetWindowPos(__arg0);
        }

        public static void GetWindowSize(global::ImGuiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetWindowSize(__arg0);
        }

        public static float GetWindowWidth()
        {
            var __ret = __Internal.GetWindowWidth();
            return __ret;
        }

        public static float GetWindowHeight()
        {
            var __ret = __Internal.GetWindowHeight();
            return __ret;
        }

        public static void SetNextWindowPos(global::ImGuiSharp.ImVec2 pos, int cond, global::ImGuiSharp.ImVec2 pivot)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg0 = pos.__Instance;
            if (ReferenceEquals(pivot, null))
                throw new global::System.ArgumentNullException("pivot", "Cannot be null because it is passed by value.");
            var __arg2 = pivot.__Instance;
            __Internal.SetNextWindowPos(*(global::ImGuiSharp.ImVec2.__Internal*) __arg0, cond, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2);
        }

        public static void SetNextWindowSize(global::ImGuiSharp.ImVec2 size, int cond)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg0 = size.__Instance;
            __Internal.SetNextWindowSize(*(global::ImGuiSharp.ImVec2.__Internal*) __arg0, cond);
        }

        public static void SetNextWindowSizeConstraints(global::ImGuiSharp.ImVec2 size_min, global::ImGuiSharp.ImVec2 size_max, global::ImGuiSharp.ImGuiSizeCallback custom_callback, __IntPtr custom_callback_data)
        {
            if (ReferenceEquals(size_min, null))
                throw new global::System.ArgumentNullException("size_min", "Cannot be null because it is passed by value.");
            var __arg0 = size_min.__Instance;
            if (ReferenceEquals(size_max, null))
                throw new global::System.ArgumentNullException("size_max", "Cannot be null because it is passed by value.");
            var __arg1 = size_max.__Instance;
            var __arg2 = custom_callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(custom_callback);
            __Internal.SetNextWindowSizeConstraints(*(global::ImGuiSharp.ImVec2.__Internal*) __arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, __arg2, custom_callback_data);
        }

        public static void SetNextWindowContentSize(global::ImGuiSharp.ImVec2 size)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg0 = size.__Instance;
            __Internal.SetNextWindowContentSize(*(global::ImGuiSharp.ImVec2.__Internal*) __arg0);
        }

        public static void SetNextWindowCollapsed(bool collapsed, int cond)
        {
            __Internal.SetNextWindowCollapsed(collapsed, cond);
        }

        public static void SetNextWindowFocus()
        {
            __Internal.SetNextWindowFocus();
        }

        public static void SetNextWindowBgAlpha(float alpha)
        {
            __Internal.SetNextWindowBgAlpha(alpha);
        }

        public static void SetWindowPosVec2(global::ImGuiSharp.ImVec2 pos, int cond)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg0 = pos.__Instance;
            __Internal.SetWindowPosVec2(*(global::ImGuiSharp.ImVec2.__Internal*) __arg0, cond);
        }

        public static void SetWindowSizeVec2(global::ImGuiSharp.ImVec2 size, int cond)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg0 = size.__Instance;
            __Internal.SetWindowSizeVec2(*(global::ImGuiSharp.ImVec2.__Internal*) __arg0, cond);
        }

        public static void SetWindowCollapsedBool(bool collapsed, int cond)
        {
            __Internal.SetWindowCollapsedBool(collapsed, cond);
        }

        public static void SetWindowFocusNil()
        {
            __Internal.SetWindowFocusNil();
        }

        public static void SetWindowFontScale(float scale)
        {
            __Internal.SetWindowFontScale(scale);
        }

        public static void SetWindowPosStr(string name, global::ImGuiSharp.ImVec2 pos, int cond)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            __Internal.SetWindowPosStr(name, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, cond);
        }

        public static void SetWindowSizeStr(string name, global::ImGuiSharp.ImVec2 size, int cond)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            __Internal.SetWindowSizeStr(name, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, cond);
        }

        public static void SetWindowCollapsedStr(string name, bool collapsed, int cond)
        {
            __Internal.SetWindowCollapsedStr(name, collapsed, cond);
        }

        public static void SetWindowFocusStr(string name)
        {
            __Internal.SetWindowFocusStr(name);
        }

        public static void GetContentRegionAvail(global::ImGuiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetContentRegionAvail(__arg0);
        }

        public static void GetContentRegionMax(global::ImGuiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetContentRegionMax(__arg0);
        }

        public static void GetWindowContentRegionMin(global::ImGuiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetWindowContentRegionMin(__arg0);
        }

        public static void GetWindowContentRegionMax(global::ImGuiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetWindowContentRegionMax(__arg0);
        }

        public static float GetScrollX()
        {
            var __ret = __Internal.GetScrollX();
            return __ret;
        }

        public static float GetScrollY()
        {
            var __ret = __Internal.GetScrollY();
            return __ret;
        }

        public static void SetScrollX_Float(float scroll_x)
        {
            __Internal.SetScrollX_Float(scroll_x);
        }

        public static void SetScrollY_Float(float scroll_y)
        {
            __Internal.SetScrollY_Float(scroll_y);
        }

        public static float GetScrollMaxX()
        {
            var __ret = __Internal.GetScrollMaxX();
            return __ret;
        }

        public static float GetScrollMaxY()
        {
            var __ret = __Internal.GetScrollMaxY();
            return __ret;
        }

        public static void SetScrollHereX(float center_x_ratio)
        {
            __Internal.SetScrollHereX(center_x_ratio);
        }

        public static void SetScrollHereY(float center_y_ratio)
        {
            __Internal.SetScrollHereY(center_y_ratio);
        }

        public static void SetScrollFromPosX_Float(float local_x, float center_x_ratio)
        {
            __Internal.SetScrollFromPosX_Float(local_x, center_x_ratio);
        }

        public static void SetScrollFromPosY_Float(float local_y, float center_y_ratio)
        {
            __Internal.SetScrollFromPosY_Float(local_y, center_y_ratio);
        }

        public static void PushFont(global::ImGuiSharp.ImFont font)
        {
            var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
            __Internal.PushFont(__arg0);
        }

        public static void PopFont()
        {
            __Internal.PopFont();
        }

        public static void PushStyleColorU32(int idx, uint col)
        {
            __Internal.PushStyleColorU32(idx, col);
        }

        public static void PushStyleColorVec4(int idx, global::ImGuiSharp.ImVec4 col)
        {
            if (ReferenceEquals(col, null))
                throw new global::System.ArgumentNullException("col", "Cannot be null because it is passed by value.");
            var __arg1 = col.__Instance;
            __Internal.PushStyleColorVec4(idx, *(global::ImGuiSharp.ImVec4.__Internal*) __arg1);
        }

        public static void PopStyleColor(int count)
        {
            __Internal.PopStyleColor(count);
        }

        public static void PushStyleVarFloat(int idx, float val)
        {
            __Internal.PushStyleVarFloat(idx, val);
        }

        public static void PushStyleVarVec2(int idx, global::ImGuiSharp.ImVec2 val)
        {
            if (ReferenceEquals(val, null))
                throw new global::System.ArgumentNullException("val", "Cannot be null because it is passed by value.");
            var __arg1 = val.__Instance;
            __Internal.PushStyleVarVec2(idx, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1);
        }

        public static void PopStyleVar(int count)
        {
            __Internal.PopStyleVar(count);
        }

        public static void PushAllowKeyboardFocus(bool allow_keyboard_focus)
        {
            __Internal.PushAllowKeyboardFocus(allow_keyboard_focus);
        }

        public static void PopAllowKeyboardFocus()
        {
            __Internal.PopAllowKeyboardFocus();
        }

        public static void PushButtonRepeat(bool repeat)
        {
            __Internal.PushButtonRepeat(repeat);
        }

        public static void PopButtonRepeat()
        {
            __Internal.PopButtonRepeat();
        }

        public static void PushItemWidth(float item_width)
        {
            __Internal.PushItemWidth(item_width);
        }

        public static void PopItemWidth()
        {
            __Internal.PopItemWidth();
        }

        public static void SetNextItemWidth(float item_width)
        {
            __Internal.SetNextItemWidth(item_width);
        }

        public static float CalcItemWidth()
        {
            var __ret = __Internal.CalcItemWidth();
            return __ret;
        }

        public static void PushTextWrapPos(float wrap_local_pos_x)
        {
            __Internal.PushTextWrapPos(wrap_local_pos_x);
        }

        public static void PopTextWrapPos()
        {
            __Internal.PopTextWrapPos();
        }

        public static global::ImGuiSharp.ImFont GetFont()
        {
            var __ret = __Internal.GetFont();
            var __result0 = global::ImGuiSharp.ImFont.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static float GetFontSize()
        {
            var __ret = __Internal.GetFontSize();
            return __ret;
        }

        public static void GetFontTexUvWhitePixel(global::ImGuiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetFontTexUvWhitePixel(__arg0);
        }

        public static uint GetColorU32Col(int idx, float alpha_mul)
        {
            var __ret = __Internal.GetColorU32Col(idx, alpha_mul);
            return __ret;
        }

        public static uint GetColorU32Vec4(global::ImGuiSharp.ImVec4 col)
        {
            if (ReferenceEquals(col, null))
                throw new global::System.ArgumentNullException("col", "Cannot be null because it is passed by value.");
            var __arg0 = col.__Instance;
            var __ret = __Internal.GetColorU32Vec4(*(global::ImGuiSharp.ImVec4.__Internal*) __arg0);
            return __ret;
        }

        public static uint GetColorU32U32(uint col)
        {
            var __ret = __Internal.GetColorU32U32(col);
            return __ret;
        }

        public static global::ImGuiSharp.ImVec4 GetStyleColorVec4(int idx)
        {
            var __ret = __Internal.GetStyleColorVec4(idx);
            var __result0 = global::ImGuiSharp.ImVec4.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void Separator()
        {
            __Internal.Separator();
        }

        public static void SameLine(float offset_from_start_x, float spacing)
        {
            __Internal.SameLine(offset_from_start_x, spacing);
        }

        public static void NewLine()
        {
            __Internal.NewLine();
        }

        public static void Spacing()
        {
            __Internal.Spacing();
        }

        public static void Dummy(global::ImGuiSharp.ImVec2 size)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg0 = size.__Instance;
            __Internal.Dummy(*(global::ImGuiSharp.ImVec2.__Internal*) __arg0);
        }

        public static void Indent(float indent_w)
        {
            __Internal.Indent(indent_w);
        }

        public static void Unindent(float indent_w)
        {
            __Internal.Unindent(indent_w);
        }

        public static void BeginGroup()
        {
            __Internal.BeginGroup();
        }

        public static void EndGroup()
        {
            __Internal.EndGroup();
        }

        public static void GetCursorPos(global::ImGuiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetCursorPos(__arg0);
        }

        public static float GetCursorPosX()
        {
            var __ret = __Internal.GetCursorPosX();
            return __ret;
        }

        public static float GetCursorPosY()
        {
            var __ret = __Internal.GetCursorPosY();
            return __ret;
        }

        public static void SetCursorPos(global::ImGuiSharp.ImVec2 local_pos)
        {
            if (ReferenceEquals(local_pos, null))
                throw new global::System.ArgumentNullException("local_pos", "Cannot be null because it is passed by value.");
            var __arg0 = local_pos.__Instance;
            __Internal.SetCursorPos(*(global::ImGuiSharp.ImVec2.__Internal*) __arg0);
        }

        public static void SetCursorPosX(float local_x)
        {
            __Internal.SetCursorPosX(local_x);
        }

        public static void SetCursorPosY(float local_y)
        {
            __Internal.SetCursorPosY(local_y);
        }

        public static void GetCursorStartPos(global::ImGuiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetCursorStartPos(__arg0);
        }

        public static void GetCursorScreenPos(global::ImGuiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetCursorScreenPos(__arg0);
        }

        public static void SetCursorScreenPos(global::ImGuiSharp.ImVec2 pos)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg0 = pos.__Instance;
            __Internal.SetCursorScreenPos(*(global::ImGuiSharp.ImVec2.__Internal*) __arg0);
        }

        public static void AlignTextToFramePadding()
        {
            __Internal.AlignTextToFramePadding();
        }

        public static float GetTextLineHeight()
        {
            var __ret = __Internal.GetTextLineHeight();
            return __ret;
        }

        public static float GetTextLineHeightWithSpacing()
        {
            var __ret = __Internal.GetTextLineHeightWithSpacing();
            return __ret;
        }

        public static float GetFrameHeight()
        {
            var __ret = __Internal.GetFrameHeight();
            return __ret;
        }

        public static float GetFrameHeightWithSpacing()
        {
            var __ret = __Internal.GetFrameHeightWithSpacing();
            return __ret;
        }

        public static void PushID_Str(string str_id)
        {
            __Internal.PushID_Str(str_id);
        }

        public static void PushID_StrStr(string str_id_begin, string str_id_end)
        {
            __Internal.PushID_StrStr(str_id_begin, str_id_end);
        }

        public static void PushID_Ptr(__IntPtr ptr_id)
        {
            __Internal.PushID_Ptr(ptr_id);
        }

        public static void PushID_Int(int int_id)
        {
            __Internal.PushID_Int(int_id);
        }

        public static void PopID()
        {
            __Internal.PopID();
        }

        public static uint GetID_Str(string str_id)
        {
            var __ret = __Internal.GetID_Str(str_id);
            return __ret;
        }

        public static uint GetID_StrStr(string str_id_begin, string str_id_end)
        {
            var __ret = __Internal.GetID_StrStr(str_id_begin, str_id_end);
            return __ret;
        }

        public static uint GetID_Ptr(__IntPtr ptr_id)
        {
            var __ret = __Internal.GetID_Ptr(ptr_id);
            return __ret;
        }

        public static void TextUnformatted(string text, string text_end)
        {
            __Internal.TextUnformatted(text, text_end);
        }

        public static void Text(string fmt)
        {
            __Internal.Text(fmt);
        }

        public static void TextColored(global::ImGuiSharp.ImVec4 col, string fmt)
        {
            if (ReferenceEquals(col, null))
                throw new global::System.ArgumentNullException("col", "Cannot be null because it is passed by value.");
            var __arg0 = col.__Instance;
            __Internal.TextColored(*(global::ImGuiSharp.ImVec4.__Internal*) __arg0, fmt);
        }

        public static void TextDisabled(string fmt)
        {
            __Internal.TextDisabled(fmt);
        }

        public static void TextWrapped(string fmt)
        {
            __Internal.TextWrapped(fmt);
        }

        public static void LabelText(string label, string fmt)
        {
            __Internal.LabelText(label, fmt);
        }

        public static void BulletText(string fmt)
        {
            __Internal.BulletText(fmt);
        }

        public static bool Button(string label, global::ImGuiSharp.ImVec2 size)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            var __ret = __Internal.Button(label, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1);
            return __ret;
        }

        public static bool SmallButton(string label)
        {
            var __ret = __Internal.SmallButton(label);
            return __ret;
        }

        public static bool InvisibleButton(string str_id, global::ImGuiSharp.ImVec2 size, int flags)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            var __ret = __Internal.InvisibleButton(str_id, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, flags);
            return __ret;
        }

        public static bool ArrowButton(string str_id, int dir)
        {
            var __ret = __Internal.ArrowButton(str_id, dir);
            return __ret;
        }

        public static void Image(__IntPtr user_texture_id, global::ImGuiSharp.ImVec2 size, global::ImGuiSharp.ImVec2 uv0, global::ImGuiSharp.ImVec2 uv1, global::ImGuiSharp.ImVec4 tint_col, global::ImGuiSharp.ImVec4 border_col)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            if (ReferenceEquals(uv0, null))
                throw new global::System.ArgumentNullException("uv0", "Cannot be null because it is passed by value.");
            var __arg2 = uv0.__Instance;
            if (ReferenceEquals(uv1, null))
                throw new global::System.ArgumentNullException("uv1", "Cannot be null because it is passed by value.");
            var __arg3 = uv1.__Instance;
            if (ReferenceEquals(tint_col, null))
                throw new global::System.ArgumentNullException("tint_col", "Cannot be null because it is passed by value.");
            var __arg4 = tint_col.__Instance;
            if (ReferenceEquals(border_col, null))
                throw new global::System.ArgumentNullException("border_col", "Cannot be null because it is passed by value.");
            var __arg5 = border_col.__Instance;
            __Internal.Image(user_texture_id, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3, *(global::ImGuiSharp.ImVec4.__Internal*) __arg4, *(global::ImGuiSharp.ImVec4.__Internal*) __arg5);
        }

        public static bool ImageButton(__IntPtr user_texture_id, global::ImGuiSharp.ImVec2 size, global::ImGuiSharp.ImVec2 uv0, global::ImGuiSharp.ImVec2 uv1, int frame_padding, global::ImGuiSharp.ImVec4 bg_col, global::ImGuiSharp.ImVec4 tint_col)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            if (ReferenceEquals(uv0, null))
                throw new global::System.ArgumentNullException("uv0", "Cannot be null because it is passed by value.");
            var __arg2 = uv0.__Instance;
            if (ReferenceEquals(uv1, null))
                throw new global::System.ArgumentNullException("uv1", "Cannot be null because it is passed by value.");
            var __arg3 = uv1.__Instance;
            if (ReferenceEquals(bg_col, null))
                throw new global::System.ArgumentNullException("bg_col", "Cannot be null because it is passed by value.");
            var __arg5 = bg_col.__Instance;
            if (ReferenceEquals(tint_col, null))
                throw new global::System.ArgumentNullException("tint_col", "Cannot be null because it is passed by value.");
            var __arg6 = tint_col.__Instance;
            var __ret = __Internal.ImageButton(user_texture_id, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3, frame_padding, *(global::ImGuiSharp.ImVec4.__Internal*) __arg5, *(global::ImGuiSharp.ImVec4.__Internal*) __arg6);
            return __ret;
        }

        public static bool Checkbox(string label, ref bool v)
        {
            fixed (bool* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.Checkbox(label, __arg1);
                return __ret;
            }
        }

        public static bool CheckboxFlagsIntPtr(string label, ref int flags, int flags_value)
        {
            fixed (int* __flags1 = &flags)
            {
                var __arg1 = __flags1;
                var __ret = __Internal.CheckboxFlagsIntPtr(label, __arg1, flags_value);
                return __ret;
            }
        }

        public static bool CheckboxFlagsUintPtr(string label, ref uint flags, uint flags_value)
        {
            fixed (uint* __flags1 = &flags)
            {
                var __arg1 = __flags1;
                var __ret = __Internal.CheckboxFlagsUintPtr(label, __arg1, flags_value);
                return __ret;
            }
        }

        public static bool RadioButtonBool(string label, bool active)
        {
            var __ret = __Internal.RadioButtonBool(label, active);
            return __ret;
        }

        public static bool RadioButtonIntPtr(string label, ref int v, int v_button)
        {
            fixed (int* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.RadioButtonIntPtr(label, __arg1, v_button);
                return __ret;
            }
        }

        public static void ProgressBar(float fraction, global::ImGuiSharp.ImVec2 size_arg, string overlay)
        {
            if (ReferenceEquals(size_arg, null))
                throw new global::System.ArgumentNullException("size_arg", "Cannot be null because it is passed by value.");
            var __arg1 = size_arg.__Instance;
            __Internal.ProgressBar(fraction, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, overlay);
        }

        public static void Bullet()
        {
            __Internal.Bullet();
        }

        public static bool BeginCombo(string label, string preview_value, int flags)
        {
            var __ret = __Internal.BeginCombo(label, preview_value, flags);
            return __ret;
        }

        public static void EndCombo()
        {
            __Internal.EndCombo();
        }

        public static bool ComboStr_arr(string label, ref int current_item, string[] items, int items_count, int popup_max_height_in_items)
        {
            fixed (int* __current_item1 = &current_item)
            {
                var __arg1 = __current_item1;
                var __ret = __Internal.ComboStr_arr(label, __arg1, items, items_count, popup_max_height_in_items);
                return __ret;
            }
        }

        public static bool ComboStr(string label, ref int current_item, string items_separated_by_zeros, int popup_max_height_in_items)
        {
            fixed (int* __current_item1 = &current_item)
            {
                var __arg1 = __current_item1;
                var __ret = __Internal.ComboStr(label, __arg1, items_separated_by_zeros, popup_max_height_in_items);
                return __ret;
            }
        }

        public static bool ComboFnBoolPtr(string label, ref int current_item, global::ImGuiSharp.Delegates.Func_bool___IntPtr_int_sbytePtrPtr items_getter, __IntPtr data, int items_count, int popup_max_height_in_items)
        {
            fixed (int* __current_item1 = &current_item)
            {
                var __arg1 = __current_item1;
                var __arg2 = items_getter == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(items_getter);
                var __ret = __Internal.ComboFnBoolPtr(label, __arg1, __arg2, data, items_count, popup_max_height_in_items);
                return __ret;
            }
        }

        public static bool DragFloat(string label, ref float v, float v_speed, float v_min, float v_max, string format, int flags)
        {
            fixed (float* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.DragFloat(label, __arg1, v_speed, v_min, v_max, format, flags);
                return __ret;
            }
        }

        public static bool DragFloat2(string label, float[] v, float v_speed, float v_min, float v_max, string format, int flags)
        {
            if (v == null || v.Length != 2)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.DragFloat2(label, v, v_speed, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool DragFloat3(string label, float[] v, float v_speed, float v_min, float v_max, string format, int flags)
        {
            if (v == null || v.Length != 3)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.DragFloat3(label, v, v_speed, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool DragFloat4(string label, float[] v, float v_speed, float v_min, float v_max, string format, int flags)
        {
            if (v == null || v.Length != 4)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.DragFloat4(label, v, v_speed, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool DragFloatRange2(string label, ref float v_current_min, ref float v_current_max, float v_speed, float v_min, float v_max, string format, string format_max, int flags)
        {
            fixed (float* __v_current_min1 = &v_current_min)
            {
                var __arg1 = __v_current_min1;
                fixed (float* __v_current_max2 = &v_current_max)
                {
                    var __arg2 = __v_current_max2;
                    var __ret = __Internal.DragFloatRange2(label, __arg1, __arg2, v_speed, v_min, v_max, format, format_max, flags);
                    return __ret;
                }
            }
        }

        public static bool DragInt(string label, ref int v, float v_speed, int v_min, int v_max, string format, int flags)
        {
            fixed (int* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.DragInt(label, __arg1, v_speed, v_min, v_max, format, flags);
                return __ret;
            }
        }

        public static bool DragInt2(string label, int[] v, float v_speed, int v_min, int v_max, string format, int flags)
        {
            if (v == null || v.Length != 2)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.DragInt2(label, v, v_speed, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool DragInt3(string label, int[] v, float v_speed, int v_min, int v_max, string format, int flags)
        {
            if (v == null || v.Length != 3)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.DragInt3(label, v, v_speed, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool DragInt4(string label, int[] v, float v_speed, int v_min, int v_max, string format, int flags)
        {
            if (v == null || v.Length != 4)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.DragInt4(label, v, v_speed, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool DragIntRange2(string label, ref int v_current_min, ref int v_current_max, float v_speed, int v_min, int v_max, string format, string format_max, int flags)
        {
            fixed (int* __v_current_min1 = &v_current_min)
            {
                var __arg1 = __v_current_min1;
                fixed (int* __v_current_max2 = &v_current_max)
                {
                    var __arg2 = __v_current_max2;
                    var __ret = __Internal.DragIntRange2(label, __arg1, __arg2, v_speed, v_min, v_max, format, format_max, flags);
                    return __ret;
                }
            }
        }

        public static bool DragScalar(string label, int data_type, __IntPtr p_data, float v_speed, __IntPtr p_min, __IntPtr p_max, string format, int flags)
        {
            var __ret = __Internal.DragScalar(label, data_type, p_data, v_speed, p_min, p_max, format, flags);
            return __ret;
        }

        public static bool DragScalarN(string label, int data_type, __IntPtr p_data, int components, float v_speed, __IntPtr p_min, __IntPtr p_max, string format, int flags)
        {
            var __ret = __Internal.DragScalarN(label, data_type, p_data, components, v_speed, p_min, p_max, format, flags);
            return __ret;
        }

        public static bool SliderFloat(string label, ref float v, float v_min, float v_max, string format, int flags)
        {
            fixed (float* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.SliderFloat(label, __arg1, v_min, v_max, format, flags);
                return __ret;
            }
        }

        public static bool SliderFloat2(string label, float[] v, float v_min, float v_max, string format, int flags)
        {
            if (v == null || v.Length != 2)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.SliderFloat2(label, v, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool SliderFloat3(string label, float[] v, float v_min, float v_max, string format, int flags)
        {
            if (v == null || v.Length != 3)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.SliderFloat3(label, v, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool SliderFloat4(string label, float[] v, float v_min, float v_max, string format, int flags)
        {
            if (v == null || v.Length != 4)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.SliderFloat4(label, v, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool SliderAngle(string label, ref float v_rad, float v_degrees_min, float v_degrees_max, string format, int flags)
        {
            fixed (float* __v_rad1 = &v_rad)
            {
                var __arg1 = __v_rad1;
                var __ret = __Internal.SliderAngle(label, __arg1, v_degrees_min, v_degrees_max, format, flags);
                return __ret;
            }
        }

        public static bool SliderInt(string label, ref int v, int v_min, int v_max, string format, int flags)
        {
            fixed (int* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.SliderInt(label, __arg1, v_min, v_max, format, flags);
                return __ret;
            }
        }

        public static bool SliderInt2(string label, int[] v, int v_min, int v_max, string format, int flags)
        {
            if (v == null || v.Length != 2)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.SliderInt2(label, v, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool SliderInt3(string label, int[] v, int v_min, int v_max, string format, int flags)
        {
            if (v == null || v.Length != 3)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.SliderInt3(label, v, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool SliderInt4(string label, int[] v, int v_min, int v_max, string format, int flags)
        {
            if (v == null || v.Length != 4)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.SliderInt4(label, v, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool SliderScalar(string label, int data_type, __IntPtr p_data, __IntPtr p_min, __IntPtr p_max, string format, int flags)
        {
            var __ret = __Internal.SliderScalar(label, data_type, p_data, p_min, p_max, format, flags);
            return __ret;
        }

        public static bool SliderScalarN(string label, int data_type, __IntPtr p_data, int components, __IntPtr p_min, __IntPtr p_max, string format, int flags)
        {
            var __ret = __Internal.SliderScalarN(label, data_type, p_data, components, p_min, p_max, format, flags);
            return __ret;
        }

        public static bool VSliderFloat(string label, global::ImGuiSharp.ImVec2 size, ref float v, float v_min, float v_max, string format, int flags)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            fixed (float* __v2 = &v)
            {
                var __arg2 = __v2;
                var __ret = __Internal.VSliderFloat(label, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, __arg2, v_min, v_max, format, flags);
                return __ret;
            }
        }

        public static bool VSliderInt(string label, global::ImGuiSharp.ImVec2 size, ref int v, int v_min, int v_max, string format, int flags)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            fixed (int* __v2 = &v)
            {
                var __arg2 = __v2;
                var __ret = __Internal.VSliderInt(label, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, __arg2, v_min, v_max, format, flags);
                return __ret;
            }
        }

        public static bool VSliderScalar(string label, global::ImGuiSharp.ImVec2 size, int data_type, __IntPtr p_data, __IntPtr p_min, __IntPtr p_max, string format, int flags)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            var __ret = __Internal.VSliderScalar(label, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, data_type, p_data, p_min, p_max, format, flags);
            return __ret;
        }

        public static bool InputText(string label, sbyte* buf, IntPtr buf_size, int flags, global::ImGuiSharp.ImGuiInputTextCallback callback, __IntPtr user_data)
        {
            var __arg4 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.InputText(label, buf, buf_size, flags, __arg4, user_data);
            return __ret;
        }

        public static bool InputTextMultiline(string label, sbyte* buf, IntPtr buf_size, global::ImGuiSharp.ImVec2 size, int flags, global::ImGuiSharp.ImGuiInputTextCallback callback, __IntPtr user_data)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg3 = size.__Instance;
            var __arg5 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.InputTextMultiline(label, buf, buf_size, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3, flags, __arg5, user_data);
            return __ret;
        }

        public static bool InputTextWithHint(string label, string hint, sbyte* buf, IntPtr buf_size, int flags, global::ImGuiSharp.ImGuiInputTextCallback callback, __IntPtr user_data)
        {
            var __arg5 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.InputTextWithHint(label, hint, buf, buf_size, flags, __arg5, user_data);
            return __ret;
        }

        public static bool InputFloat(string label, ref float v, float step, float step_fast, string format, int flags)
        {
            fixed (float* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.InputFloat(label, __arg1, step, step_fast, format, flags);
                return __ret;
            }
        }

        public static bool InputFloat2(string label, float[] v, string format, int flags)
        {
            if (v == null || v.Length != 2)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.InputFloat2(label, v, format, flags);
            return __ret;
        }

        public static bool InputFloat3(string label, float[] v, string format, int flags)
        {
            if (v == null || v.Length != 3)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.InputFloat3(label, v, format, flags);
            return __ret;
        }

        public static bool InputFloat4(string label, float[] v, string format, int flags)
        {
            if (v == null || v.Length != 4)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.InputFloat4(label, v, format, flags);
            return __ret;
        }

        public static bool InputInt(string label, ref int v, int step, int step_fast, int flags)
        {
            fixed (int* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.InputInt(label, __arg1, step, step_fast, flags);
                return __ret;
            }
        }

        public static bool InputInt2(string label, int[] v, int flags)
        {
            if (v == null || v.Length != 2)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.InputInt2(label, v, flags);
            return __ret;
        }

        public static bool InputInt3(string label, int[] v, int flags)
        {
            if (v == null || v.Length != 3)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.InputInt3(label, v, flags);
            return __ret;
        }

        public static bool InputInt4(string label, int[] v, int flags)
        {
            if (v == null || v.Length != 4)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.InputInt4(label, v, flags);
            return __ret;
        }

        public static bool InputDouble(string label, ref double v, double step, double step_fast, string format, int flags)
        {
            fixed (double* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.InputDouble(label, __arg1, step, step_fast, format, flags);
                return __ret;
            }
        }

        public static bool InputScalar(string label, int data_type, __IntPtr p_data, __IntPtr p_step, __IntPtr p_step_fast, string format, int flags)
        {
            var __ret = __Internal.InputScalar(label, data_type, p_data, p_step, p_step_fast, format, flags);
            return __ret;
        }

        public static bool InputScalarN(string label, int data_type, __IntPtr p_data, int components, __IntPtr p_step, __IntPtr p_step_fast, string format, int flags)
        {
            var __ret = __Internal.InputScalarN(label, data_type, p_data, components, p_step, p_step_fast, format, flags);
            return __ret;
        }

        public static bool ColorEdit3(string label, float[] col, int flags)
        {
            if (col == null || col.Length != 3)
                throw new ArgumentOutOfRangeException("col", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.ColorEdit3(label, col, flags);
            return __ret;
        }

        public static bool ColorEdit4(string label, float[] col, int flags)
        {
            if (col == null || col.Length != 4)
                throw new ArgumentOutOfRangeException("col", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.ColorEdit4(label, col, flags);
            return __ret;
        }

        public static bool ColorPicker3(string label, float[] col, int flags)
        {
            if (col == null || col.Length != 3)
                throw new ArgumentOutOfRangeException("col", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.ColorPicker3(label, col, flags);
            return __ret;
        }

        public static bool ColorPicker4(string label, float[] col, int flags, ref float ref_col)
        {
            if (col == null || col.Length != 4)
                throw new ArgumentOutOfRangeException("col", "The dimensions of the provided array don't match the required size.");
            fixed (float* __ref_col3 = &ref_col)
            {
                var __arg3 = __ref_col3;
                var __ret = __Internal.ColorPicker4(label, col, flags, __arg3);
                return __ret;
            }
        }

        public static bool ColorButton(string desc_id, global::ImGuiSharp.ImVec4 col, int flags, global::ImGuiSharp.ImVec2 size)
        {
            if (ReferenceEquals(col, null))
                throw new global::System.ArgumentNullException("col", "Cannot be null because it is passed by value.");
            var __arg1 = col.__Instance;
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg3 = size.__Instance;
            var __ret = __Internal.ColorButton(desc_id, *(global::ImGuiSharp.ImVec4.__Internal*) __arg1, flags, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3);
            return __ret;
        }

        public static void SetColorEditOptions(int flags)
        {
            __Internal.SetColorEditOptions(flags);
        }

        public static bool TreeNodeStr(string label)
        {
            var __ret = __Internal.TreeNodeStr(label);
            return __ret;
        }

        public static bool TreeNodeStrStr(string str_id, string fmt)
        {
            var __ret = __Internal.TreeNodeStrStr(str_id, fmt);
            return __ret;
        }

        public static bool TreeNodePtr(__IntPtr ptr_id, string fmt)
        {
            var __ret = __Internal.TreeNodePtr(ptr_id, fmt);
            return __ret;
        }

        public static bool TreeNodeExStr(string label, int flags)
        {
            var __ret = __Internal.TreeNodeExStr(label, flags);
            return __ret;
        }

        public static bool TreeNodeExStrStr(string str_id, int flags, string fmt)
        {
            var __ret = __Internal.TreeNodeExStrStr(str_id, flags, fmt);
            return __ret;
        }

        public static bool TreeNodeExPtr(__IntPtr ptr_id, int flags, string fmt)
        {
            var __ret = __Internal.TreeNodeExPtr(ptr_id, flags, fmt);
            return __ret;
        }

        public static void TreePushStr(string str_id)
        {
            __Internal.TreePushStr(str_id);
        }

        public static void TreePushPtr(__IntPtr ptr_id)
        {
            __Internal.TreePushPtr(ptr_id);
        }

        public static void TreePop()
        {
            __Internal.TreePop();
        }

        public static float GetTreeNodeToLabelSpacing()
        {
            var __ret = __Internal.GetTreeNodeToLabelSpacing();
            return __ret;
        }

        public static bool CollapsingHeaderTreeNodeFlags(string label, int flags)
        {
            var __ret = __Internal.CollapsingHeaderTreeNodeFlags(label, flags);
            return __ret;
        }

        public static bool CollapsingHeaderBoolPtr(string label, ref bool p_visible, int flags)
        {
            fixed (bool* __p_visible1 = &p_visible)
            {
                var __arg1 = __p_visible1;
                var __ret = __Internal.CollapsingHeaderBoolPtr(label, __arg1, flags);
                return __ret;
            }
        }

        public static void SetNextItemOpen(bool is_open, int cond)
        {
            __Internal.SetNextItemOpen(is_open, cond);
        }

        public static bool SelectableBool(string label, bool selected, int flags, global::ImGuiSharp.ImVec2 size)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg3 = size.__Instance;
            var __ret = __Internal.SelectableBool(label, selected, flags, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3);
            return __ret;
        }

        public static bool SelectableBoolPtr(string label, ref bool p_selected, int flags, global::ImGuiSharp.ImVec2 size)
        {
            fixed (bool* __p_selected1 = &p_selected)
            {
                var __arg1 = __p_selected1;
                if (ReferenceEquals(size, null))
                    throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
                var __arg3 = size.__Instance;
                var __ret = __Internal.SelectableBoolPtr(label, __arg1, flags, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3);
                return __ret;
            }
        }

        public static bool BeginListBox(string label, global::ImGuiSharp.ImVec2 size)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            var __ret = __Internal.BeginListBox(label, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1);
            return __ret;
        }

        public static void EndListBox()
        {
            __Internal.EndListBox();
        }

        public static bool ListBoxStr_arr(string label, ref int current_item, string[] items, int items_count, int height_in_items)
        {
            fixed (int* __current_item1 = &current_item)
            {
                var __arg1 = __current_item1;
                var __ret = __Internal.ListBoxStr_arr(label, __arg1, items, items_count, height_in_items);
                return __ret;
            }
        }

        public static bool ListBoxFnBoolPtr(string label, ref int current_item, global::ImGuiSharp.Delegates.Func_bool___IntPtr_int_sbytePtrPtr items_getter, __IntPtr data, int items_count, int height_in_items)
        {
            fixed (int* __current_item1 = &current_item)
            {
                var __arg1 = __current_item1;
                var __arg2 = items_getter == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(items_getter);
                var __ret = __Internal.ListBoxFnBoolPtr(label, __arg1, __arg2, data, items_count, height_in_items);
                return __ret;
            }
        }

        public static void PlotLinesFloatPtr(string label, ref float values, int values_count, int values_offset, string overlay_text, float scale_min, float scale_max, global::ImGuiSharp.ImVec2 graph_size, int stride)
        {
            fixed (float* __values1 = &values)
            {
                var __arg1 = __values1;
                if (ReferenceEquals(graph_size, null))
                    throw new global::System.ArgumentNullException("graph_size", "Cannot be null because it is passed by value.");
                var __arg7 = graph_size.__Instance;
                __Internal.PlotLinesFloatPtr(label, __arg1, values_count, values_offset, overlay_text, scale_min, scale_max, *(global::ImGuiSharp.ImVec2.__Internal*) __arg7, stride);
            }
        }

        public static void PlotLinesFnFloatPtr(string label, global::ImGuiSharp.Delegates.Func_float___IntPtr_int values_getter, __IntPtr data, int values_count, int values_offset, string overlay_text, float scale_min, float scale_max, global::ImGuiSharp.ImVec2 graph_size)
        {
            var __arg1 = values_getter == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(values_getter);
            if (ReferenceEquals(graph_size, null))
                throw new global::System.ArgumentNullException("graph_size", "Cannot be null because it is passed by value.");
            var __arg8 = graph_size.__Instance;
            __Internal.PlotLinesFnFloatPtr(label, __arg1, data, values_count, values_offset, overlay_text, scale_min, scale_max, *(global::ImGuiSharp.ImVec2.__Internal*) __arg8);
        }

        public static void PlotHistogramFloatPtr(string label, ref float values, int values_count, int values_offset, string overlay_text, float scale_min, float scale_max, global::ImGuiSharp.ImVec2 graph_size, int stride)
        {
            fixed (float* __values1 = &values)
            {
                var __arg1 = __values1;
                if (ReferenceEquals(graph_size, null))
                    throw new global::System.ArgumentNullException("graph_size", "Cannot be null because it is passed by value.");
                var __arg7 = graph_size.__Instance;
                __Internal.PlotHistogramFloatPtr(label, __arg1, values_count, values_offset, overlay_text, scale_min, scale_max, *(global::ImGuiSharp.ImVec2.__Internal*) __arg7, stride);
            }
        }

        public static void PlotHistogramFnFloatPtr(string label, global::ImGuiSharp.Delegates.Func_float___IntPtr_int values_getter, __IntPtr data, int values_count, int values_offset, string overlay_text, float scale_min, float scale_max, global::ImGuiSharp.ImVec2 graph_size)
        {
            var __arg1 = values_getter == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(values_getter);
            if (ReferenceEquals(graph_size, null))
                throw new global::System.ArgumentNullException("graph_size", "Cannot be null because it is passed by value.");
            var __arg8 = graph_size.__Instance;
            __Internal.PlotHistogramFnFloatPtr(label, __arg1, data, values_count, values_offset, overlay_text, scale_min, scale_max, *(global::ImGuiSharp.ImVec2.__Internal*) __arg8);
        }

        public static void ValueBool(string prefix, bool b)
        {
            __Internal.ValueBool(prefix, b);
        }

        public static void ValueInt(string prefix, int v)
        {
            __Internal.ValueInt(prefix, v);
        }

        public static void ValueUint(string prefix, uint v)
        {
            __Internal.ValueUint(prefix, v);
        }

        public static void ValueFloat(string prefix, float v, string float_format)
        {
            __Internal.ValueFloat(prefix, v, float_format);
        }

        public static bool BeginMenuBar()
        {
            var __ret = __Internal.BeginMenuBar();
            return __ret;
        }

        public static void EndMenuBar()
        {
            __Internal.EndMenuBar();
        }

        public static bool BeginMainMenuBar()
        {
            var __ret = __Internal.BeginMainMenuBar();
            return __ret;
        }

        public static void EndMainMenuBar()
        {
            __Internal.EndMainMenuBar();
        }

        public static bool BeginMenu(string label, bool enabled)
        {
            var __ret = __Internal.BeginMenu(label, enabled);
            return __ret;
        }

        public static void EndMenu()
        {
            __Internal.EndMenu();
        }

        public static bool MenuItemBool(string label, string shortcut, bool selected, bool enabled)
        {
            var __ret = __Internal.MenuItemBool(label, shortcut, selected, enabled);
            return __ret;
        }

        public static bool MenuItemBoolPtr(string label, string shortcut, ref bool p_selected, bool enabled)
        {
            fixed (bool* __p_selected2 = &p_selected)
            {
                var __arg2 = __p_selected2;
                var __ret = __Internal.MenuItemBoolPtr(label, shortcut, __arg2, enabled);
                return __ret;
            }
        }

        public static void BeginTooltip()
        {
            __Internal.BeginTooltip();
        }

        public static void EndTooltip()
        {
            __Internal.EndTooltip();
        }

        public static void SetTooltip(string fmt)
        {
            __Internal.SetTooltip(fmt);
        }

        public static bool BeginPopup(string str_id, int flags)
        {
            var __ret = __Internal.BeginPopup(str_id, flags);
            return __ret;
        }

        public static bool BeginPopupModal(string name, ref bool p_open, int flags)
        {
            fixed (bool* __p_open1 = &p_open)
            {
                var __arg1 = __p_open1;
                var __ret = __Internal.BeginPopupModal(name, __arg1, flags);
                return __ret;
            }
        }

        public static void EndPopup()
        {
            __Internal.EndPopup();
        }

        public static void OpenPopupStr(string str_id, int popup_flags)
        {
            __Internal.OpenPopupStr(str_id, popup_flags);
        }

        public static void OpenPopupID(uint id, int popup_flags)
        {
            __Internal.OpenPopupID(id, popup_flags);
        }

        public static void OpenPopupOnItemClick(string str_id, int popup_flags)
        {
            __Internal.OpenPopupOnItemClick(str_id, popup_flags);
        }

        public static void CloseCurrentPopup()
        {
            __Internal.CloseCurrentPopup();
        }

        public static bool BeginPopupContextItem(string str_id, int popup_flags)
        {
            var __ret = __Internal.BeginPopupContextItem(str_id, popup_flags);
            return __ret;
        }

        public static bool BeginPopupContextWindow(string str_id, int popup_flags)
        {
            var __ret = __Internal.BeginPopupContextWindow(str_id, popup_flags);
            return __ret;
        }

        public static bool BeginPopupContextVoid(string str_id, int popup_flags)
        {
            var __ret = __Internal.BeginPopupContextVoid(str_id, popup_flags);
            return __ret;
        }

        public static bool IsPopupOpenStr(string str_id, int flags)
        {
            var __ret = __Internal.IsPopupOpenStr(str_id, flags);
            return __ret;
        }

        public static bool BeginTable(string str_id, int column, int flags, global::ImGuiSharp.ImVec2 outer_size, float inner_width)
        {
            if (ReferenceEquals(outer_size, null))
                throw new global::System.ArgumentNullException("outer_size", "Cannot be null because it is passed by value.");
            var __arg3 = outer_size.__Instance;
            var __ret = __Internal.BeginTable(str_id, column, flags, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3, inner_width);
            return __ret;
        }

        public static void EndTable()
        {
            __Internal.EndTable();
        }

        public static void TableNextRow(int row_flags, float min_row_height)
        {
            __Internal.TableNextRow(row_flags, min_row_height);
        }

        public static bool TableNextColumn()
        {
            var __ret = __Internal.TableNextColumn();
            return __ret;
        }

        public static bool TableSetColumnIndex(int column_n)
        {
            var __ret = __Internal.TableSetColumnIndex(column_n);
            return __ret;
        }

        public static void TableSetupColumn(string label, int flags, float init_width_or_weight, uint user_id)
        {
            __Internal.TableSetupColumn(label, flags, init_width_or_weight, user_id);
        }

        public static void TableSetupScrollFreeze(int cols, int rows)
        {
            __Internal.TableSetupScrollFreeze(cols, rows);
        }

        public static void TableHeadersRow()
        {
            __Internal.TableHeadersRow();
        }

        public static void TableHeader(string label)
        {
            __Internal.TableHeader(label);
        }

        public static global::ImGuiSharp.ImGuiTableSortSpecs TableGetSortSpecs()
        {
            var __ret = __Internal.TableGetSortSpecs();
            var __result0 = global::ImGuiSharp.ImGuiTableSortSpecs.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static int TableGetColumnCount()
        {
            var __ret = __Internal.TableGetColumnCount();
            return __ret;
        }

        public static int TableGetColumnIndex()
        {
            var __ret = __Internal.TableGetColumnIndex();
            return __ret;
        }

        public static int TableGetRowIndex()
        {
            var __ret = __Internal.TableGetRowIndex();
            return __ret;
        }

        public static string TableGetColumnNameInt(int column_n)
        {
            var __ret = __Internal.TableGetColumnNameInt(column_n);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static int TableGetColumnFlags(int column_n)
        {
            var __ret = __Internal.TableGetColumnFlags(column_n);
            return __ret;
        }

        public static void TableSetColumnEnabled(int column_n, bool v)
        {
            __Internal.TableSetColumnEnabled(column_n, v);
        }

        public static void TableSetBgColor(int target, uint color, int column_n)
        {
            __Internal.TableSetBgColor(target, color, column_n);
        }

        public static void Columns(int count, string id, bool border)
        {
            __Internal.Columns(count, id, border);
        }

        public static void NextColumn()
        {
            __Internal.NextColumn();
        }

        public static int GetColumnIndex()
        {
            var __ret = __Internal.GetColumnIndex();
            return __ret;
        }

        public static float GetColumnWidth(int column_index)
        {
            var __ret = __Internal.GetColumnWidth(column_index);
            return __ret;
        }

        public static void SetColumnWidth(int column_index, float width)
        {
            __Internal.SetColumnWidth(column_index, width);
        }

        public static float GetColumnOffset(int column_index)
        {
            var __ret = __Internal.GetColumnOffset(column_index);
            return __ret;
        }

        public static void SetColumnOffset(int column_index, float offset_x)
        {
            __Internal.SetColumnOffset(column_index, offset_x);
        }

        public static int GetColumnsCount()
        {
            var __ret = __Internal.GetColumnsCount();
            return __ret;
        }

        public static bool BeginTabBar(string str_id, int flags)
        {
            var __ret = __Internal.BeginTabBar(str_id, flags);
            return __ret;
        }

        public static void EndTabBar()
        {
            __Internal.EndTabBar();
        }

        public static bool BeginTabItem(string label, ref bool p_open, int flags)
        {
            fixed (bool* __p_open1 = &p_open)
            {
                var __arg1 = __p_open1;
                var __ret = __Internal.BeginTabItem(label, __arg1, flags);
                return __ret;
            }
        }

        public static void EndTabItem()
        {
            __Internal.EndTabItem();
        }

        public static bool TabItemButton(string label, int flags)
        {
            var __ret = __Internal.TabItemButton(label, flags);
            return __ret;
        }

        public static void SetTabItemClosed(string tab_or_docked_window_label)
        {
            __Internal.SetTabItemClosed(tab_or_docked_window_label);
        }

        public static void LogToTTY(int auto_open_depth)
        {
            __Internal.LogToTTY(auto_open_depth);
        }

        public static void LogToFile(int auto_open_depth, string filename)
        {
            __Internal.LogToFile(auto_open_depth, filename);
        }

        public static void LogToClipboard(int auto_open_depth)
        {
            __Internal.LogToClipboard(auto_open_depth);
        }

        public static void LogFinish()
        {
            __Internal.LogFinish();
        }

        public static void LogButtons()
        {
            __Internal.LogButtons();
        }

        public static bool BeginDragDropSource(int flags)
        {
            var __ret = __Internal.BeginDragDropSource(flags);
            return __ret;
        }

        public static bool SetDragDropPayload(string type, __IntPtr data, IntPtr sz, int cond)
        {
            var __ret = __Internal.SetDragDropPayload(type, data, sz, cond);
            return __ret;
        }

        public static void EndDragDropSource()
        {
            __Internal.EndDragDropSource();
        }

        public static bool BeginDragDropTarget()
        {
            var __ret = __Internal.BeginDragDropTarget();
            return __ret;
        }

        public static global::ImGuiSharp.ImGuiPayload AcceptDragDropPayload(string type, int flags)
        {
            var __ret = __Internal.AcceptDragDropPayload(type, flags);
            var __result0 = global::ImGuiSharp.ImGuiPayload.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void EndDragDropTarget()
        {
            __Internal.EndDragDropTarget();
        }

        public static global::ImGuiSharp.ImGuiPayload GetDragDropPayload()
        {
            var __ret = __Internal.GetDragDropPayload();
            var __result0 = global::ImGuiSharp.ImGuiPayload.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void BeginDisabled(bool disabled)
        {
            __Internal.BeginDisabled(disabled);
        }

        public static void EndDisabled()
        {
            __Internal.EndDisabled();
        }

        public static void PushClipRect(global::ImGuiSharp.ImVec2 clip_rect_min, global::ImGuiSharp.ImVec2 clip_rect_max, bool intersect_with_current_clip_rect)
        {
            if (ReferenceEquals(clip_rect_min, null))
                throw new global::System.ArgumentNullException("clip_rect_min", "Cannot be null because it is passed by value.");
            var __arg0 = clip_rect_min.__Instance;
            if (ReferenceEquals(clip_rect_max, null))
                throw new global::System.ArgumentNullException("clip_rect_max", "Cannot be null because it is passed by value.");
            var __arg1 = clip_rect_max.__Instance;
            __Internal.PushClipRect(*(global::ImGuiSharp.ImVec2.__Internal*) __arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, intersect_with_current_clip_rect);
        }

        public static void PopClipRect()
        {
            __Internal.PopClipRect();
        }

        public static void SetItemDefaultFocus()
        {
            __Internal.SetItemDefaultFocus();
        }

        public static void SetKeyboardFocusHere(int offset)
        {
            __Internal.SetKeyboardFocusHere(offset);
        }

        public static bool IsItemHovered(int flags)
        {
            var __ret = __Internal.IsItemHovered(flags);
            return __ret;
        }

        public static bool IsItemActive()
        {
            var __ret = __Internal.IsItemActive();
            return __ret;
        }

        public static bool IsItemFocused()
        {
            var __ret = __Internal.IsItemFocused();
            return __ret;
        }

        public static bool IsItemClicked(int mouse_button)
        {
            var __ret = __Internal.IsItemClicked(mouse_button);
            return __ret;
        }

        public static bool IsItemVisible()
        {
            var __ret = __Internal.IsItemVisible();
            return __ret;
        }

        public static bool IsItemEdited()
        {
            var __ret = __Internal.IsItemEdited();
            return __ret;
        }

        public static bool IsItemActivated()
        {
            var __ret = __Internal.IsItemActivated();
            return __ret;
        }

        public static bool IsItemDeactivated()
        {
            var __ret = __Internal.IsItemDeactivated();
            return __ret;
        }

        public static bool IsItemDeactivatedAfterEdit()
        {
            var __ret = __Internal.IsItemDeactivatedAfterEdit();
            return __ret;
        }

        public static bool IsItemToggledOpen()
        {
            var __ret = __Internal.IsItemToggledOpen();
            return __ret;
        }

        public static bool IsAnyItemHovered()
        {
            var __ret = __Internal.IsAnyItemHovered();
            return __ret;
        }

        public static bool IsAnyItemActive()
        {
            var __ret = __Internal.IsAnyItemActive();
            return __ret;
        }

        public static bool IsAnyItemFocused()
        {
            var __ret = __Internal.IsAnyItemFocused();
            return __ret;
        }

        public static void GetItemRectMin(global::ImGuiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetItemRectMin(__arg0);
        }

        public static void GetItemRectMax(global::ImGuiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetItemRectMax(__arg0);
        }

        public static void GetItemRectSize(global::ImGuiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetItemRectSize(__arg0);
        }

        public static void SetItemAllowOverlap()
        {
            __Internal.SetItemAllowOverlap();
        }

        public static global::ImGuiSharp.ImGuiViewport GetMainViewport()
        {
            var __ret = __Internal.GetMainViewport();
            var __result0 = global::ImGuiSharp.ImGuiViewport.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static bool IsRectVisibleNil(global::ImGuiSharp.ImVec2 size)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg0 = size.__Instance;
            var __ret = __Internal.IsRectVisibleNil(*(global::ImGuiSharp.ImVec2.__Internal*) __arg0);
            return __ret;
        }

        public static bool IsRectVisibleVec2(global::ImGuiSharp.ImVec2 rect_min, global::ImGuiSharp.ImVec2 rect_max)
        {
            if (ReferenceEquals(rect_min, null))
                throw new global::System.ArgumentNullException("rect_min", "Cannot be null because it is passed by value.");
            var __arg0 = rect_min.__Instance;
            if (ReferenceEquals(rect_max, null))
                throw new global::System.ArgumentNullException("rect_max", "Cannot be null because it is passed by value.");
            var __arg1 = rect_max.__Instance;
            var __ret = __Internal.IsRectVisibleVec2(*(global::ImGuiSharp.ImVec2.__Internal*) __arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1);
            return __ret;
        }

        public static double GetTime()
        {
            var __ret = __Internal.GetTime();
            return __ret;
        }

        public static int GetFrameCount()
        {
            var __ret = __Internal.GetFrameCount();
            return __ret;
        }

        public static global::ImGuiSharp.ImDrawList GetBackgroundDrawListNil()
        {
            var __ret = __Internal.GetBackgroundDrawListNil();
            var __result0 = global::ImGuiSharp.ImDrawList.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::ImGuiSharp.ImDrawList GetForegroundDrawListNil()
        {
            var __ret = __Internal.GetForegroundDrawListNil();
            var __result0 = global::ImGuiSharp.ImDrawList.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::ImGuiSharp.ImDrawListSharedData GetDrawListSharedData()
        {
            var __ret = __Internal.GetDrawListSharedData();
            var __result0 = global::ImGuiSharp.ImDrawListSharedData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static string GetStyleColorName(int idx)
        {
            var __ret = __Internal.GetStyleColorName(idx);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static void SetStateStorage(global::ImGuiSharp.ImGuiStorage storage)
        {
            var __arg0 = storage is null ? __IntPtr.Zero : storage.__Instance;
            __Internal.SetStateStorage(__arg0);
        }

        public static global::ImGuiSharp.ImGuiStorage GetStateStorage()
        {
            var __ret = __Internal.GetStateStorage();
            var __result0 = global::ImGuiSharp.ImGuiStorage.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static bool BeginChildFrame(uint id, global::ImGuiSharp.ImVec2 size, int flags)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            var __ret = __Internal.BeginChildFrame(id, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, flags);
            return __ret;
        }

        public static void EndChildFrame()
        {
            __Internal.EndChildFrame();
        }

        public static void CalcTextSize(global::ImGuiSharp.ImVec2 pOut, string text, string text_end, bool hide_text_after_double_hash, float wrap_width)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.CalcTextSize(__arg0, text, text_end, hide_text_after_double_hash, wrap_width);
        }

        public static void ColorConvertU32ToFloat4(global::ImGuiSharp.ImVec4 pOut, uint @in)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.ColorConvertU32ToFloat4(__arg0, @in);
        }

        public static uint ColorConvertFloat4ToU32(global::ImGuiSharp.ImVec4 @in)
        {
            if (ReferenceEquals(@in, null))
                throw new global::System.ArgumentNullException("@in", "Cannot be null because it is passed by value.");
            var __arg0 = @in.__Instance;
            var __ret = __Internal.ColorConvertFloat4ToU32(*(global::ImGuiSharp.ImVec4.__Internal*) __arg0);
            return __ret;
        }

        public static void ColorConvertRGBtoHSV(float r, float g, float b, ref float out_h, ref float out_s, ref float out_v)
        {
            fixed (float* __out_h3 = &out_h)
            {
                var __arg3 = __out_h3;
                fixed (float* __out_s4 = &out_s)
                {
                    var __arg4 = __out_s4;
                    fixed (float* __out_v5 = &out_v)
                    {
                        var __arg5 = __out_v5;
                        __Internal.ColorConvertRGBtoHSV(r, g, b, __arg3, __arg4, __arg5);
                    }
                }
            }
        }

        public static void ColorConvertHSVtoRGB(float h, float s, float v, ref float out_r, ref float out_g, ref float out_b)
        {
            fixed (float* __out_r3 = &out_r)
            {
                var __arg3 = __out_r3;
                fixed (float* __out_g4 = &out_g)
                {
                    var __arg4 = __out_g4;
                    fixed (float* __out_b5 = &out_b)
                    {
                        var __arg5 = __out_b5;
                        __Internal.ColorConvertHSVtoRGB(h, s, v, __arg3, __arg4, __arg5);
                    }
                }
            }
        }

        public static bool IsKeyDown(int key)
        {
            var __ret = __Internal.IsKeyDown(key);
            return __ret;
        }

        public static bool IsKeyPressed(int key, bool repeat)
        {
            var __ret = __Internal.IsKeyPressed(key, repeat);
            return __ret;
        }

        public static bool IsKeyReleased(int key)
        {
            var __ret = __Internal.IsKeyReleased(key);
            return __ret;
        }

        public static int GetKeyPressedAmount(int key, float repeat_delay, float rate)
        {
            var __ret = __Internal.GetKeyPressedAmount(key, repeat_delay, rate);
            return __ret;
        }

        public static string GetKeyName(int key)
        {
            var __ret = __Internal.GetKeyName(key);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static void CaptureKeyboardFromApp(bool want_capture_keyboard_value)
        {
            __Internal.CaptureKeyboardFromApp(want_capture_keyboard_value);
        }

        public static bool IsMouseDown(int button)
        {
            var __ret = __Internal.IsMouseDown(button);
            return __ret;
        }

        public static bool IsMouseClicked(int button, bool repeat)
        {
            var __ret = __Internal.IsMouseClicked(button, repeat);
            return __ret;
        }

        public static bool IsMouseReleased(int button)
        {
            var __ret = __Internal.IsMouseReleased(button);
            return __ret;
        }

        public static bool IsMouseDoubleClicked(int button)
        {
            var __ret = __Internal.IsMouseDoubleClicked(button);
            return __ret;
        }

        public static int GetMouseClickedCount(int button)
        {
            var __ret = __Internal.GetMouseClickedCount(button);
            return __ret;
        }

        public static bool IsMouseHoveringRect(global::ImGuiSharp.ImVec2 r_min, global::ImGuiSharp.ImVec2 r_max, bool clip)
        {
            if (ReferenceEquals(r_min, null))
                throw new global::System.ArgumentNullException("r_min", "Cannot be null because it is passed by value.");
            var __arg0 = r_min.__Instance;
            if (ReferenceEquals(r_max, null))
                throw new global::System.ArgumentNullException("r_max", "Cannot be null because it is passed by value.");
            var __arg1 = r_max.__Instance;
            var __ret = __Internal.IsMouseHoveringRect(*(global::ImGuiSharp.ImVec2.__Internal*) __arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, clip);
            return __ret;
        }

        public static bool IsMousePosValid(global::ImGuiSharp.ImVec2 mouse_pos)
        {
            var __arg0 = mouse_pos is null ? __IntPtr.Zero : mouse_pos.__Instance;
            var __ret = __Internal.IsMousePosValid(__arg0);
            return __ret;
        }

        public static bool IsAnyMouseDown()
        {
            var __ret = __Internal.IsAnyMouseDown();
            return __ret;
        }

        public static void GetMousePos(global::ImGuiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetMousePos(__arg0);
        }

        public static void GetMousePosOnOpeningCurrentPopup(global::ImGuiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetMousePosOnOpeningCurrentPopup(__arg0);
        }

        public static bool IsMouseDragging(int button, float lock_threshold)
        {
            var __ret = __Internal.IsMouseDragging(button, lock_threshold);
            return __ret;
        }

        public static void GetMouseDragDelta(global::ImGuiSharp.ImVec2 pOut, int button, float lock_threshold)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetMouseDragDelta(__arg0, button, lock_threshold);
        }

        public static void ResetMouseDragDelta(int button)
        {
            __Internal.ResetMouseDragDelta(button);
        }

        public static int GetMouseCursor()
        {
            var __ret = __Internal.GetMouseCursor();
            return __ret;
        }

        public static void SetMouseCursor(int cursor_type)
        {
            __Internal.SetMouseCursor(cursor_type);
        }

        public static void CaptureMouseFromApp(bool want_capture_mouse_value)
        {
            __Internal.CaptureMouseFromApp(want_capture_mouse_value);
        }

        public static string GetClipboardText()
        {
            var __ret = __Internal.GetClipboardText();
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static void SetClipboardText(string text)
        {
            __Internal.SetClipboardText(text);
        }

        public static void LoadIniSettingsFromDisk(string ini_filename)
        {
            __Internal.LoadIniSettingsFromDisk(ini_filename);
        }

        public static void LoadIniSettingsFromMemory(string ini_data, IntPtr ini_size)
        {
            __Internal.LoadIniSettingsFromMemory(ini_data, ini_size);
        }

        public static void SaveIniSettingsToDisk(string ini_filename)
        {
            __Internal.SaveIniSettingsToDisk(ini_filename);
        }

        public static string SaveIniSettingsToMemory(ref IntPtr out_ini_size)
        {
            fixed (IntPtr* __out_ini_size0 = &out_ini_size)
            {
                var __arg0 = __out_ini_size0;
                var __ret = __Internal.SaveIniSettingsToMemory(__arg0);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
            }
        }

        public static bool DebugCheckVersionAndDataLayout(string version_str, IntPtr sz_io, IntPtr sz_style, IntPtr sz_vec2, IntPtr sz_vec4, IntPtr sz_drawvert, IntPtr sz_drawidx)
        {
            var __ret = __Internal.DebugCheckVersionAndDataLayout(version_str, sz_io, sz_style, sz_vec2, sz_vec4, sz_drawvert, sz_drawidx);
            return __ret;
        }

        public static void SetAllocatorFunctions(global::ImGuiSharp.ImGuiMemAllocFunc alloc_func, global::ImGuiSharp.ImGuiMemFreeFunc free_func, __IntPtr user_data)
        {
            var __arg0 = alloc_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(alloc_func);
            var __arg1 = free_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(free_func);
            __Internal.SetAllocatorFunctions(__arg0, __arg1, user_data);
        }

        public static void GetAllocatorFunctions(global::ImGuiSharp.ImGuiMemAllocFunc p_alloc_func, global::ImGuiSharp.ImGuiMemFreeFunc p_free_func, __IntPtr* p_user_data)
        {
            var __arg0 = p_alloc_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(p_alloc_func);
            var __arg1 = p_free_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(p_free_func);
            __Internal.GetAllocatorFunctions(__arg0, __arg1, p_user_data);
        }

        public static __IntPtr MemAlloc(IntPtr size)
        {
            var __ret = __Internal.MemAlloc(size);
            return __ret;
        }

        public static void MemFree(__IntPtr ptr)
        {
            __Internal.MemFree(ptr);
        }

        public static global::ImGuiSharp.ImGuiStyle ImGuiStyleImGuiStyle()
        {
            var __ret = __Internal.ImGuiStyleImGuiStyle();
            var __result0 = global::ImGuiSharp.ImGuiStyle.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiStyle_destroy(global::ImGuiSharp.ImGuiStyle self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStyle_destroy(__arg0);
        }

        public static void ImGuiStyleScaleAllSizes(global::ImGuiSharp.ImGuiStyle self, float scale_factor)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStyleScaleAllSizes(__arg0, scale_factor);
        }

        public static void ImGuiIO_AddKeyEvent(global::ImGuiSharp.ImGuiIO self, int key, bool down)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_AddKeyEvent(__arg0, key, down);
        }

        public static void ImGuiIO_AddKeyAnalogEvent(global::ImGuiSharp.ImGuiIO self, int key, bool down, float v)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_AddKeyAnalogEvent(__arg0, key, down, v);
        }

        public static void ImGuiIO_AddMousePosEvent(global::ImGuiSharp.ImGuiIO self, float x, float y)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_AddMousePosEvent(__arg0, x, y);
        }

        public static void ImGuiIO_AddMouseButtonEvent(global::ImGuiSharp.ImGuiIO self, int button, bool down)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_AddMouseButtonEvent(__arg0, button, down);
        }

        public static void ImGuiIO_AddMouseWheelEvent(global::ImGuiSharp.ImGuiIO self, float wh_x, float wh_y)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_AddMouseWheelEvent(__arg0, wh_x, wh_y);
        }

        public static void ImGuiIO_AddFocusEvent(global::ImGuiSharp.ImGuiIO self, bool focused)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_AddFocusEvent(__arg0, focused);
        }

        public static void ImGuiIO_AddInputCharacter(global::ImGuiSharp.ImGuiIO self, uint c)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_AddInputCharacter(__arg0, c);
        }

        public static void ImGuiIO_AddInputCharacterUTF16(global::ImGuiSharp.ImGuiIO self, ushort c)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_AddInputCharacterUTF16(__arg0, c);
        }

        public static void ImGuiIO_AddInputCharactersUTF8(global::ImGuiSharp.ImGuiIO self, string str)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_AddInputCharactersUTF8(__arg0, str);
        }

        public static void ImGuiIO_ClearInputCharacters(global::ImGuiSharp.ImGuiIO self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_ClearInputCharacters(__arg0);
        }

        public static void ImGuiIO_ClearInputKeys(global::ImGuiSharp.ImGuiIO self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_ClearInputKeys(__arg0);
        }

        public static void ImGuiIO_SetKeyEventNativeData(global::ImGuiSharp.ImGuiIO self, int key, int native_keycode, int native_scancode, int native_legacy_index)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_SetKeyEventNativeData(__arg0, key, native_keycode, native_scancode, native_legacy_index);
        }

        public static global::ImGuiSharp.ImGuiIO ImGuiIO_ImGuiIO()
        {
            var __ret = __Internal.ImGuiIO_ImGuiIO();
            var __result0 = global::ImGuiSharp.ImGuiIO.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiIO_destroy(global::ImGuiSharp.ImGuiIO self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImGuiInputTextCallbackData ImGuiInputTextCallbackDataImGuiInputTextCallbackData()
        {
            var __ret = __Internal.ImGuiInputTextCallbackDataImGuiInputTextCallbackData();
            var __result0 = global::ImGuiSharp.ImGuiInputTextCallbackData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiInputTextCallbackData_destroy(global::ImGuiSharp.ImGuiInputTextCallbackData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextCallbackData_destroy(__arg0);
        }

        public static void ImGuiInputTextCallbackDataDeleteChars(global::ImGuiSharp.ImGuiInputTextCallbackData self, int pos, int bytes_count)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextCallbackDataDeleteChars(__arg0, pos, bytes_count);
        }

        public static void ImGuiInputTextCallbackDataInsertChars(global::ImGuiSharp.ImGuiInputTextCallbackData self, int pos, string text, string text_end)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextCallbackDataInsertChars(__arg0, pos, text, text_end);
        }

        public static void ImGuiInputTextCallbackDataSelectAll(global::ImGuiSharp.ImGuiInputTextCallbackData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextCallbackDataSelectAll(__arg0);
        }

        public static void ImGuiInputTextCallbackDataClearSelection(global::ImGuiSharp.ImGuiInputTextCallbackData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextCallbackDataClearSelection(__arg0);
        }

        public static bool ImGuiInputTextCallbackDataHasSelection(global::ImGuiSharp.ImGuiInputTextCallbackData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiInputTextCallbackDataHasSelection(__arg0);
            return __ret;
        }

        public static global::ImGuiSharp.ImGuiPayload ImGuiPayloadImGuiPayload()
        {
            var __ret = __Internal.ImGuiPayloadImGuiPayload();
            var __result0 = global::ImGuiSharp.ImGuiPayload.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiPayload_destroy(global::ImGuiSharp.ImGuiPayload self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiPayload_destroy(__arg0);
        }

        public static void ImGuiPayloadClear(global::ImGuiSharp.ImGuiPayload self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiPayloadClear(__arg0);
        }

        public static bool ImGuiPayloadIsDataType(global::ImGuiSharp.ImGuiPayload self, string type)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiPayloadIsDataType(__arg0, type);
            return __ret;
        }

        public static bool ImGuiPayloadIsPreview(global::ImGuiSharp.ImGuiPayload self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiPayloadIsPreview(__arg0);
            return __ret;
        }

        public static bool ImGuiPayloadIsDelivery(global::ImGuiSharp.ImGuiPayload self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiPayloadIsDelivery(__arg0);
            return __ret;
        }

        public static global::ImGuiSharp.ImGuiTableColumnSortSpecs ImGuiTableColumnSortSpecsImGuiTableColumnSortSpecs()
        {
            var __ret = __Internal.ImGuiTableColumnSortSpecsImGuiTableColumnSortSpecs();
            var __result0 = global::ImGuiSharp.ImGuiTableColumnSortSpecs.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiTableColumnSortSpecs_destroy(global::ImGuiSharp.ImGuiTableColumnSortSpecs self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTableColumnSortSpecs_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImGuiTableSortSpecs ImGuiTableSortSpecsImGuiTableSortSpecs()
        {
            var __ret = __Internal.ImGuiTableSortSpecsImGuiTableSortSpecs();
            var __result0 = global::ImGuiSharp.ImGuiTableSortSpecs.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiTableSortSpecs_destroy(global::ImGuiSharp.ImGuiTableSortSpecs self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTableSortSpecs_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImGuiOnceUponAFrame ImGuiOnceUponAFrameImGuiOnceUponAFrame()
        {
            var __ret = __Internal.ImGuiOnceUponAFrameImGuiOnceUponAFrame();
            var __result0 = global::ImGuiSharp.ImGuiOnceUponAFrame.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiOnceUponAFrame_destroy(global::ImGuiSharp.ImGuiOnceUponAFrame self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiOnceUponAFrame_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImGuiTextFilter ImGuiTextFilterImGuiTextFilter(string default_filter)
        {
            var __ret = __Internal.ImGuiTextFilterImGuiTextFilter(default_filter);
            var __result0 = global::ImGuiSharp.ImGuiTextFilter.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiTextFilter_destroy(global::ImGuiSharp.ImGuiTextFilter self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTextFilter_destroy(__arg0);
        }

        public static bool ImGuiTextFilterDraw(global::ImGuiSharp.ImGuiTextFilter self, string label, float width)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextFilterDraw(__arg0, label, width);
            return __ret;
        }

        public static bool ImGuiTextFilterPassFilter(global::ImGuiSharp.ImGuiTextFilter self, string text, string text_end)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextFilterPassFilter(__arg0, text, text_end);
            return __ret;
        }

        public static void ImGuiTextFilterBuild(global::ImGuiSharp.ImGuiTextFilter self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTextFilterBuild(__arg0);
        }

        public static void ImGuiTextFilterClear(global::ImGuiSharp.ImGuiTextFilter self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTextFilterClear(__arg0);
        }

        public static bool ImGuiTextFilterIsActive(global::ImGuiSharp.ImGuiTextFilter self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextFilterIsActive(__arg0);
            return __ret;
        }

        public static global::ImGuiSharp.ImGuiTextRange ImGuiTextRangeImGuiTextRangeNil()
        {
            var __ret = __Internal.ImGuiTextRangeImGuiTextRangeNil();
            var __result0 = global::ImGuiSharp.ImGuiTextRange.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiTextRange_destroy(global::ImGuiSharp.ImGuiTextRange self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTextRange_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImGuiTextRange ImGuiTextRangeImGuiTextRangeStr(string _b, string _e)
        {
            var __ret = __Internal.ImGuiTextRangeImGuiTextRangeStr(_b, _e);
            var __result0 = global::ImGuiSharp.ImGuiTextRange.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static bool ImGuiTextRange_empty(global::ImGuiSharp.ImGuiTextRange self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextRange_empty(__arg0);
            return __ret;
        }

        public static void ImGuiTextRange_split(global::ImGuiSharp.ImGuiTextRange self, sbyte separator, global::ImGuiSharp.ImVectorImGuiTextRange @out)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg2 = @out is null ? __IntPtr.Zero : @out.__Instance;
            __Internal.ImGuiTextRange_split(__arg0, separator, __arg2);
        }

        public static global::ImGuiSharp.ImGuiTextBuffer ImGuiTextBufferImGuiTextBuffer()
        {
            var __ret = __Internal.ImGuiTextBufferImGuiTextBuffer();
            var __result0 = global::ImGuiSharp.ImGuiTextBuffer.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiTextBuffer_destroy(global::ImGuiSharp.ImGuiTextBuffer self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTextBuffer_destroy(__arg0);
        }

        public static string ImGuiTextBuffer_begin(global::ImGuiSharp.ImGuiTextBuffer self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextBuffer_begin(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static string ImGuiTextBuffer_end(global::ImGuiSharp.ImGuiTextBuffer self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextBuffer_end(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static int ImGuiTextBuffer_size(global::ImGuiSharp.ImGuiTextBuffer self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextBuffer_size(__arg0);
            return __ret;
        }

        public static bool ImGuiTextBuffer_empty(global::ImGuiSharp.ImGuiTextBuffer self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextBuffer_empty(__arg0);
            return __ret;
        }

        public static void ImGuiTextBuffer_clear(global::ImGuiSharp.ImGuiTextBuffer self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTextBuffer_clear(__arg0);
        }

        public static void ImGuiTextBuffer_reserve(global::ImGuiSharp.ImGuiTextBuffer self, int capacity)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTextBuffer_reserve(__arg0, capacity);
        }

        public static string ImGuiTextBuffer_c_str(global::ImGuiSharp.ImGuiTextBuffer self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextBuffer_c_str(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static void ImGuiTextBuffer_append(global::ImGuiSharp.ImGuiTextBuffer self, string str, string str_end)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTextBuffer_append(__arg0, str, str_end);
        }

        public static global::ImGuiSharp.ImGuiStoragePair ImGuiStoragePairImGuiStoragePairInt(uint _key, int _val_i)
        {
            var __ret = __Internal.ImGuiStoragePairImGuiStoragePairInt(_key, _val_i);
            var __result0 = global::ImGuiSharp.ImGuiStoragePair.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiStoragePair_destroy(global::ImGuiSharp.ImGuiStoragePair self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStoragePair_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImGuiStoragePair ImGuiStoragePairImGuiStoragePairFloat(uint _key, float _val_f)
        {
            var __ret = __Internal.ImGuiStoragePairImGuiStoragePairFloat(_key, _val_f);
            var __result0 = global::ImGuiSharp.ImGuiStoragePair.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::ImGuiSharp.ImGuiStoragePair ImGuiStoragePairImGuiStoragePairPtr(uint _key, __IntPtr _val_p)
        {
            var __ret = __Internal.ImGuiStoragePairImGuiStoragePairPtr(_key, _val_p);
            var __result0 = global::ImGuiSharp.ImGuiStoragePair.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiStorageClear(global::ImGuiSharp.ImGuiStorage self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStorageClear(__arg0);
        }

        public static int ImGuiStorageGetInt(global::ImGuiSharp.ImGuiStorage self, uint key, int default_val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiStorageGetInt(__arg0, key, default_val);
            return __ret;
        }

        public static void ImGuiStorageSetInt(global::ImGuiSharp.ImGuiStorage self, uint key, int val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStorageSetInt(__arg0, key, val);
        }

        public static bool ImGuiStorageGetBool(global::ImGuiSharp.ImGuiStorage self, uint key, bool default_val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiStorageGetBool(__arg0, key, default_val);
            return __ret;
        }

        public static void ImGuiStorageSetBool(global::ImGuiSharp.ImGuiStorage self, uint key, bool val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStorageSetBool(__arg0, key, val);
        }

        public static float ImGuiStorageGetFloat(global::ImGuiSharp.ImGuiStorage self, uint key, float default_val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiStorageGetFloat(__arg0, key, default_val);
            return __ret;
        }

        public static void ImGuiStorageSetFloat(global::ImGuiSharp.ImGuiStorage self, uint key, float val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStorageSetFloat(__arg0, key, val);
        }

        public static __IntPtr ImGuiStorageGetVoidPtr(global::ImGuiSharp.ImGuiStorage self, uint key)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiStorageGetVoidPtr(__arg0, key);
            return __ret;
        }

        public static void ImGuiStorageSetVoidPtr(global::ImGuiSharp.ImGuiStorage self, uint key, __IntPtr val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStorageSetVoidPtr(__arg0, key, val);
        }

        public static int* ImGuiStorageGetIntRef(global::ImGuiSharp.ImGuiStorage self, uint key, int default_val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiStorageGetIntRef(__arg0, key, default_val);
            return __ret;
        }

        public static bool* ImGuiStorageGetBoolRef(global::ImGuiSharp.ImGuiStorage self, uint key, bool default_val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiStorageGetBoolRef(__arg0, key, default_val);
            return __ret;
        }

        public static float* ImGuiStorageGetFloatRef(global::ImGuiSharp.ImGuiStorage self, uint key, float default_val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiStorageGetFloatRef(__arg0, key, default_val);
            return __ret;
        }

        public static __IntPtr* ImGuiStorageGetVoidPtrRef(global::ImGuiSharp.ImGuiStorage self, uint key, __IntPtr default_val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiStorageGetVoidPtrRef(__arg0, key, default_val);
            return __ret;
        }

        public static void ImGuiStorageSetAllInt(global::ImGuiSharp.ImGuiStorage self, int val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStorageSetAllInt(__arg0, val);
        }

        public static void ImGuiStorageBuildSortByKey(global::ImGuiSharp.ImGuiStorage self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStorageBuildSortByKey(__arg0);
        }

        public static global::ImGuiSharp.ImGuiListClipper ImGuiListClipperImGuiListClipper()
        {
            var __ret = __Internal.ImGuiListClipperImGuiListClipper();
            var __result0 = global::ImGuiSharp.ImGuiListClipper.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiListClipper_destroy(global::ImGuiSharp.ImGuiListClipper self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiListClipper_destroy(__arg0);
        }

        public static void ImGuiListClipperBegin(global::ImGuiSharp.ImGuiListClipper self, int items_count, float items_height)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiListClipperBegin(__arg0, items_count, items_height);
        }

        public static void ImGuiListClipperEnd(global::ImGuiSharp.ImGuiListClipper self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiListClipperEnd(__arg0);
        }

        public static bool ImGuiListClipperStep(global::ImGuiSharp.ImGuiListClipper self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiListClipperStep(__arg0);
            return __ret;
        }

        public static void ImGuiListClipperForceDisplayRangeByIndices(global::ImGuiSharp.ImGuiListClipper self, int item_min, int item_max)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiListClipperForceDisplayRangeByIndices(__arg0, item_min, item_max);
        }

        public static global::ImGuiSharp.ImColor ImColorImColorNil()
        {
            var __ret = __Internal.ImColorImColorNil();
            var __result0 = global::ImGuiSharp.ImColor.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImColor_destroy(global::ImGuiSharp.ImColor self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImColor_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImColor ImColorImColorInt(int r, int g, int b, int a)
        {
            var __ret = __Internal.ImColorImColorInt(r, g, b, a);
            var __result0 = global::ImGuiSharp.ImColor.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::ImGuiSharp.ImColor ImColorImColorU32(uint rgba)
        {
            var __ret = __Internal.ImColorImColorU32(rgba);
            var __result0 = global::ImGuiSharp.ImColor.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::ImGuiSharp.ImColor ImColorImColorFloat(float r, float g, float b, float a)
        {
            var __ret = __Internal.ImColorImColorFloat(r, g, b, a);
            var __result0 = global::ImGuiSharp.ImColor.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::ImGuiSharp.ImColor ImColorImColorVec4(global::ImGuiSharp.ImVec4 col)
        {
            if (ReferenceEquals(col, null))
                throw new global::System.ArgumentNullException("col", "Cannot be null because it is passed by value.");
            var __arg0 = col.__Instance;
            var __ret = __Internal.ImColorImColorVec4(*(global::ImGuiSharp.ImVec4.__Internal*) __arg0);
            var __result0 = global::ImGuiSharp.ImColor.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImColorSetHSV(global::ImGuiSharp.ImColor self, float h, float s, float v, float a)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImColorSetHSV(__arg0, h, s, v, a);
        }

        public static void ImColorHSV(global::ImGuiSharp.ImColor pOut, float h, float s, float v, float a)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.ImColorHSV(__arg0, h, s, v, a);
        }

        public static global::ImGuiSharp.ImDrawCmd ImDrawCmdImDrawCmd()
        {
            var __ret = __Internal.ImDrawCmdImDrawCmd();
            var __result0 = global::ImGuiSharp.ImDrawCmd.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImDrawCmd_destroy(global::ImGuiSharp.ImDrawCmd self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawCmd_destroy(__arg0);
        }

        public static __IntPtr ImDrawCmdGetTexID(global::ImGuiSharp.ImDrawCmd self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImDrawCmdGetTexID(__arg0);
            return __ret;
        }

        public static global::ImGuiSharp.ImDrawListSplitter ImDrawListSplitterImDrawListSplitter()
        {
            var __ret = __Internal.ImDrawListSplitterImDrawListSplitter();
            var __result0 = global::ImGuiSharp.ImDrawListSplitter.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImDrawListSplitter_destroy(global::ImGuiSharp.ImDrawListSplitter self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListSplitter_destroy(__arg0);
        }

        public static void ImDrawListSplitterClear(global::ImGuiSharp.ImDrawListSplitter self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListSplitterClear(__arg0);
        }

        public static void ImDrawListSplitterClearFreeMemory(global::ImGuiSharp.ImDrawListSplitter self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListSplitterClearFreeMemory(__arg0);
        }

        public static void ImDrawListSplitterSplit(global::ImGuiSharp.ImDrawListSplitter self, global::ImGuiSharp.ImDrawList draw_list, int count)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            __Internal.ImDrawListSplitterSplit(__arg0, __arg1, count);
        }

        public static void ImDrawListSplitterMerge(global::ImGuiSharp.ImDrawListSplitter self, global::ImGuiSharp.ImDrawList draw_list)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            __Internal.ImDrawListSplitterMerge(__arg0, __arg1);
        }

        public static void ImDrawListSplitterSetCurrentChannel(global::ImGuiSharp.ImDrawListSplitter self, global::ImGuiSharp.ImDrawList draw_list, int channel_idx)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            __Internal.ImDrawListSplitterSetCurrentChannel(__arg0, __arg1, channel_idx);
        }

        public static global::ImGuiSharp.ImDrawList ImDrawListImDrawList(global::ImGuiSharp.ImDrawListSharedData shared_data)
        {
            var __arg0 = shared_data is null ? __IntPtr.Zero : shared_data.__Instance;
            var __ret = __Internal.ImDrawListImDrawList(__arg0);
            var __result0 = global::ImGuiSharp.ImDrawList.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImDrawList_destroy(global::ImGuiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawList_destroy(__arg0);
        }

        public static void ImDrawListPushClipRect(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImVec2 clip_rect_min, global::ImGuiSharp.ImVec2 clip_rect_max, bool intersect_with_current_clip_rect)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(clip_rect_min, null))
                throw new global::System.ArgumentNullException("clip_rect_min", "Cannot be null because it is passed by value.");
            var __arg1 = clip_rect_min.__Instance;
            if (ReferenceEquals(clip_rect_max, null))
                throw new global::System.ArgumentNullException("clip_rect_max", "Cannot be null because it is passed by value.");
            var __arg2 = clip_rect_max.__Instance;
            __Internal.ImDrawListPushClipRect(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, intersect_with_current_clip_rect);
        }

        public static void ImDrawListPushClipRectFullScreen(global::ImGuiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPushClipRectFullScreen(__arg0);
        }

        public static void ImDrawListPopClipRect(global::ImGuiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPopClipRect(__arg0);
        }

        public static void ImDrawListPushTextureID(global::ImGuiSharp.ImDrawList self, __IntPtr texture_id)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPushTextureID(__arg0, texture_id);
        }

        public static void ImDrawListPopTextureID(global::ImGuiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPopTextureID(__arg0);
        }

        public static void ImDrawListGetClipRectMin(global::ImGuiSharp.ImVec2 pOut, global::ImGuiSharp.ImDrawList self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListGetClipRectMin(__arg0, __arg1);
        }

        public static void ImDrawListGetClipRectMax(global::ImGuiSharp.ImVec2 pOut, global::ImGuiSharp.ImDrawList self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListGetClipRectMax(__arg0, __arg1);
        }

        public static void ImDrawListAddLine(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImVec2 p1, global::ImGuiSharp.ImVec2 p2, uint col, float thickness)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            __Internal.ImDrawListAddLine(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, col, thickness);
        }

        public static void ImDrawListAddRect(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImVec2 p_min, global::ImGuiSharp.ImVec2 p_max, uint col, float rounding, int flags, float thickness)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is passed by value.");
            var __arg1 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is passed by value.");
            var __arg2 = p_max.__Instance;
            __Internal.ImDrawListAddRect(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, col, rounding, flags, thickness);
        }

        public static void ImDrawListAddRectFilled(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImVec2 p_min, global::ImGuiSharp.ImVec2 p_max, uint col, float rounding, int flags)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is passed by value.");
            var __arg1 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is passed by value.");
            var __arg2 = p_max.__Instance;
            __Internal.ImDrawListAddRectFilled(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, col, rounding, flags);
        }

        public static void ImDrawListAddRectFilledMultiColor(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImVec2 p_min, global::ImGuiSharp.ImVec2 p_max, uint col_upr_left, uint col_upr_right, uint col_bot_right, uint col_bot_left)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is passed by value.");
            var __arg1 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is passed by value.");
            var __arg2 = p_max.__Instance;
            __Internal.ImDrawListAddRectFilledMultiColor(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, col_upr_left, col_upr_right, col_bot_right, col_bot_left);
        }

        public static void ImDrawListAddQuad(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImVec2 p1, global::ImGuiSharp.ImVec2 p2, global::ImGuiSharp.ImVec2 p3, global::ImGuiSharp.ImVec2 p4, uint col, float thickness)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is passed by value.");
            var __arg4 = p4.__Instance;
            __Internal.ImDrawListAddQuad(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3, *(global::ImGuiSharp.ImVec2.__Internal*) __arg4, col, thickness);
        }

        public static void ImDrawListAddQuadFilled(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImVec2 p1, global::ImGuiSharp.ImVec2 p2, global::ImGuiSharp.ImVec2 p3, global::ImGuiSharp.ImVec2 p4, uint col)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is passed by value.");
            var __arg4 = p4.__Instance;
            __Internal.ImDrawListAddQuadFilled(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3, *(global::ImGuiSharp.ImVec2.__Internal*) __arg4, col);
        }

        public static void ImDrawListAddTriangle(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImVec2 p1, global::ImGuiSharp.ImVec2 p2, global::ImGuiSharp.ImVec2 p3, uint col, float thickness)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            __Internal.ImDrawListAddTriangle(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3, col, thickness);
        }

        public static void ImDrawListAddTriangleFilled(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImVec2 p1, global::ImGuiSharp.ImVec2 p2, global::ImGuiSharp.ImVec2 p3, uint col)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            __Internal.ImDrawListAddTriangleFilled(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3, col);
        }

        public static void ImDrawListAddCircle(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImVec2 center, float radius, uint col, int num_segments, float thickness)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg1 = center.__Instance;
            __Internal.ImDrawListAddCircle(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, radius, col, num_segments, thickness);
        }

        public static void ImDrawListAddCircleFilled(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImVec2 center, float radius, uint col, int num_segments)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg1 = center.__Instance;
            __Internal.ImDrawListAddCircleFilled(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, radius, col, num_segments);
        }

        public static void ImDrawListAddNgon(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImVec2 center, float radius, uint col, int num_segments, float thickness)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg1 = center.__Instance;
            __Internal.ImDrawListAddNgon(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, radius, col, num_segments, thickness);
        }

        public static void ImDrawListAddNgonFilled(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImVec2 center, float radius, uint col, int num_segments)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg1 = center.__Instance;
            __Internal.ImDrawListAddNgonFilled(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, radius, col, num_segments);
        }

        public static void ImDrawListAddTextVec2(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImVec2 pos, uint col, string text_begin, string text_end)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            __Internal.ImDrawListAddTextVec2(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, col, text_begin, text_end);
        }

        public static void ImDrawListAddTextFontPtr(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImFont font, float font_size, global::ImGuiSharp.ImVec2 pos, uint col, string text_begin, string text_end, float wrap_width, global::ImGuiSharp.ImVec4 cpu_fine_clip_rect)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = font is null ? __IntPtr.Zero : font.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg3 = pos.__Instance;
            var __arg8 = cpu_fine_clip_rect is null ? __IntPtr.Zero : cpu_fine_clip_rect.__Instance;
            __Internal.ImDrawListAddTextFontPtr(__arg0, __arg1, font_size, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3, col, text_begin, text_end, wrap_width, __arg8);
        }

        public static void ImDrawListAddPolyline(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImVec2 points, int num_points, uint col, int flags, float thickness)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = points is null ? __IntPtr.Zero : points.__Instance;
            __Internal.ImDrawListAddPolyline(__arg0, __arg1, num_points, col, flags, thickness);
        }

        public static void ImDrawListAddConvexPolyFilled(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImVec2 points, int num_points, uint col)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = points is null ? __IntPtr.Zero : points.__Instance;
            __Internal.ImDrawListAddConvexPolyFilled(__arg0, __arg1, num_points, col);
        }

        public static void ImDrawListAddBezierCubic(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImVec2 p1, global::ImGuiSharp.ImVec2 p2, global::ImGuiSharp.ImVec2 p3, global::ImGuiSharp.ImVec2 p4, uint col, float thickness, int num_segments)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is passed by value.");
            var __arg4 = p4.__Instance;
            __Internal.ImDrawListAddBezierCubic(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3, *(global::ImGuiSharp.ImVec2.__Internal*) __arg4, col, thickness, num_segments);
        }

        public static void ImDrawListAddBezierQuadratic(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImVec2 p1, global::ImGuiSharp.ImVec2 p2, global::ImGuiSharp.ImVec2 p3, uint col, float thickness, int num_segments)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            __Internal.ImDrawListAddBezierQuadratic(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3, col, thickness, num_segments);
        }

        public static void ImDrawListAddImage(global::ImGuiSharp.ImDrawList self, __IntPtr user_texture_id, global::ImGuiSharp.ImVec2 p_min, global::ImGuiSharp.ImVec2 p_max, global::ImGuiSharp.ImVec2 uv_min, global::ImGuiSharp.ImVec2 uv_max, uint col)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is passed by value.");
            var __arg2 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is passed by value.");
            var __arg3 = p_max.__Instance;
            if (ReferenceEquals(uv_min, null))
                throw new global::System.ArgumentNullException("uv_min", "Cannot be null because it is passed by value.");
            var __arg4 = uv_min.__Instance;
            if (ReferenceEquals(uv_max, null))
                throw new global::System.ArgumentNullException("uv_max", "Cannot be null because it is passed by value.");
            var __arg5 = uv_max.__Instance;
            __Internal.ImDrawListAddImage(__arg0, user_texture_id, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3, *(global::ImGuiSharp.ImVec2.__Internal*) __arg4, *(global::ImGuiSharp.ImVec2.__Internal*) __arg5, col);
        }

        public static void ImDrawListAddImageQuad(global::ImGuiSharp.ImDrawList self, __IntPtr user_texture_id, global::ImGuiSharp.ImVec2 p1, global::ImGuiSharp.ImVec2 p2, global::ImGuiSharp.ImVec2 p3, global::ImGuiSharp.ImVec2 p4, global::ImGuiSharp.ImVec2 uv1, global::ImGuiSharp.ImVec2 uv2, global::ImGuiSharp.ImVec2 uv3, global::ImGuiSharp.ImVec2 uv4, uint col)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg2 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg3 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg4 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is passed by value.");
            var __arg5 = p4.__Instance;
            if (ReferenceEquals(uv1, null))
                throw new global::System.ArgumentNullException("uv1", "Cannot be null because it is passed by value.");
            var __arg6 = uv1.__Instance;
            if (ReferenceEquals(uv2, null))
                throw new global::System.ArgumentNullException("uv2", "Cannot be null because it is passed by value.");
            var __arg7 = uv2.__Instance;
            if (ReferenceEquals(uv3, null))
                throw new global::System.ArgumentNullException("uv3", "Cannot be null because it is passed by value.");
            var __arg8 = uv3.__Instance;
            if (ReferenceEquals(uv4, null))
                throw new global::System.ArgumentNullException("uv4", "Cannot be null because it is passed by value.");
            var __arg9 = uv4.__Instance;
            __Internal.ImDrawListAddImageQuad(__arg0, user_texture_id, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3, *(global::ImGuiSharp.ImVec2.__Internal*) __arg4, *(global::ImGuiSharp.ImVec2.__Internal*) __arg5, *(global::ImGuiSharp.ImVec2.__Internal*) __arg6, *(global::ImGuiSharp.ImVec2.__Internal*) __arg7, *(global::ImGuiSharp.ImVec2.__Internal*) __arg8, *(global::ImGuiSharp.ImVec2.__Internal*) __arg9, col);
        }

        public static void ImDrawListAddImageRounded(global::ImGuiSharp.ImDrawList self, __IntPtr user_texture_id, global::ImGuiSharp.ImVec2 p_min, global::ImGuiSharp.ImVec2 p_max, global::ImGuiSharp.ImVec2 uv_min, global::ImGuiSharp.ImVec2 uv_max, uint col, float rounding, int flags)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is passed by value.");
            var __arg2 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is passed by value.");
            var __arg3 = p_max.__Instance;
            if (ReferenceEquals(uv_min, null))
                throw new global::System.ArgumentNullException("uv_min", "Cannot be null because it is passed by value.");
            var __arg4 = uv_min.__Instance;
            if (ReferenceEquals(uv_max, null))
                throw new global::System.ArgumentNullException("uv_max", "Cannot be null because it is passed by value.");
            var __arg5 = uv_max.__Instance;
            __Internal.ImDrawListAddImageRounded(__arg0, user_texture_id, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3, *(global::ImGuiSharp.ImVec2.__Internal*) __arg4, *(global::ImGuiSharp.ImVec2.__Internal*) __arg5, col, rounding, flags);
        }

        public static void ImDrawListPathClear(global::ImGuiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPathClear(__arg0);
        }

        public static void ImDrawListPathLineTo(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImVec2 pos)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            __Internal.ImDrawListPathLineTo(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1);
        }

        public static void ImDrawListPathLineToMergeDuplicate(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImVec2 pos)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            __Internal.ImDrawListPathLineToMergeDuplicate(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1);
        }

        public static void ImDrawListPathFillConvex(global::ImGuiSharp.ImDrawList self, uint col)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPathFillConvex(__arg0, col);
        }

        public static void ImDrawListPathStroke(global::ImGuiSharp.ImDrawList self, uint col, int flags, float thickness)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPathStroke(__arg0, col, flags, thickness);
        }

        public static void ImDrawListPathArcTo(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImVec2 center, float radius, float a_min, float a_max, int num_segments)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg1 = center.__Instance;
            __Internal.ImDrawListPathArcTo(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, radius, a_min, a_max, num_segments);
        }

        public static void ImDrawListPathArcToFast(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImVec2 center, float radius, int a_min_of_12, int a_max_of_12)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg1 = center.__Instance;
            __Internal.ImDrawListPathArcToFast(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, radius, a_min_of_12, a_max_of_12);
        }

        public static void ImDrawListPathBezierCubicCurveTo(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImVec2 p2, global::ImGuiSharp.ImVec2 p3, global::ImGuiSharp.ImVec2 p4, int num_segments)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg1 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg2 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is passed by value.");
            var __arg3 = p4.__Instance;
            __Internal.ImDrawListPathBezierCubicCurveTo(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3, num_segments);
        }

        public static void ImDrawListPathBezierQuadraticCurveTo(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImVec2 p2, global::ImGuiSharp.ImVec2 p3, int num_segments)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg1 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg2 = p3.__Instance;
            __Internal.ImDrawListPathBezierQuadraticCurveTo(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, num_segments);
        }

        public static void ImDrawListPathRect(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImVec2 rect_min, global::ImGuiSharp.ImVec2 rect_max, float rounding, int flags)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(rect_min, null))
                throw new global::System.ArgumentNullException("rect_min", "Cannot be null because it is passed by value.");
            var __arg1 = rect_min.__Instance;
            if (ReferenceEquals(rect_max, null))
                throw new global::System.ArgumentNullException("rect_max", "Cannot be null because it is passed by value.");
            var __arg2 = rect_max.__Instance;
            __Internal.ImDrawListPathRect(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, rounding, flags);
        }

        public static void ImDrawListAddCallback(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImDrawCallback callback, __IntPtr callback_data)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            __Internal.ImDrawListAddCallback(__arg0, __arg1, callback_data);
        }

        public static void ImDrawListAddDrawCmd(global::ImGuiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListAddDrawCmd(__arg0);
        }

        public static global::ImGuiSharp.ImDrawList ImDrawListCloneOutput(global::ImGuiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImDrawListCloneOutput(__arg0);
            var __result0 = global::ImGuiSharp.ImDrawList.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImDrawListChannelsSplit(global::ImGuiSharp.ImDrawList self, int count)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListChannelsSplit(__arg0, count);
        }

        public static void ImDrawListChannelsMerge(global::ImGuiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListChannelsMerge(__arg0);
        }

        public static void ImDrawListChannelsSetCurrent(global::ImGuiSharp.ImDrawList self, int n)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListChannelsSetCurrent(__arg0, n);
        }

        public static void ImDrawListPrimReserve(global::ImGuiSharp.ImDrawList self, int idx_count, int vtx_count)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPrimReserve(__arg0, idx_count, vtx_count);
        }

        public static void ImDrawListPrimUnreserve(global::ImGuiSharp.ImDrawList self, int idx_count, int vtx_count)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPrimUnreserve(__arg0, idx_count, vtx_count);
        }

        public static void ImDrawListPrimRect(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImVec2 a, global::ImGuiSharp.ImVec2 b, uint col)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg1 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg2 = b.__Instance;
            __Internal.ImDrawListPrimRect(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, col);
        }

        public static void ImDrawListPrimRectUV(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImVec2 a, global::ImGuiSharp.ImVec2 b, global::ImGuiSharp.ImVec2 uv_a, global::ImGuiSharp.ImVec2 uv_b, uint col)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg1 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg2 = b.__Instance;
            if (ReferenceEquals(uv_a, null))
                throw new global::System.ArgumentNullException("uv_a", "Cannot be null because it is passed by value.");
            var __arg3 = uv_a.__Instance;
            if (ReferenceEquals(uv_b, null))
                throw new global::System.ArgumentNullException("uv_b", "Cannot be null because it is passed by value.");
            var __arg4 = uv_b.__Instance;
            __Internal.ImDrawListPrimRectUV(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3, *(global::ImGuiSharp.ImVec2.__Internal*) __arg4, col);
        }

        public static void ImDrawListPrimQuadUV(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImVec2 a, global::ImGuiSharp.ImVec2 b, global::ImGuiSharp.ImVec2 c, global::ImGuiSharp.ImVec2 d, global::ImGuiSharp.ImVec2 uv_a, global::ImGuiSharp.ImVec2 uv_b, global::ImGuiSharp.ImVec2 uv_c, global::ImGuiSharp.ImVec2 uv_d, uint col)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg1 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg2 = b.__Instance;
            if (ReferenceEquals(c, null))
                throw new global::System.ArgumentNullException("c", "Cannot be null because it is passed by value.");
            var __arg3 = c.__Instance;
            if (ReferenceEquals(d, null))
                throw new global::System.ArgumentNullException("d", "Cannot be null because it is passed by value.");
            var __arg4 = d.__Instance;
            if (ReferenceEquals(uv_a, null))
                throw new global::System.ArgumentNullException("uv_a", "Cannot be null because it is passed by value.");
            var __arg5 = uv_a.__Instance;
            if (ReferenceEquals(uv_b, null))
                throw new global::System.ArgumentNullException("uv_b", "Cannot be null because it is passed by value.");
            var __arg6 = uv_b.__Instance;
            if (ReferenceEquals(uv_c, null))
                throw new global::System.ArgumentNullException("uv_c", "Cannot be null because it is passed by value.");
            var __arg7 = uv_c.__Instance;
            if (ReferenceEquals(uv_d, null))
                throw new global::System.ArgumentNullException("uv_d", "Cannot be null because it is passed by value.");
            var __arg8 = uv_d.__Instance;
            __Internal.ImDrawListPrimQuadUV(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3, *(global::ImGuiSharp.ImVec2.__Internal*) __arg4, *(global::ImGuiSharp.ImVec2.__Internal*) __arg5, *(global::ImGuiSharp.ImVec2.__Internal*) __arg6, *(global::ImGuiSharp.ImVec2.__Internal*) __arg7, *(global::ImGuiSharp.ImVec2.__Internal*) __arg8, col);
        }

        public static void ImDrawListPrimWriteVtx(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImVec2 pos, global::ImGuiSharp.ImVec2 uv, uint col)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            if (ReferenceEquals(uv, null))
                throw new global::System.ArgumentNullException("uv", "Cannot be null because it is passed by value.");
            var __arg2 = uv.__Instance;
            __Internal.ImDrawListPrimWriteVtx(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, col);
        }

        public static void ImDrawListPrimWriteIdx(global::ImGuiSharp.ImDrawList self, ushort idx)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPrimWriteIdx(__arg0, idx);
        }

        public static void ImDrawListPrimVtx(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImVec2 pos, global::ImGuiSharp.ImVec2 uv, uint col)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            if (ReferenceEquals(uv, null))
                throw new global::System.ArgumentNullException("uv", "Cannot be null because it is passed by value.");
            var __arg2 = uv.__Instance;
            __Internal.ImDrawListPrimVtx(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, col);
        }

        public static void ImDrawListResetForNewFrame(global::ImGuiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListResetForNewFrame(__arg0);
        }

        public static void ImDrawListClearFreeMemory(global::ImGuiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListClearFreeMemory(__arg0);
        }

        public static void ImDrawListPopUnusedDrawCmd(global::ImGuiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPopUnusedDrawCmd(__arg0);
        }

        public static void ImDrawListTryMergeDrawCmds(global::ImGuiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListTryMergeDrawCmds(__arg0);
        }

        public static void ImDrawListOnChangedClipRect(global::ImGuiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListOnChangedClipRect(__arg0);
        }

        public static void ImDrawListOnChangedTextureID(global::ImGuiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListOnChangedTextureID(__arg0);
        }

        public static void ImDrawListOnChangedVtxOffset(global::ImGuiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListOnChangedVtxOffset(__arg0);
        }

        public static int ImDrawListCalcCircleAutoSegmentCount(global::ImGuiSharp.ImDrawList self, float radius)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImDrawListCalcCircleAutoSegmentCount(__arg0, radius);
            return __ret;
        }

        public static void ImDrawListPathArcToFastEx(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImVec2 center, float radius, int a_min_sample, int a_max_sample, int a_step)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg1 = center.__Instance;
            __Internal.ImDrawListPathArcToFastEx(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, radius, a_min_sample, a_max_sample, a_step);
        }

        public static void ImDrawListPathArcToN(global::ImGuiSharp.ImDrawList self, global::ImGuiSharp.ImVec2 center, float radius, float a_min, float a_max, int num_segments)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg1 = center.__Instance;
            __Internal.ImDrawListPathArcToN(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, radius, a_min, a_max, num_segments);
        }

        public static global::ImGuiSharp.ImDrawData ImDrawDataImDrawData()
        {
            var __ret = __Internal.ImDrawDataImDrawData();
            var __result0 = global::ImGuiSharp.ImDrawData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImDrawData_destroy(global::ImGuiSharp.ImDrawData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawData_destroy(__arg0);
        }

        public static void ImDrawDataClear(global::ImGuiSharp.ImDrawData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawDataClear(__arg0);
        }

        public static void ImDrawDataDeIndexAllBuffers(global::ImGuiSharp.ImDrawData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawDataDeIndexAllBuffers(__arg0);
        }

        public static void ImDrawDataScaleClipRects(global::ImGuiSharp.ImDrawData self, global::ImGuiSharp.ImVec2 fb_scale)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(fb_scale, null))
                throw new global::System.ArgumentNullException("fb_scale", "Cannot be null because it is passed by value.");
            var __arg1 = fb_scale.__Instance;
            __Internal.ImDrawDataScaleClipRects(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1);
        }

        public static global::ImGuiSharp.ImFontConfig ImFontConfigImFontConfig()
        {
            var __ret = __Internal.ImFontConfigImFontConfig();
            var __result0 = global::ImGuiSharp.ImFontConfig.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImFontConfig_destroy(global::ImGuiSharp.ImFontConfig self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontConfig_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImFontGlyphRangesBuilder ImFontGlyphRangesBuilderImFontGlyphRangesBuilder()
        {
            var __ret = __Internal.ImFontGlyphRangesBuilderImFontGlyphRangesBuilder();
            var __result0 = global::ImGuiSharp.ImFontGlyphRangesBuilder.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImFontGlyphRangesBuilder_destroy(global::ImGuiSharp.ImFontGlyphRangesBuilder self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontGlyphRangesBuilder_destroy(__arg0);
        }

        public static void ImFontGlyphRangesBuilderClear(global::ImGuiSharp.ImFontGlyphRangesBuilder self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontGlyphRangesBuilderClear(__arg0);
        }

        public static bool ImFontGlyphRangesBuilderGetBit(global::ImGuiSharp.ImFontGlyphRangesBuilder self, IntPtr n)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontGlyphRangesBuilderGetBit(__arg0, n);
            return __ret;
        }

        public static void ImFontGlyphRangesBuilderSetBit(global::ImGuiSharp.ImFontGlyphRangesBuilder self, IntPtr n)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontGlyphRangesBuilderSetBit(__arg0, n);
        }

        public static void ImFontGlyphRangesBuilderAddChar(global::ImGuiSharp.ImFontGlyphRangesBuilder self, ushort c)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontGlyphRangesBuilderAddChar(__arg0, c);
        }

        public static void ImFontGlyphRangesBuilderAddText(global::ImGuiSharp.ImFontGlyphRangesBuilder self, string text, string text_end)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontGlyphRangesBuilderAddText(__arg0, text, text_end);
        }

        public static void ImFontGlyphRangesBuilderAddRanges(global::ImGuiSharp.ImFontGlyphRangesBuilder self, ref ushort ranges)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            fixed (ushort* __ranges1 = &ranges)
            {
                var __arg1 = __ranges1;
                __Internal.ImFontGlyphRangesBuilderAddRanges(__arg0, __arg1);
            }
        }

        public static void ImFontGlyphRangesBuilderBuildRanges(global::ImGuiSharp.ImFontGlyphRangesBuilder self, global::ImGuiSharp.ImVectorImWchar out_ranges)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = out_ranges is null ? __IntPtr.Zero : out_ranges.__Instance;
            __Internal.ImFontGlyphRangesBuilderBuildRanges(__arg0, __arg1);
        }

        public static global::ImGuiSharp.ImFontAtlasCustomRect ImFontAtlasCustomRectImFontAtlasCustomRect()
        {
            var __ret = __Internal.ImFontAtlasCustomRectImFontAtlasCustomRect();
            var __result0 = global::ImGuiSharp.ImFontAtlasCustomRect.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImFontAtlasCustomRect_destroy(global::ImGuiSharp.ImFontAtlasCustomRect self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontAtlasCustomRect_destroy(__arg0);
        }

        public static bool ImFontAtlasCustomRectIsPacked(global::ImGuiSharp.ImFontAtlasCustomRect self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasCustomRectIsPacked(__arg0);
            return __ret;
        }

        public static global::ImGuiSharp.ImFontAtlas ImFontAtlasImFontAtlas()
        {
            var __ret = __Internal.ImFontAtlasImFontAtlas();
            var __result0 = global::ImGuiSharp.ImFontAtlas.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImFontAtlas_destroy(global::ImGuiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontAtlas_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImFont ImFontAtlasAddFont(global::ImGuiSharp.ImFontAtlas self, global::ImGuiSharp.ImFontConfig font_cfg)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = font_cfg is null ? __IntPtr.Zero : font_cfg.__Instance;
            var __ret = __Internal.ImFontAtlasAddFont(__arg0, __arg1);
            var __result0 = global::ImGuiSharp.ImFont.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::ImGuiSharp.ImFont ImFontAtlasAddFontDefault(global::ImGuiSharp.ImFontAtlas self, global::ImGuiSharp.ImFontConfig font_cfg)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = font_cfg is null ? __IntPtr.Zero : font_cfg.__Instance;
            var __ret = __Internal.ImFontAtlasAddFontDefault(__arg0, __arg1);
            var __result0 = global::ImGuiSharp.ImFont.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::ImGuiSharp.ImFont ImFontAtlasAddFontFromFileTTF(global::ImGuiSharp.ImFontAtlas self, string filename, float size_pixels, global::ImGuiSharp.ImFontConfig font_cfg, ref ushort glyph_ranges)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg3 = font_cfg is null ? __IntPtr.Zero : font_cfg.__Instance;
            fixed (ushort* __glyph_ranges4 = &glyph_ranges)
            {
                var __arg4 = __glyph_ranges4;
                var __ret = __Internal.ImFontAtlasAddFontFromFileTTF(__arg0, filename, size_pixels, __arg3, __arg4);
                var __result0 = global::ImGuiSharp.ImFont.__GetOrCreateInstance(__ret, false);
                return __result0;
            }
        }

        public static global::ImGuiSharp.ImFont ImFontAtlasAddFontFromMemoryTTF(global::ImGuiSharp.ImFontAtlas self, __IntPtr font_data, int font_size, float size_pixels, global::ImGuiSharp.ImFontConfig font_cfg, ref ushort glyph_ranges)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg4 = font_cfg is null ? __IntPtr.Zero : font_cfg.__Instance;
            fixed (ushort* __glyph_ranges5 = &glyph_ranges)
            {
                var __arg5 = __glyph_ranges5;
                var __ret = __Internal.ImFontAtlasAddFontFromMemoryTTF(__arg0, font_data, font_size, size_pixels, __arg4, __arg5);
                var __result0 = global::ImGuiSharp.ImFont.__GetOrCreateInstance(__ret, false);
                return __result0;
            }
        }

        public static global::ImGuiSharp.ImFont ImFontAtlasAddFontFromMemoryCompressedTTF(global::ImGuiSharp.ImFontAtlas self, __IntPtr compressed_font_data, int compressed_font_size, float size_pixels, global::ImGuiSharp.ImFontConfig font_cfg, ref ushort glyph_ranges)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg4 = font_cfg is null ? __IntPtr.Zero : font_cfg.__Instance;
            fixed (ushort* __glyph_ranges5 = &glyph_ranges)
            {
                var __arg5 = __glyph_ranges5;
                var __ret = __Internal.ImFontAtlasAddFontFromMemoryCompressedTTF(__arg0, compressed_font_data, compressed_font_size, size_pixels, __arg4, __arg5);
                var __result0 = global::ImGuiSharp.ImFont.__GetOrCreateInstance(__ret, false);
                return __result0;
            }
        }

        public static global::ImGuiSharp.ImFont ImFontAtlasAddFontFromMemoryCompressedBase85TTF(global::ImGuiSharp.ImFontAtlas self, string compressed_font_data_base85, float size_pixels, global::ImGuiSharp.ImFontConfig font_cfg, ref ushort glyph_ranges)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg3 = font_cfg is null ? __IntPtr.Zero : font_cfg.__Instance;
            fixed (ushort* __glyph_ranges4 = &glyph_ranges)
            {
                var __arg4 = __glyph_ranges4;
                var __ret = __Internal.ImFontAtlasAddFontFromMemoryCompressedBase85TTF(__arg0, compressed_font_data_base85, size_pixels, __arg3, __arg4);
                var __result0 = global::ImGuiSharp.ImFont.__GetOrCreateInstance(__ret, false);
                return __result0;
            }
        }

        public static void ImFontAtlasClearInputData(global::ImGuiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontAtlasClearInputData(__arg0);
        }

        public static void ImFontAtlasClearTexData(global::ImGuiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontAtlasClearTexData(__arg0);
        }

        public static void ImFontAtlasClearFonts(global::ImGuiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontAtlasClearFonts(__arg0);
        }

        public static void ImFontAtlasClear(global::ImGuiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontAtlasClear(__arg0);
        }

        public static bool ImFontAtlasBuild(global::ImGuiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasBuild(__arg0);
            return __ret;
        }

        public static void ImFontAtlasGetTexDataAsAlpha8(global::ImGuiSharp.ImFontAtlas self, byte** out_pixels, ref int out_width, ref int out_height, ref int out_bytes_per_pixel)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            fixed (int* __out_width2 = &out_width)
            {
                var __arg2 = __out_width2;
                fixed (int* __out_height3 = &out_height)
                {
                    var __arg3 = __out_height3;
                    fixed (int* __out_bytes_per_pixel4 = &out_bytes_per_pixel)
                    {
                        var __arg4 = __out_bytes_per_pixel4;
                        __Internal.ImFontAtlasGetTexDataAsAlpha8(__arg0, out_pixels, __arg2, __arg3, __arg4);
                    }
                }
            }
        }

        public static void ImFontAtlasGetTexDataAsRGBA32(global::ImGuiSharp.ImFontAtlas self, byte** out_pixels, ref int out_width, ref int out_height, ref int out_bytes_per_pixel)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            fixed (int* __out_width2 = &out_width)
            {
                var __arg2 = __out_width2;
                fixed (int* __out_height3 = &out_height)
                {
                    var __arg3 = __out_height3;
                    fixed (int* __out_bytes_per_pixel4 = &out_bytes_per_pixel)
                    {
                        var __arg4 = __out_bytes_per_pixel4;
                        __Internal.ImFontAtlasGetTexDataAsRGBA32(__arg0, out_pixels, __arg2, __arg3, __arg4);
                    }
                }
            }
        }

        public static bool ImFontAtlasIsBuilt(global::ImGuiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasIsBuilt(__arg0);
            return __ret;
        }

        public static void ImFontAtlasSetTexID(global::ImGuiSharp.ImFontAtlas self, __IntPtr id)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontAtlasSetTexID(__arg0, id);
        }

        public static ushort* ImFontAtlasGetGlyphRangesDefault(global::ImGuiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetGlyphRangesDefault(__arg0);
            return __ret;
        }

        public static ushort* ImFontAtlasGetGlyphRangesKorean(global::ImGuiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetGlyphRangesKorean(__arg0);
            return __ret;
        }

        public static ushort* ImFontAtlasGetGlyphRangesJapanese(global::ImGuiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetGlyphRangesJapanese(__arg0);
            return __ret;
        }

        public static ushort* ImFontAtlasGetGlyphRangesChineseFull(global::ImGuiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetGlyphRangesChineseFull(__arg0);
            return __ret;
        }

        public static ushort* ImFontAtlasGetGlyphRangesChineseSimplifiedCommon(global::ImGuiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetGlyphRangesChineseSimplifiedCommon(__arg0);
            return __ret;
        }

        public static ushort* ImFontAtlasGetGlyphRangesCyrillic(global::ImGuiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetGlyphRangesCyrillic(__arg0);
            return __ret;
        }

        public static ushort* ImFontAtlasGetGlyphRangesThai(global::ImGuiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetGlyphRangesThai(__arg0);
            return __ret;
        }

        public static ushort* ImFontAtlasGetGlyphRangesVietnamese(global::ImGuiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetGlyphRangesVietnamese(__arg0);
            return __ret;
        }

        public static int ImFontAtlasAddCustomRectRegular(global::ImGuiSharp.ImFontAtlas self, int width, int height)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasAddCustomRectRegular(__arg0, width, height);
            return __ret;
        }

        public static int ImFontAtlasAddCustomRectFontGlyph(global::ImGuiSharp.ImFontAtlas self, global::ImGuiSharp.ImFont font, ushort id, int width, int height, float advance_x, global::ImGuiSharp.ImVec2 offset)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = font is null ? __IntPtr.Zero : font.__Instance;
            if (ReferenceEquals(offset, null))
                throw new global::System.ArgumentNullException("offset", "Cannot be null because it is passed by value.");
            var __arg6 = offset.__Instance;
            var __ret = __Internal.ImFontAtlasAddCustomRectFontGlyph(__arg0, __arg1, id, width, height, advance_x, *(global::ImGuiSharp.ImVec2.__Internal*) __arg6);
            return __ret;
        }

        public static global::ImGuiSharp.ImFontAtlasCustomRect ImFontAtlasGetCustomRectByIndex(global::ImGuiSharp.ImFontAtlas self, int index)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetCustomRectByIndex(__arg0, index);
            var __result0 = global::ImGuiSharp.ImFontAtlasCustomRect.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImFontAtlasCalcCustomRectUV(global::ImGuiSharp.ImFontAtlas self, global::ImGuiSharp.ImFontAtlasCustomRect rect, global::ImGuiSharp.ImVec2 out_uv_min, global::ImGuiSharp.ImVec2 out_uv_max)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = rect is null ? __IntPtr.Zero : rect.__Instance;
            var __arg2 = out_uv_min is null ? __IntPtr.Zero : out_uv_min.__Instance;
            var __arg3 = out_uv_max is null ? __IntPtr.Zero : out_uv_max.__Instance;
            __Internal.ImFontAtlasCalcCustomRectUV(__arg0, __arg1, __arg2, __arg3);
        }

        public static bool ImFontAtlasGetMouseCursorTexData(global::ImGuiSharp.ImFontAtlas self, int cursor, global::ImGuiSharp.ImVec2 out_offset, global::ImGuiSharp.ImVec2 out_size, global::ImGuiSharp.ImVec2[] out_uv_border, global::ImGuiSharp.ImVec2[] out_uv_fill)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg2 = out_offset is null ? __IntPtr.Zero : out_offset.__Instance;
            var __arg3 = out_size is null ? __IntPtr.Zero : out_size.__Instance;
            if (out_uv_border == null || out_uv_border.Length != 2)
                throw new ArgumentOutOfRangeException("out_uv_border", "The dimensions of the provided array don't match the required size.");
            global::ImGuiSharp.ImVec2.__Internal[] __out_uv_border;
            if (out_uv_border == null)
                __out_uv_border = null;
            else
            {
                __out_uv_border = new global::ImGuiSharp.ImVec2.__Internal[out_uv_border.Length];
                for (int i = 0; i < __out_uv_border.Length; i++)
                {
                    var __element = out_uv_border[i];
                    __out_uv_border[i] = __element is null ? new global::ImGuiSharp.ImVec2.__Internal() : *(global::ImGuiSharp.ImVec2.__Internal*) __element.__Instance;
                }
            }
            var __arg4 = __out_uv_border;
            if (out_uv_fill == null || out_uv_fill.Length != 2)
                throw new ArgumentOutOfRangeException("out_uv_fill", "The dimensions of the provided array don't match the required size.");
            global::ImGuiSharp.ImVec2.__Internal[] __out_uv_fill;
            if (out_uv_fill == null)
                __out_uv_fill = null;
            else
            {
                __out_uv_fill = new global::ImGuiSharp.ImVec2.__Internal[out_uv_fill.Length];
                for (int i = 0; i < __out_uv_fill.Length; i++)
                {
                    var __element = out_uv_fill[i];
                    __out_uv_fill[i] = __element is null ? new global::ImGuiSharp.ImVec2.__Internal() : *(global::ImGuiSharp.ImVec2.__Internal*) __element.__Instance;
                }
            }
            var __arg5 = __out_uv_fill;
            var __ret = __Internal.ImFontAtlasGetMouseCursorTexData(__arg0, cursor, __arg2, __arg3, __arg4, __arg5);
            return __ret;
        }

        public static global::ImGuiSharp.ImFont ImFontImFont()
        {
            var __ret = __Internal.ImFontImFont();
            var __result0 = global::ImGuiSharp.ImFont.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImFont_destroy(global::ImGuiSharp.ImFont self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFont_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImFontGlyph ImFontFindGlyph(global::ImGuiSharp.ImFont self, ushort c)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontFindGlyph(__arg0, c);
            var __result0 = global::ImGuiSharp.ImFontGlyph.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::ImGuiSharp.ImFontGlyph ImFontFindGlyphNoFallback(global::ImGuiSharp.ImFont self, ushort c)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontFindGlyphNoFallback(__arg0, c);
            var __result0 = global::ImGuiSharp.ImFontGlyph.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static float ImFontGetCharAdvance(global::ImGuiSharp.ImFont self, ushort c)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontGetCharAdvance(__arg0, c);
            return __ret;
        }

        public static bool ImFontIsLoaded(global::ImGuiSharp.ImFont self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontIsLoaded(__arg0);
            return __ret;
        }

        public static string ImFontGetDebugName(global::ImGuiSharp.ImFont self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontGetDebugName(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static void ImFontCalcTextSizeA(global::ImGuiSharp.ImVec2 pOut, global::ImGuiSharp.ImFont self, float size, float max_width, float wrap_width, string text_begin, string text_end, sbyte** remaining)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontCalcTextSizeA(__arg0, __arg1, size, max_width, wrap_width, text_begin, text_end, remaining);
        }

        public static string ImFontCalcWordWrapPositionA(global::ImGuiSharp.ImFont self, float scale, string text, string text_end, float wrap_width)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontCalcWordWrapPositionA(__arg0, scale, text, text_end, wrap_width);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static void ImFontRenderChar(global::ImGuiSharp.ImFont self, global::ImGuiSharp.ImDrawList draw_list, float size, global::ImGuiSharp.ImVec2 pos, uint col, ushort c)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg3 = pos.__Instance;
            __Internal.ImFontRenderChar(__arg0, __arg1, size, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3, col, c);
        }

        public static void ImFontRenderText(global::ImGuiSharp.ImFont self, global::ImGuiSharp.ImDrawList draw_list, float size, global::ImGuiSharp.ImVec2 pos, uint col, global::ImGuiSharp.ImVec4 clip_rect, string text_begin, string text_end, float wrap_width, bool cpu_fine_clip)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg3 = pos.__Instance;
            if (ReferenceEquals(clip_rect, null))
                throw new global::System.ArgumentNullException("clip_rect", "Cannot be null because it is passed by value.");
            var __arg5 = clip_rect.__Instance;
            __Internal.ImFontRenderText(__arg0, __arg1, size, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3, col, *(global::ImGuiSharp.ImVec4.__Internal*) __arg5, text_begin, text_end, wrap_width, cpu_fine_clip);
        }

        public static void ImFontBuildLookupTable(global::ImGuiSharp.ImFont self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontBuildLookupTable(__arg0);
        }

        public static void ImFontClearOutputData(global::ImGuiSharp.ImFont self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontClearOutputData(__arg0);
        }

        public static void ImFontGrowIndex(global::ImGuiSharp.ImFont self, int new_size)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontGrowIndex(__arg0, new_size);
        }

        public static void ImFontAddGlyph(global::ImGuiSharp.ImFont self, global::ImGuiSharp.ImFontConfig src_cfg, ushort c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = src_cfg is null ? __IntPtr.Zero : src_cfg.__Instance;
            __Internal.ImFontAddGlyph(__arg0, __arg1, c, x0, y0, x1, y1, u0, v0, u1, v1, advance_x);
        }

        public static void ImFontAddRemapChar(global::ImGuiSharp.ImFont self, ushort dst, ushort src, bool overwrite_dst)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontAddRemapChar(__arg0, dst, src, overwrite_dst);
        }

        public static void ImFontSetGlyphVisible(global::ImGuiSharp.ImFont self, ushort c, bool visible)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontSetGlyphVisible(__arg0, c, visible);
        }

        public static bool ImFontIsGlyphRangeUnused(global::ImGuiSharp.ImFont self, uint c_begin, uint c_last)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontIsGlyphRangeUnused(__arg0, c_begin, c_last);
            return __ret;
        }

        public static global::ImGuiSharp.ImGuiViewport ImGuiViewportImGuiViewport()
        {
            var __ret = __Internal.ImGuiViewportImGuiViewport();
            var __result0 = global::ImGuiSharp.ImGuiViewport.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiViewport_destroy(global::ImGuiSharp.ImGuiViewport self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiViewport_destroy(__arg0);
        }

        public static void ImGuiViewportGetCenter(global::ImGuiSharp.ImVec2 pOut, global::ImGuiSharp.ImGuiViewport self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiViewportGetCenter(__arg0, __arg1);
        }

        public static void ImGuiViewportGetWorkCenter(global::ImGuiSharp.ImVec2 pOut, global::ImGuiSharp.ImGuiViewport self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiViewportGetWorkCenter(__arg0, __arg1);
        }

        public static global::ImGuiSharp.ImGuiPlatformImeData ImGuiPlatformImeDataImGuiPlatformImeData()
        {
            var __ret = __Internal.ImGuiPlatformImeDataImGuiPlatformImeData();
            var __result0 = global::ImGuiSharp.ImGuiPlatformImeData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiPlatformImeData_destroy(global::ImGuiSharp.ImGuiPlatformImeData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiPlatformImeData_destroy(__arg0);
        }

        public static int GetKeyIndex(int key)
        {
            var __ret = __Internal.GetKeyIndex(key);
            return __ret;
        }

        public static uint ImHashData(__IntPtr data, IntPtr data_size, uint seed)
        {
            var __ret = __Internal.ImHashData(data, data_size, seed);
            return __ret;
        }

        public static uint ImHashStr(string data, IntPtr data_size, uint seed)
        {
            var __ret = __Internal.ImHashStr(data, data_size, seed);
            return __ret;
        }

        public static void ImQsort(__IntPtr @base, IntPtr count, IntPtr size_of_element, global::ImGuiSharp.Delegates.Func_int___IntPtr___IntPtr compare_func)
        {
            var __arg3 = compare_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(compare_func);
            __Internal.ImQsort(@base, count, size_of_element, __arg3);
        }

        public static uint ImAlphaBlendColors(uint col_a, uint col_b)
        {
            var __ret = __Internal.ImAlphaBlendColors(col_a, col_b);
            return __ret;
        }

        public static bool ImIsPowerOfTwoInt(int v)
        {
            var __ret = __Internal.ImIsPowerOfTwoInt(v);
            return __ret;
        }

        public static bool ImIsPowerOfTwoU64(ulong v)
        {
            var __ret = __Internal.ImIsPowerOfTwoU64(v);
            return __ret;
        }

        public static int ImUpperPowerOfTwo(int v)
        {
            var __ret = __Internal.ImUpperPowerOfTwo(v);
            return __ret;
        }

        public static int ImStricmp(string str1, string str2)
        {
            var __ret = __Internal.ImStricmp(str1, str2);
            return __ret;
        }

        public static int ImStrnicmp(string str1, string str2, IntPtr count)
        {
            var __ret = __Internal.ImStrnicmp(str1, str2, count);
            return __ret;
        }

        public static void ImStrncpy(sbyte* dst, string src, IntPtr count)
        {
            __Internal.ImStrncpy(dst, src, count);
        }

        public static sbyte* ImStrdup(string str)
        {
            var __ret = __Internal.ImStrdup(str);
            return __ret;
        }

        public static sbyte* ImStrdupcpy(sbyte* dst, ref IntPtr p_dst_size, string str)
        {
            fixed (IntPtr* __p_dst_size1 = &p_dst_size)
            {
                var __arg1 = __p_dst_size1;
                var __ret = __Internal.ImStrdupcpy(dst, __arg1, str);
                return __ret;
            }
        }

        public static string ImStrchrRange(string str_begin, string str_end, sbyte c)
        {
            var __ret = __Internal.ImStrchrRange(str_begin, str_end, c);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static int ImStrlenW(ref ushort str)
        {
            fixed (ushort* __str0 = &str)
            {
                var __arg0 = __str0;
                var __ret = __Internal.ImStrlenW(__arg0);
                return __ret;
            }
        }

        public static string ImStreolRange(string str, string str_end)
        {
            var __ret = __Internal.ImStreolRange(str, str_end);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static ushort* ImStrbolW(ref ushort buf_mid_line, ref ushort buf_begin)
        {
            fixed (ushort* __buf_mid_line0 = &buf_mid_line)
            {
                var __arg0 = __buf_mid_line0;
                fixed (ushort* __buf_begin1 = &buf_begin)
                {
                    var __arg1 = __buf_begin1;
                    var __ret = __Internal.ImStrbolW(__arg0, __arg1);
                    return __ret;
                }
            }
        }

        public static string ImStristr(string haystack, string haystack_end, string needle, string needle_end)
        {
            var __ret = __Internal.ImStristr(haystack, haystack_end, needle, needle_end);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static void ImStrTrimBlanks(sbyte* str)
        {
            __Internal.ImStrTrimBlanks(str);
        }

        public static string ImStrSkipBlank(string str)
        {
            var __ret = __Internal.ImStrSkipBlank(str);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static int ImFormatString(sbyte* buf, IntPtr buf_size, string fmt)
        {
            var __ret = __Internal.ImFormatString(buf, buf_size, fmt);
            return __ret;
        }

        public static string ImParseFormatFindStart(string format)
        {
            var __ret = __Internal.ImParseFormatFindStart(format);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static string ImParseFormatFindEnd(string format)
        {
            var __ret = __Internal.ImParseFormatFindEnd(format);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static string ImParseFormatTrimDecorations(string format, sbyte* buf, IntPtr buf_size)
        {
            var __ret = __Internal.ImParseFormatTrimDecorations(format, buf, buf_size);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static int ImParseFormatPrecision(string format, int default_value)
        {
            var __ret = __Internal.ImParseFormatPrecision(format, default_value);
            return __ret;
        }

        public static bool ImCharIsBlankA(sbyte c)
        {
            var __ret = __Internal.ImCharIsBlankA(c);
            return __ret;
        }

        public static bool ImCharIsBlankW(uint c)
        {
            var __ret = __Internal.ImCharIsBlankW(c);
            return __ret;
        }

        public static string ImTextCharToUtf8(sbyte[] out_buf, uint c)
        {
            if (out_buf == null || out_buf.Length != 5)
                throw new ArgumentOutOfRangeException("out_buf", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.ImTextCharToUtf8(out_buf, c);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static int ImTextStrToUtf8(sbyte* out_buf, int out_buf_size, ref ushort in_text, ref ushort in_text_end)
        {
            fixed (ushort* __in_text2 = &in_text)
            {
                var __arg2 = __in_text2;
                fixed (ushort* __in_text_end3 = &in_text_end)
                {
                    var __arg3 = __in_text_end3;
                    var __ret = __Internal.ImTextStrToUtf8(out_buf, out_buf_size, __arg2, __arg3);
                    return __ret;
                }
            }
        }

        public static int ImTextCharFromUtf8(ref uint out_char, string in_text, string in_text_end)
        {
            fixed (uint* __out_char0 = &out_char)
            {
                var __arg0 = __out_char0;
                var __ret = __Internal.ImTextCharFromUtf8(__arg0, in_text, in_text_end);
                return __ret;
            }
        }

        public static int ImTextStrFromUtf8(ref ushort out_buf, int out_buf_size, string in_text, string in_text_end, sbyte** in_remaining)
        {
            fixed (ushort* __out_buf0 = &out_buf)
            {
                var __arg0 = __out_buf0;
                var __ret = __Internal.ImTextStrFromUtf8(__arg0, out_buf_size, in_text, in_text_end, in_remaining);
                return __ret;
            }
        }

        public static int ImTextCountCharsFromUtf8(string in_text, string in_text_end)
        {
            var __ret = __Internal.ImTextCountCharsFromUtf8(in_text, in_text_end);
            return __ret;
        }

        public static int ImTextCountUtf8BytesFromChar(string in_text, string in_text_end)
        {
            var __ret = __Internal.ImTextCountUtf8BytesFromChar(in_text, in_text_end);
            return __ret;
        }

        public static int ImTextCountUtf8BytesFromStr(ref ushort in_text, ref ushort in_text_end)
        {
            fixed (ushort* __in_text0 = &in_text)
            {
                var __arg0 = __in_text0;
                fixed (ushort* __in_text_end1 = &in_text_end)
                {
                    var __arg1 = __in_text_end1;
                    var __ret = __Internal.ImTextCountUtf8BytesFromStr(__arg0, __arg1);
                    return __ret;
                }
            }
        }

        public static global::System.IntPtr ImFileOpen(string filename, string mode)
        {
            var __ret = __Internal.ImFileOpen(filename, mode);
            return __ret;
        }

        public static bool ImFileClose(global::System.IntPtr file)
        {
            var __ret = __Internal.ImFileClose(file);
            return __ret;
        }

        public static ulong ImFileGetSize(global::System.IntPtr file)
        {
            var __ret = __Internal.ImFileGetSize(file);
            return __ret;
        }

        public static ulong ImFileRead(__IntPtr data, ulong size, ulong count, global::System.IntPtr file)
        {
            var __ret = __Internal.ImFileRead(data, size, count, file);
            return __ret;
        }

        public static ulong ImFileWrite(__IntPtr data, ulong size, ulong count, global::System.IntPtr file)
        {
            var __ret = __Internal.ImFileWrite(data, size, count, file);
            return __ret;
        }

        public static __IntPtr ImFileLoadToMemory(string filename, string mode, ref IntPtr out_file_size, int padding_bytes)
        {
            fixed (IntPtr* __out_file_size2 = &out_file_size)
            {
                var __arg2 = __out_file_size2;
                var __ret = __Internal.ImFileLoadToMemory(filename, mode, __arg2, padding_bytes);
                return __ret;
            }
        }

        public static float ImPowFloat(float x, float y)
        {
            var __ret = __Internal.ImPowFloat(x, y);
            return __ret;
        }

        public static double ImPow_double(double x, double y)
        {
            var __ret = __Internal.ImPow_double(x, y);
            return __ret;
        }

        public static float ImLogFloat(float x)
        {
            var __ret = __Internal.ImLogFloat(x);
            return __ret;
        }

        public static double ImLog_double(double x)
        {
            var __ret = __Internal.ImLog_double(x);
            return __ret;
        }

        public static int ImAbsInt(int x)
        {
            var __ret = __Internal.ImAbsInt(x);
            return __ret;
        }

        public static float ImAbsFloat(float x)
        {
            var __ret = __Internal.ImAbsFloat(x);
            return __ret;
        }

        public static double ImAbs_double(double x)
        {
            var __ret = __Internal.ImAbs_double(x);
            return __ret;
        }

        public static float ImSignFloat(float x)
        {
            var __ret = __Internal.ImSignFloat(x);
            return __ret;
        }

        public static double ImSign_double(double x)
        {
            var __ret = __Internal.ImSign_double(x);
            return __ret;
        }

        public static float ImRsqrtFloat(float x)
        {
            var __ret = __Internal.ImRsqrtFloat(x);
            return __ret;
        }

        public static double ImRsqrt_double(double x)
        {
            var __ret = __Internal.ImRsqrt_double(x);
            return __ret;
        }

        public static void ImMin(global::ImGuiSharp.ImVec2 pOut, global::ImGuiSharp.ImVec2 lhs, global::ImGuiSharp.ImVec2 rhs)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(lhs, null))
                throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is passed by value.");
            var __arg1 = lhs.__Instance;
            if (ReferenceEquals(rhs, null))
                throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is passed by value.");
            var __arg2 = rhs.__Instance;
            __Internal.ImMin(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2);
        }

        public static void ImMax(global::ImGuiSharp.ImVec2 pOut, global::ImGuiSharp.ImVec2 lhs, global::ImGuiSharp.ImVec2 rhs)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(lhs, null))
                throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is passed by value.");
            var __arg1 = lhs.__Instance;
            if (ReferenceEquals(rhs, null))
                throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is passed by value.");
            var __arg2 = rhs.__Instance;
            __Internal.ImMax(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2);
        }

        public static void ImClamp(global::ImGuiSharp.ImVec2 pOut, global::ImGuiSharp.ImVec2 v, global::ImGuiSharp.ImVec2 mn, global::ImGuiSharp.ImVec2 mx)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(v, null))
                throw new global::System.ArgumentNullException("v", "Cannot be null because it is passed by value.");
            var __arg1 = v.__Instance;
            if (ReferenceEquals(mn, null))
                throw new global::System.ArgumentNullException("mn", "Cannot be null because it is passed by value.");
            var __arg2 = mn.__Instance;
            if (ReferenceEquals(mx, null))
                throw new global::System.ArgumentNullException("mx", "Cannot be null because it is passed by value.");
            var __arg3 = mx.__Instance;
            __Internal.ImClamp(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3);
        }

        public static void ImLerpVec2Float(global::ImGuiSharp.ImVec2 pOut, global::ImGuiSharp.ImVec2 a, global::ImGuiSharp.ImVec2 b, float t)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg1 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg2 = b.__Instance;
            __Internal.ImLerpVec2Float(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, t);
        }

        public static void ImLerpVec2Vec2(global::ImGuiSharp.ImVec2 pOut, global::ImGuiSharp.ImVec2 a, global::ImGuiSharp.ImVec2 b, global::ImGuiSharp.ImVec2 t)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg1 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg2 = b.__Instance;
            if (ReferenceEquals(t, null))
                throw new global::System.ArgumentNullException("t", "Cannot be null because it is passed by value.");
            var __arg3 = t.__Instance;
            __Internal.ImLerpVec2Vec2(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3);
        }

        public static void ImLerpVec4(global::ImGuiSharp.ImVec4 pOut, global::ImGuiSharp.ImVec4 a, global::ImGuiSharp.ImVec4 b, float t)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg1 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg2 = b.__Instance;
            __Internal.ImLerpVec4(__arg0, *(global::ImGuiSharp.ImVec4.__Internal*) __arg1, *(global::ImGuiSharp.ImVec4.__Internal*) __arg2, t);
        }

        public static float ImSaturate(float f)
        {
            var __ret = __Internal.ImSaturate(f);
            return __ret;
        }

        public static float ImLengthSqrVec2(global::ImGuiSharp.ImVec2 lhs)
        {
            if (ReferenceEquals(lhs, null))
                throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is passed by value.");
            var __arg0 = lhs.__Instance;
            var __ret = __Internal.ImLengthSqrVec2(*(global::ImGuiSharp.ImVec2.__Internal*) __arg0);
            return __ret;
        }

        public static float ImLengthSqrVec4(global::ImGuiSharp.ImVec4 lhs)
        {
            if (ReferenceEquals(lhs, null))
                throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is passed by value.");
            var __arg0 = lhs.__Instance;
            var __ret = __Internal.ImLengthSqrVec4(*(global::ImGuiSharp.ImVec4.__Internal*) __arg0);
            return __ret;
        }

        public static float ImInvLength(global::ImGuiSharp.ImVec2 lhs, float fail_value)
        {
            if (ReferenceEquals(lhs, null))
                throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is passed by value.");
            var __arg0 = lhs.__Instance;
            var __ret = __Internal.ImInvLength(*(global::ImGuiSharp.ImVec2.__Internal*) __arg0, fail_value);
            return __ret;
        }

        public static float ImFloorFloat(float f)
        {
            var __ret = __Internal.ImFloorFloat(f);
            return __ret;
        }

        public static float ImFloorSignedFloat(float f)
        {
            var __ret = __Internal.ImFloorSignedFloat(f);
            return __ret;
        }

        public static void ImFloorVec2(global::ImGuiSharp.ImVec2 pOut, global::ImGuiSharp.ImVec2 v)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(v, null))
                throw new global::System.ArgumentNullException("v", "Cannot be null because it is passed by value.");
            var __arg1 = v.__Instance;
            __Internal.ImFloorVec2(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1);
        }

        public static void ImFloorSignedVec2(global::ImGuiSharp.ImVec2 pOut, global::ImGuiSharp.ImVec2 v)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(v, null))
                throw new global::System.ArgumentNullException("v", "Cannot be null because it is passed by value.");
            var __arg1 = v.__Instance;
            __Internal.ImFloorSignedVec2(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1);
        }

        public static int ImModPositive(int a, int b)
        {
            var __ret = __Internal.ImModPositive(a, b);
            return __ret;
        }

        public static float ImDot(global::ImGuiSharp.ImVec2 a, global::ImGuiSharp.ImVec2 b)
        {
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg0 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg1 = b.__Instance;
            var __ret = __Internal.ImDot(*(global::ImGuiSharp.ImVec2.__Internal*) __arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1);
            return __ret;
        }

        public static void ImRotate(global::ImGuiSharp.ImVec2 pOut, global::ImGuiSharp.ImVec2 v, float cos_a, float sin_a)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(v, null))
                throw new global::System.ArgumentNullException("v", "Cannot be null because it is passed by value.");
            var __arg1 = v.__Instance;
            __Internal.ImRotate(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, cos_a, sin_a);
        }

        public static float ImLinearSweep(float current, float target, float speed)
        {
            var __ret = __Internal.ImLinearSweep(current, target, speed);
            return __ret;
        }

        public static void ImMul(global::ImGuiSharp.ImVec2 pOut, global::ImGuiSharp.ImVec2 lhs, global::ImGuiSharp.ImVec2 rhs)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(lhs, null))
                throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is passed by value.");
            var __arg1 = lhs.__Instance;
            if (ReferenceEquals(rhs, null))
                throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is passed by value.");
            var __arg2 = rhs.__Instance;
            __Internal.ImMul(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2);
        }

        public static bool ImIsFloatAboveGuaranteedIntegerPrecision(float f)
        {
            var __ret = __Internal.ImIsFloatAboveGuaranteedIntegerPrecision(f);
            return __ret;
        }

        public static void ImBezierCubicCalc(global::ImGuiSharp.ImVec2 pOut, global::ImGuiSharp.ImVec2 p1, global::ImGuiSharp.ImVec2 p2, global::ImGuiSharp.ImVec2 p3, global::ImGuiSharp.ImVec2 p4, float t)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is passed by value.");
            var __arg4 = p4.__Instance;
            __Internal.ImBezierCubicCalc(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3, *(global::ImGuiSharp.ImVec2.__Internal*) __arg4, t);
        }

        public static void ImBezierCubicClosestPoint(global::ImGuiSharp.ImVec2 pOut, global::ImGuiSharp.ImVec2 p1, global::ImGuiSharp.ImVec2 p2, global::ImGuiSharp.ImVec2 p3, global::ImGuiSharp.ImVec2 p4, global::ImGuiSharp.ImVec2 p, int num_segments)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is passed by value.");
            var __arg4 = p4.__Instance;
            if (ReferenceEquals(p, null))
                throw new global::System.ArgumentNullException("p", "Cannot be null because it is passed by value.");
            var __arg5 = p.__Instance;
            __Internal.ImBezierCubicClosestPoint(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3, *(global::ImGuiSharp.ImVec2.__Internal*) __arg4, *(global::ImGuiSharp.ImVec2.__Internal*) __arg5, num_segments);
        }

        public static void ImBezierCubicClosestPointCasteljau(global::ImGuiSharp.ImVec2 pOut, global::ImGuiSharp.ImVec2 p1, global::ImGuiSharp.ImVec2 p2, global::ImGuiSharp.ImVec2 p3, global::ImGuiSharp.ImVec2 p4, global::ImGuiSharp.ImVec2 p, float tess_tol)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is passed by value.");
            var __arg4 = p4.__Instance;
            if (ReferenceEquals(p, null))
                throw new global::System.ArgumentNullException("p", "Cannot be null because it is passed by value.");
            var __arg5 = p.__Instance;
            __Internal.ImBezierCubicClosestPointCasteljau(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3, *(global::ImGuiSharp.ImVec2.__Internal*) __arg4, *(global::ImGuiSharp.ImVec2.__Internal*) __arg5, tess_tol);
        }

        public static void ImBezierQuadraticCalc(global::ImGuiSharp.ImVec2 pOut, global::ImGuiSharp.ImVec2 p1, global::ImGuiSharp.ImVec2 p2, global::ImGuiSharp.ImVec2 p3, float t)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            __Internal.ImBezierQuadraticCalc(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3, t);
        }

        public static void ImLineClosestPoint(global::ImGuiSharp.ImVec2 pOut, global::ImGuiSharp.ImVec2 a, global::ImGuiSharp.ImVec2 b, global::ImGuiSharp.ImVec2 p)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg1 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg2 = b.__Instance;
            if (ReferenceEquals(p, null))
                throw new global::System.ArgumentNullException("p", "Cannot be null because it is passed by value.");
            var __arg3 = p.__Instance;
            __Internal.ImLineClosestPoint(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3);
        }

        public static bool ImTriangleContainsPoint(global::ImGuiSharp.ImVec2 a, global::ImGuiSharp.ImVec2 b, global::ImGuiSharp.ImVec2 c, global::ImGuiSharp.ImVec2 p)
        {
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg0 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg1 = b.__Instance;
            if (ReferenceEquals(c, null))
                throw new global::System.ArgumentNullException("c", "Cannot be null because it is passed by value.");
            var __arg2 = c.__Instance;
            if (ReferenceEquals(p, null))
                throw new global::System.ArgumentNullException("p", "Cannot be null because it is passed by value.");
            var __arg3 = p.__Instance;
            var __ret = __Internal.ImTriangleContainsPoint(*(global::ImGuiSharp.ImVec2.__Internal*) __arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3);
            return __ret;
        }

        public static void ImTriangleClosestPoint(global::ImGuiSharp.ImVec2 pOut, global::ImGuiSharp.ImVec2 a, global::ImGuiSharp.ImVec2 b, global::ImGuiSharp.ImVec2 c, global::ImGuiSharp.ImVec2 p)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg1 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg2 = b.__Instance;
            if (ReferenceEquals(c, null))
                throw new global::System.ArgumentNullException("c", "Cannot be null because it is passed by value.");
            var __arg3 = c.__Instance;
            if (ReferenceEquals(p, null))
                throw new global::System.ArgumentNullException("p", "Cannot be null because it is passed by value.");
            var __arg4 = p.__Instance;
            __Internal.ImTriangleClosestPoint(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3, *(global::ImGuiSharp.ImVec2.__Internal*) __arg4);
        }

        public static void ImTriangleBarycentricCoords(global::ImGuiSharp.ImVec2 a, global::ImGuiSharp.ImVec2 b, global::ImGuiSharp.ImVec2 c, global::ImGuiSharp.ImVec2 p, ref float out_u, ref float out_v, ref float out_w)
        {
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg0 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg1 = b.__Instance;
            if (ReferenceEquals(c, null))
                throw new global::System.ArgumentNullException("c", "Cannot be null because it is passed by value.");
            var __arg2 = c.__Instance;
            if (ReferenceEquals(p, null))
                throw new global::System.ArgumentNullException("p", "Cannot be null because it is passed by value.");
            var __arg3 = p.__Instance;
            fixed (float* __out_u4 = &out_u)
            {
                var __arg4 = __out_u4;
                fixed (float* __out_v5 = &out_v)
                {
                    var __arg5 = __out_v5;
                    fixed (float* __out_w6 = &out_w)
                    {
                        var __arg6 = __out_w6;
                        __Internal.ImTriangleBarycentricCoords(*(global::ImGuiSharp.ImVec2.__Internal*) __arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3, __arg4, __arg5, __arg6);
                    }
                }
            }
        }

        public static float ImTriangleArea(global::ImGuiSharp.ImVec2 a, global::ImGuiSharp.ImVec2 b, global::ImGuiSharp.ImVec2 c)
        {
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg0 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg1 = b.__Instance;
            if (ReferenceEquals(c, null))
                throw new global::System.ArgumentNullException("c", "Cannot be null because it is passed by value.");
            var __arg2 = c.__Instance;
            var __ret = __Internal.ImTriangleArea(*(global::ImGuiSharp.ImVec2.__Internal*) __arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2);
            return __ret;
        }

        public static int ImGetDirQuadrantFromDelta(float dx, float dy)
        {
            var __ret = __Internal.ImGetDirQuadrantFromDelta(dx, dy);
            return __ret;
        }

        public static global::ImGuiSharp.ImVec1 ImVec1ImVec1Nil()
        {
            var __ret = __Internal.ImVec1ImVec1Nil();
            var __result0 = global::ImGuiSharp.ImVec1.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImVec1_destroy(global::ImGuiSharp.ImVec1 self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImVec1_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImVec1 ImVec1ImVec1Float(float _x)
        {
            var __ret = __Internal.ImVec1ImVec1Float(_x);
            var __result0 = global::ImGuiSharp.ImVec1.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::ImGuiSharp.ImVec2ih ImVec2ihImVec2ihNil()
        {
            var __ret = __Internal.ImVec2ihImVec2ihNil();
            var __result0 = global::ImGuiSharp.ImVec2ih.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImVec2ih_destroy(global::ImGuiSharp.ImVec2ih self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImVec2ih_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImVec2ih ImVec2ihImVec2ih_short(short _x, short _y)
        {
            var __ret = __Internal.ImVec2ihImVec2ih_short(_x, _y);
            var __result0 = global::ImGuiSharp.ImVec2ih.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::ImGuiSharp.ImRect ImRectImRectNil()
        {
            var __ret = __Internal.ImRectImRectNil();
            var __result0 = global::ImGuiSharp.ImRect.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImRect_destroy(global::ImGuiSharp.ImRect self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImRect_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImRect ImRectImRectVec2(global::ImGuiSharp.ImVec2 min, global::ImGuiSharp.ImVec2 max)
        {
            if (ReferenceEquals(min, null))
                throw new global::System.ArgumentNullException("min", "Cannot be null because it is passed by value.");
            var __arg0 = min.__Instance;
            if (ReferenceEquals(max, null))
                throw new global::System.ArgumentNullException("max", "Cannot be null because it is passed by value.");
            var __arg1 = max.__Instance;
            var __ret = __Internal.ImRectImRectVec2(*(global::ImGuiSharp.ImVec2.__Internal*) __arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1);
            var __result0 = global::ImGuiSharp.ImRect.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::ImGuiSharp.ImRect ImRectImRectVec4(global::ImGuiSharp.ImVec4 v)
        {
            if (ReferenceEquals(v, null))
                throw new global::System.ArgumentNullException("v", "Cannot be null because it is passed by value.");
            var __arg0 = v.__Instance;
            var __ret = __Internal.ImRectImRectVec4(*(global::ImGuiSharp.ImVec4.__Internal*) __arg0);
            var __result0 = global::ImGuiSharp.ImRect.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::ImGuiSharp.ImRect ImRectImRectFloat(float x1, float y1, float x2, float y2)
        {
            var __ret = __Internal.ImRectImRectFloat(x1, y1, x2, y2);
            var __result0 = global::ImGuiSharp.ImRect.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImRectGetCenter(global::ImGuiSharp.ImVec2 pOut, global::ImGuiSharp.ImRect self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImRectGetCenter(__arg0, __arg1);
        }

        public static void ImRectGetSize(global::ImGuiSharp.ImVec2 pOut, global::ImGuiSharp.ImRect self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImRectGetSize(__arg0, __arg1);
        }

        public static float ImRectGetWidth(global::ImGuiSharp.ImRect self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImRectGetWidth(__arg0);
            return __ret;
        }

        public static float ImRectGetHeight(global::ImGuiSharp.ImRect self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImRectGetHeight(__arg0);
            return __ret;
        }

        public static float ImRectGetArea(global::ImGuiSharp.ImRect self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImRectGetArea(__arg0);
            return __ret;
        }

        public static void ImRectGetTL(global::ImGuiSharp.ImVec2 pOut, global::ImGuiSharp.ImRect self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImRectGetTL(__arg0, __arg1);
        }

        public static void ImRectGetTR(global::ImGuiSharp.ImVec2 pOut, global::ImGuiSharp.ImRect self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImRectGetTR(__arg0, __arg1);
        }

        public static void ImRectGetBL(global::ImGuiSharp.ImVec2 pOut, global::ImGuiSharp.ImRect self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImRectGetBL(__arg0, __arg1);
        }

        public static void ImRectGetBR(global::ImGuiSharp.ImVec2 pOut, global::ImGuiSharp.ImRect self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImRectGetBR(__arg0, __arg1);
        }

        public static bool ImRectContainsVec2(global::ImGuiSharp.ImRect self, global::ImGuiSharp.ImVec2 p)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p, null))
                throw new global::System.ArgumentNullException("p", "Cannot be null because it is passed by value.");
            var __arg1 = p.__Instance;
            var __ret = __Internal.ImRectContainsVec2(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1);
            return __ret;
        }

        public static bool ImRectContainsRect(global::ImGuiSharp.ImRect self, global::ImGuiSharp.ImRect r)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(r, null))
                throw new global::System.ArgumentNullException("r", "Cannot be null because it is passed by value.");
            var __arg1 = r.__Instance;
            var __ret = __Internal.ImRectContainsRect(__arg0, __arg1);
            return __ret;
        }

        public static bool ImRectOverlaps(global::ImGuiSharp.ImRect self, global::ImGuiSharp.ImRect r)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(r, null))
                throw new global::System.ArgumentNullException("r", "Cannot be null because it is passed by value.");
            var __arg1 = r.__Instance;
            var __ret = __Internal.ImRectOverlaps(__arg0, __arg1);
            return __ret;
        }

        public static void ImRectAddVec2(global::ImGuiSharp.ImRect self, global::ImGuiSharp.ImVec2 p)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p, null))
                throw new global::System.ArgumentNullException("p", "Cannot be null because it is passed by value.");
            var __arg1 = p.__Instance;
            __Internal.ImRectAddVec2(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1);
        }

        public static void ImRectAddRect(global::ImGuiSharp.ImRect self, global::ImGuiSharp.ImRect r)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(r, null))
                throw new global::System.ArgumentNullException("r", "Cannot be null because it is passed by value.");
            var __arg1 = r.__Instance;
            __Internal.ImRectAddRect(__arg0, __arg1);
        }

        public static void ImRectExpandFloat(global::ImGuiSharp.ImRect self, float amount)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImRectExpandFloat(__arg0, amount);
        }

        public static void ImRectExpandVec2(global::ImGuiSharp.ImRect self, global::ImGuiSharp.ImVec2 amount)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(amount, null))
                throw new global::System.ArgumentNullException("amount", "Cannot be null because it is passed by value.");
            var __arg1 = amount.__Instance;
            __Internal.ImRectExpandVec2(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1);
        }

        public static void ImRectTranslate(global::ImGuiSharp.ImRect self, global::ImGuiSharp.ImVec2 d)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(d, null))
                throw new global::System.ArgumentNullException("d", "Cannot be null because it is passed by value.");
            var __arg1 = d.__Instance;
            __Internal.ImRectTranslate(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1);
        }

        public static void ImRectTranslateX(global::ImGuiSharp.ImRect self, float dx)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImRectTranslateX(__arg0, dx);
        }

        public static void ImRectTranslateY(global::ImGuiSharp.ImRect self, float dy)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImRectTranslateY(__arg0, dy);
        }

        public static void ImRectClipWith(global::ImGuiSharp.ImRect self, global::ImGuiSharp.ImRect r)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(r, null))
                throw new global::System.ArgumentNullException("r", "Cannot be null because it is passed by value.");
            var __arg1 = r.__Instance;
            __Internal.ImRectClipWith(__arg0, __arg1);
        }

        public static void ImRectClipWithFull(global::ImGuiSharp.ImRect self, global::ImGuiSharp.ImRect r)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(r, null))
                throw new global::System.ArgumentNullException("r", "Cannot be null because it is passed by value.");
            var __arg1 = r.__Instance;
            __Internal.ImRectClipWithFull(__arg0, __arg1);
        }

        public static void ImRectFloor(global::ImGuiSharp.ImRect self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImRectFloor(__arg0);
        }

        public static bool ImRectIsInverted(global::ImGuiSharp.ImRect self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImRectIsInverted(__arg0);
            return __ret;
        }

        public static void ImRectToVec4(global::ImGuiSharp.ImVec4 pOut, global::ImGuiSharp.ImRect self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImRectToVec4(__arg0, __arg1);
        }

        public static bool ImBitArrayTestBit(ref uint arr, int n)
        {
            fixed (uint* __arr0 = &arr)
            {
                var __arg0 = __arr0;
                var __ret = __Internal.ImBitArrayTestBit(__arg0, n);
                return __ret;
            }
        }

        public static void ImBitArrayClearBit(ref uint arr, int n)
        {
            fixed (uint* __arr0 = &arr)
            {
                var __arg0 = __arr0;
                __Internal.ImBitArrayClearBit(__arg0, n);
            }
        }

        public static void ImBitArraySetBit(ref uint arr, int n)
        {
            fixed (uint* __arr0 = &arr)
            {
                var __arg0 = __arr0;
                __Internal.ImBitArraySetBit(__arg0, n);
            }
        }

        public static void ImBitArraySetBitRange(ref uint arr, int n, int n2)
        {
            fixed (uint* __arr0 = &arr)
            {
                var __arg0 = __arr0;
                __Internal.ImBitArraySetBitRange(__arg0, n, n2);
            }
        }

        public static void ImBitVectorCreate(global::ImGuiSharp.ImBitVector self, int sz)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImBitVectorCreate(__arg0, sz);
        }

        public static void ImBitVectorClear(global::ImGuiSharp.ImBitVector self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImBitVectorClear(__arg0);
        }

        public static bool ImBitVectorTestBit(global::ImGuiSharp.ImBitVector self, int n)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImBitVectorTestBit(__arg0, n);
            return __ret;
        }

        public static void ImBitVectorSetBit(global::ImGuiSharp.ImBitVector self, int n)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImBitVectorSetBit(__arg0, n);
        }

        public static void ImBitVectorClearBit(global::ImGuiSharp.ImBitVector self, int n)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImBitVectorClearBit(__arg0, n);
        }

        public static global::ImGuiSharp.ImDrawListSharedData ImDrawListSharedDataImDrawListSharedData()
        {
            var __ret = __Internal.ImDrawListSharedDataImDrawListSharedData();
            var __result0 = global::ImGuiSharp.ImDrawListSharedData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImDrawListSharedData_destroy(global::ImGuiSharp.ImDrawListSharedData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListSharedData_destroy(__arg0);
        }

        public static void ImDrawListSharedDataSetCircleTessellationMaxError(global::ImGuiSharp.ImDrawListSharedData self, float max_error)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListSharedDataSetCircleTessellationMaxError(__arg0, max_error);
        }

        public static void ImDrawDataBuilderClear(global::ImGuiSharp.ImDrawDataBuilder self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawDataBuilderClear(__arg0);
        }

        public static void ImDrawDataBuilderClearFreeMemory(global::ImGuiSharp.ImDrawDataBuilder self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawDataBuilderClearFreeMemory(__arg0);
        }

        public static int ImDrawDataBuilderGetDrawListCount(global::ImGuiSharp.ImDrawDataBuilder self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImDrawDataBuilderGetDrawListCount(__arg0);
            return __ret;
        }

        public static void ImDrawDataBuilderFlattenIntoSingleLayer(global::ImGuiSharp.ImDrawDataBuilder self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawDataBuilderFlattenIntoSingleLayer(__arg0);
        }

        public static global::ImGuiSharp.ImGuiStyleMod ImGuiStyleModImGuiStyleModInt(int idx, int v)
        {
            var __ret = __Internal.ImGuiStyleModImGuiStyleModInt(idx, v);
            var __result0 = global::ImGuiSharp.ImGuiStyleMod.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiStyleMod_destroy(global::ImGuiSharp.ImGuiStyleMod self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStyleMod_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImGuiStyleMod ImGuiStyleModImGuiStyleModFloat(int idx, float v)
        {
            var __ret = __Internal.ImGuiStyleModImGuiStyleModFloat(idx, v);
            var __result0 = global::ImGuiSharp.ImGuiStyleMod.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::ImGuiSharp.ImGuiStyleMod ImGuiStyleModImGuiStyleModVec2(int idx, global::ImGuiSharp.ImVec2 v)
        {
            if (ReferenceEquals(v, null))
                throw new global::System.ArgumentNullException("v", "Cannot be null because it is passed by value.");
            var __arg1 = v.__Instance;
            var __ret = __Internal.ImGuiStyleModImGuiStyleModVec2(idx, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1);
            var __result0 = global::ImGuiSharp.ImGuiStyleMod.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::ImGuiSharp.ImGuiComboPreviewData ImGuiComboPreviewDataImGuiComboPreviewData()
        {
            var __ret = __Internal.ImGuiComboPreviewDataImGuiComboPreviewData();
            var __result0 = global::ImGuiSharp.ImGuiComboPreviewData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiComboPreviewData_destroy(global::ImGuiSharp.ImGuiComboPreviewData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiComboPreviewData_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImGuiMenuColumns ImGuiMenuColumnsImGuiMenuColumns()
        {
            var __ret = __Internal.ImGuiMenuColumnsImGuiMenuColumns();
            var __result0 = global::ImGuiSharp.ImGuiMenuColumns.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiMenuColumns_destroy(global::ImGuiSharp.ImGuiMenuColumns self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiMenuColumns_destroy(__arg0);
        }

        public static void ImGuiMenuColumnsUpdate(global::ImGuiSharp.ImGuiMenuColumns self, float spacing, bool window_reappearing)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiMenuColumnsUpdate(__arg0, spacing, window_reappearing);
        }

        public static float ImGuiMenuColumnsDeclColumns(global::ImGuiSharp.ImGuiMenuColumns self, float w_icon, float w_label, float w_shortcut, float w_mark)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiMenuColumnsDeclColumns(__arg0, w_icon, w_label, w_shortcut, w_mark);
            return __ret;
        }

        public static void ImGuiMenuColumnsCalcNextTotalWidth(global::ImGuiSharp.ImGuiMenuColumns self, bool update_offsets)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiMenuColumnsCalcNextTotalWidth(__arg0, update_offsets);
        }

        public static global::ImGuiSharp.ImGuiInputTextState ImGuiInputTextStateImGuiInputTextState()
        {
            var __ret = __Internal.ImGuiInputTextStateImGuiInputTextState();
            var __result0 = global::ImGuiSharp.ImGuiInputTextState.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiInputTextState_destroy(global::ImGuiSharp.ImGuiInputTextState self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextState_destroy(__arg0);
        }

        public static void ImGuiInputTextStateClearText(global::ImGuiSharp.ImGuiInputTextState self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextStateClearText(__arg0);
        }

        public static void ImGuiInputTextStateClearFreeMemory(global::ImGuiSharp.ImGuiInputTextState self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextStateClearFreeMemory(__arg0);
        }

        public static int ImGuiInputTextStateGetUndoAvailCount(global::ImGuiSharp.ImGuiInputTextState self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiInputTextStateGetUndoAvailCount(__arg0);
            return __ret;
        }

        public static int ImGuiInputTextStateGetRedoAvailCount(global::ImGuiSharp.ImGuiInputTextState self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiInputTextStateGetRedoAvailCount(__arg0);
            return __ret;
        }

        public static void ImGuiInputTextStateOnKeyPressed(global::ImGuiSharp.ImGuiInputTextState self, int key)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextStateOnKeyPressed(__arg0, key);
        }

        public static void ImGuiInputTextStateCursorAnimReset(global::ImGuiSharp.ImGuiInputTextState self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextStateCursorAnimReset(__arg0);
        }

        public static void ImGuiInputTextStateCursorClamp(global::ImGuiSharp.ImGuiInputTextState self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextStateCursorClamp(__arg0);
        }

        public static bool ImGuiInputTextStateHasSelection(global::ImGuiSharp.ImGuiInputTextState self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiInputTextStateHasSelection(__arg0);
            return __ret;
        }

        public static void ImGuiInputTextStateClearSelection(global::ImGuiSharp.ImGuiInputTextState self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextStateClearSelection(__arg0);
        }

        public static int ImGuiInputTextStateGetCursorPos(global::ImGuiSharp.ImGuiInputTextState self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiInputTextStateGetCursorPos(__arg0);
            return __ret;
        }

        public static int ImGuiInputTextStateGetSelectionStart(global::ImGuiSharp.ImGuiInputTextState self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiInputTextStateGetSelectionStart(__arg0);
            return __ret;
        }

        public static int ImGuiInputTextStateGetSelectionEnd(global::ImGuiSharp.ImGuiInputTextState self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiInputTextStateGetSelectionEnd(__arg0);
            return __ret;
        }

        public static void ImGuiInputTextStateSelectAll(global::ImGuiSharp.ImGuiInputTextState self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextStateSelectAll(__arg0);
        }

        public static global::ImGuiSharp.ImGuiPopupData ImGuiPopupDataImGuiPopupData()
        {
            var __ret = __Internal.ImGuiPopupDataImGuiPopupData();
            var __result0 = global::ImGuiSharp.ImGuiPopupData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiPopupData_destroy(global::ImGuiSharp.ImGuiPopupData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiPopupData_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImGuiNextWindowData ImGuiNextWindowDataImGuiNextWindowData()
        {
            var __ret = __Internal.ImGuiNextWindowDataImGuiNextWindowData();
            var __result0 = global::ImGuiSharp.ImGuiNextWindowData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiNextWindowData_destroy(global::ImGuiSharp.ImGuiNextWindowData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiNextWindowData_destroy(__arg0);
        }

        public static void ImGuiNextWindowDataClearFlags(global::ImGuiSharp.ImGuiNextWindowData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiNextWindowDataClearFlags(__arg0);
        }

        public static global::ImGuiSharp.ImGuiNextItemData ImGuiNextItemDataImGuiNextItemData()
        {
            var __ret = __Internal.ImGuiNextItemDataImGuiNextItemData();
            var __result0 = global::ImGuiSharp.ImGuiNextItemData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiNextItemData_destroy(global::ImGuiSharp.ImGuiNextItemData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiNextItemData_destroy(__arg0);
        }

        public static void ImGuiNextItemDataClearFlags(global::ImGuiSharp.ImGuiNextItemData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiNextItemDataClearFlags(__arg0);
        }

        public static global::ImGuiSharp.ImGuiLastItemData ImGuiLastItemDataImGuiLastItemData()
        {
            var __ret = __Internal.ImGuiLastItemDataImGuiLastItemData();
            var __result0 = global::ImGuiSharp.ImGuiLastItemData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiLastItemData_destroy(global::ImGuiSharp.ImGuiLastItemData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiLastItemData_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImGuiStackSizes ImGuiStackSizesImGuiStackSizes()
        {
            var __ret = __Internal.ImGuiStackSizesImGuiStackSizes();
            var __result0 = global::ImGuiSharp.ImGuiStackSizes.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiStackSizes_destroy(global::ImGuiSharp.ImGuiStackSizes self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStackSizes_destroy(__arg0);
        }

        public static void ImGuiStackSizesSetToCurrentState(global::ImGuiSharp.ImGuiStackSizes self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStackSizesSetToCurrentState(__arg0);
        }

        public static void ImGuiStackSizesCompareWithCurrentState(global::ImGuiSharp.ImGuiStackSizes self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStackSizesCompareWithCurrentState(__arg0);
        }

        public static global::ImGuiSharp.ImGuiPtrOrIndex ImGuiPtrOrIndexImGuiPtrOrIndexPtr(__IntPtr ptr)
        {
            var __ret = __Internal.ImGuiPtrOrIndexImGuiPtrOrIndexPtr(ptr);
            var __result0 = global::ImGuiSharp.ImGuiPtrOrIndex.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiPtrOrIndex_destroy(global::ImGuiSharp.ImGuiPtrOrIndex self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiPtrOrIndex_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImGuiPtrOrIndex ImGuiPtrOrIndexImGuiPtrOrIndexInt(int index)
        {
            var __ret = __Internal.ImGuiPtrOrIndexImGuiPtrOrIndexInt(index);
            var __result0 = global::ImGuiSharp.ImGuiPtrOrIndex.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::ImGuiSharp.ImGuiInputEvent ImGuiInputEventImGuiInputEvent()
        {
            var __ret = __Internal.ImGuiInputEventImGuiInputEvent();
            var __result0 = global::ImGuiSharp.ImGuiInputEvent.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiInputEvent_destroy(global::ImGuiSharp.ImGuiInputEvent self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputEvent_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImGuiListClipperRange ImGuiListClipperRangeFromIndices(int min, int max)
        {
            var __ret = new global::ImGuiSharp.ImGuiListClipperRange.__Internal();
            __Internal.ImGuiListClipperRangeFromIndices(new IntPtr(&__ret), min, max);
            return global::ImGuiSharp.ImGuiListClipperRange.__CreateInstance(__ret);
        }

        public static global::ImGuiSharp.ImGuiListClipperRange ImGuiListClipperRangeFromPositions(float y1, float y2, int off_min, int off_max)
        {
            var __ret = new global::ImGuiSharp.ImGuiListClipperRange.__Internal();
            __Internal.ImGuiListClipperRangeFromPositions(new IntPtr(&__ret), y1, y2, off_min, off_max);
            return global::ImGuiSharp.ImGuiListClipperRange.__CreateInstance(__ret);
        }

        public static global::ImGuiSharp.ImGuiListClipperData ImGuiListClipperDataImGuiListClipperData()
        {
            var __ret = __Internal.ImGuiListClipperDataImGuiListClipperData();
            var __result0 = global::ImGuiSharp.ImGuiListClipperData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiListClipperData_destroy(global::ImGuiSharp.ImGuiListClipperData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiListClipperData_destroy(__arg0);
        }

        public static void ImGuiListClipperDataReset(global::ImGuiSharp.ImGuiListClipperData self, global::ImGuiSharp.ImGuiListClipper clipper)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = clipper is null ? __IntPtr.Zero : clipper.__Instance;
            __Internal.ImGuiListClipperDataReset(__arg0, __arg1);
        }

        public static global::ImGuiSharp.ImGuiNavItemData ImGuiNavItemDataImGuiNavItemData()
        {
            var __ret = __Internal.ImGuiNavItemDataImGuiNavItemData();
            var __result0 = global::ImGuiSharp.ImGuiNavItemData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiNavItemData_destroy(global::ImGuiSharp.ImGuiNavItemData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiNavItemData_destroy(__arg0);
        }

        public static void ImGuiNavItemDataClear(global::ImGuiSharp.ImGuiNavItemData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiNavItemDataClear(__arg0);
        }

        public static global::ImGuiSharp.ImGuiOldColumnData ImGuiOldColumnDataImGuiOldColumnData()
        {
            var __ret = __Internal.ImGuiOldColumnDataImGuiOldColumnData();
            var __result0 = global::ImGuiSharp.ImGuiOldColumnData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiOldColumnData_destroy(global::ImGuiSharp.ImGuiOldColumnData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiOldColumnData_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImGuiOldColumns ImGuiOldColumnsImGuiOldColumns()
        {
            var __ret = __Internal.ImGuiOldColumnsImGuiOldColumns();
            var __result0 = global::ImGuiSharp.ImGuiOldColumns.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiOldColumns_destroy(global::ImGuiSharp.ImGuiOldColumns self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiOldColumns_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImGuiViewportP ImGuiViewportP_ImGuiViewportP()
        {
            var __ret = __Internal.ImGuiViewportP_ImGuiViewportP();
            var __result0 = global::ImGuiSharp.ImGuiViewportP.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiViewportP_destroy(global::ImGuiSharp.ImGuiViewportP self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiViewportP_destroy(__arg0);
        }

        public static void ImGuiViewportP_CalcWorkRectPos(global::ImGuiSharp.ImVec2 pOut, global::ImGuiSharp.ImGuiViewportP self, global::ImGuiSharp.ImVec2 off_min)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(off_min, null))
                throw new global::System.ArgumentNullException("off_min", "Cannot be null because it is passed by value.");
            var __arg2 = off_min.__Instance;
            __Internal.ImGuiViewportP_CalcWorkRectPos(__arg0, __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2);
        }

        public static void ImGuiViewportP_CalcWorkRectSize(global::ImGuiSharp.ImVec2 pOut, global::ImGuiSharp.ImGuiViewportP self, global::ImGuiSharp.ImVec2 off_min, global::ImGuiSharp.ImVec2 off_max)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(off_min, null))
                throw new global::System.ArgumentNullException("off_min", "Cannot be null because it is passed by value.");
            var __arg2 = off_min.__Instance;
            if (ReferenceEquals(off_max, null))
                throw new global::System.ArgumentNullException("off_max", "Cannot be null because it is passed by value.");
            var __arg3 = off_max.__Instance;
            __Internal.ImGuiViewportP_CalcWorkRectSize(__arg0, __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3);
        }

        public static void ImGuiViewportP_UpdateWorkRect(global::ImGuiSharp.ImGuiViewportP self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiViewportP_UpdateWorkRect(__arg0);
        }

        public static void ImGuiViewportP_GetMainRect(global::ImGuiSharp.ImRect pOut, global::ImGuiSharp.ImGuiViewportP self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiViewportP_GetMainRect(__arg0, __arg1);
        }

        public static void ImGuiViewportP_GetWorkRect(global::ImGuiSharp.ImRect pOut, global::ImGuiSharp.ImGuiViewportP self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiViewportP_GetWorkRect(__arg0, __arg1);
        }

        public static void ImGuiViewportP_GetBuildWorkRect(global::ImGuiSharp.ImRect pOut, global::ImGuiSharp.ImGuiViewportP self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiViewportP_GetBuildWorkRect(__arg0, __arg1);
        }

        public static global::ImGuiSharp.ImGuiWindowSettings ImGuiWindowSettingsImGuiWindowSettings()
        {
            var __ret = __Internal.ImGuiWindowSettingsImGuiWindowSettings();
            var __result0 = global::ImGuiSharp.ImGuiWindowSettings.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiWindowSettings_destroy(global::ImGuiSharp.ImGuiWindowSettings self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiWindowSettings_destroy(__arg0);
        }

        public static sbyte* ImGuiWindowSettingsGetName(global::ImGuiSharp.ImGuiWindowSettings self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiWindowSettingsGetName(__arg0);
            return __ret;
        }

        public static global::ImGuiSharp.ImGuiSettingsHandler ImGuiSettingsHandlerImGuiSettingsHandler()
        {
            var __ret = __Internal.ImGuiSettingsHandlerImGuiSettingsHandler();
            var __result0 = global::ImGuiSharp.ImGuiSettingsHandler.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiSettingsHandler_destroy(global::ImGuiSharp.ImGuiSettingsHandler self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiSettingsHandler_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImGuiMetricsConfig ImGuiMetricsConfigImGuiMetricsConfig()
        {
            var __ret = __Internal.ImGuiMetricsConfigImGuiMetricsConfig();
            var __result0 = global::ImGuiSharp.ImGuiMetricsConfig.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiMetricsConfig_destroy(global::ImGuiSharp.ImGuiMetricsConfig self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiMetricsConfig_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImGuiStackLevelInfo ImGuiStackLevelInfoImGuiStackLevelInfo()
        {
            var __ret = __Internal.ImGuiStackLevelInfoImGuiStackLevelInfo();
            var __result0 = global::ImGuiSharp.ImGuiStackLevelInfo.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiStackLevelInfo_destroy(global::ImGuiSharp.ImGuiStackLevelInfo self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStackLevelInfo_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImGuiStackTool ImGuiStackToolImGuiStackTool()
        {
            var __ret = __Internal.ImGuiStackToolImGuiStackTool();
            var __result0 = global::ImGuiSharp.ImGuiStackTool.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiStackTool_destroy(global::ImGuiSharp.ImGuiStackTool self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStackTool_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImGuiContextHook ImGuiContextHookImGuiContextHook()
        {
            var __ret = __Internal.ImGuiContextHookImGuiContextHook();
            var __result0 = global::ImGuiSharp.ImGuiContextHook.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiContextHook_destroy(global::ImGuiSharp.ImGuiContextHook self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiContextHook_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImGuiContext ImGuiContextImGuiContext(global::ImGuiSharp.ImFontAtlas shared_font_atlas)
        {
            var __arg0 = shared_font_atlas is null ? __IntPtr.Zero : shared_font_atlas.__Instance;
            var __ret = __Internal.ImGuiContextImGuiContext(__arg0);
            var __result0 = global::ImGuiSharp.ImGuiContext.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiContext_destroy(global::ImGuiSharp.ImGuiContext self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiContext_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImGuiWindow ImGuiWindowImGuiWindow(global::ImGuiSharp.ImGuiContext context, string name)
        {
            var __arg0 = context is null ? __IntPtr.Zero : context.__Instance;
            var __ret = __Internal.ImGuiWindowImGuiWindow(__arg0, name);
            var __result0 = global::ImGuiSharp.ImGuiWindow.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiWindow_destroy(global::ImGuiSharp.ImGuiWindow self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiWindow_destroy(__arg0);
        }

        public static uint ImGuiWindowGetID_Str(global::ImGuiSharp.ImGuiWindow self, string str, string str_end)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiWindowGetID_Str(__arg0, str, str_end);
            return __ret;
        }

        public static uint ImGuiWindowGetID_Ptr(global::ImGuiSharp.ImGuiWindow self, __IntPtr ptr)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiWindowGetID_Ptr(__arg0, ptr);
            return __ret;
        }

        public static uint ImGuiWindowGetID_Int(global::ImGuiSharp.ImGuiWindow self, int n)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiWindowGetID_Int(__arg0, n);
            return __ret;
        }

        public static uint ImGuiWindowGetIDNoKeepAliveStr(global::ImGuiSharp.ImGuiWindow self, string str, string str_end)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiWindowGetIDNoKeepAliveStr(__arg0, str, str_end);
            return __ret;
        }

        public static uint ImGuiWindowGetIDNoKeepAlivePtr(global::ImGuiSharp.ImGuiWindow self, __IntPtr ptr)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiWindowGetIDNoKeepAlivePtr(__arg0, ptr);
            return __ret;
        }

        public static uint ImGuiWindowGetIDNoKeepAliveInt(global::ImGuiSharp.ImGuiWindow self, int n)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiWindowGetIDNoKeepAliveInt(__arg0, n);
            return __ret;
        }

        public static uint ImGuiWindowGetIDFromRectangle(global::ImGuiSharp.ImGuiWindow self, global::ImGuiSharp.ImRect r_abs)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(r_abs, null))
                throw new global::System.ArgumentNullException("r_abs", "Cannot be null because it is passed by value.");
            var __arg1 = r_abs.__Instance;
            var __ret = __Internal.ImGuiWindowGetIDFromRectangle(__arg0, __arg1);
            return __ret;
        }

        public static void ImGuiWindowRect(global::ImGuiSharp.ImRect pOut, global::ImGuiSharp.ImGuiWindow self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiWindowRect(__arg0, __arg1);
        }

        public static float ImGuiWindowCalcFontSize(global::ImGuiSharp.ImGuiWindow self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiWindowCalcFontSize(__arg0);
            return __ret;
        }

        public static float ImGuiWindowTitleBarHeight(global::ImGuiSharp.ImGuiWindow self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiWindowTitleBarHeight(__arg0);
            return __ret;
        }

        public static void ImGuiWindowTitleBarRect(global::ImGuiSharp.ImRect pOut, global::ImGuiSharp.ImGuiWindow self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiWindowTitleBarRect(__arg0, __arg1);
        }

        public static float ImGuiWindowMenuBarHeight(global::ImGuiSharp.ImGuiWindow self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiWindowMenuBarHeight(__arg0);
            return __ret;
        }

        public static void ImGuiWindowMenuBarRect(global::ImGuiSharp.ImRect pOut, global::ImGuiSharp.ImGuiWindow self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiWindowMenuBarRect(__arg0, __arg1);
        }

        public static global::ImGuiSharp.ImGuiTabItem ImGuiTabItemImGuiTabItem()
        {
            var __ret = __Internal.ImGuiTabItemImGuiTabItem();
            var __result0 = global::ImGuiSharp.ImGuiTabItem.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiTabItem_destroy(global::ImGuiSharp.ImGuiTabItem self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTabItem_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImGuiTabBar ImGuiTabBarImGuiTabBar()
        {
            var __ret = __Internal.ImGuiTabBarImGuiTabBar();
            var __result0 = global::ImGuiSharp.ImGuiTabBar.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiTabBar_destroy(global::ImGuiSharp.ImGuiTabBar self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTabBar_destroy(__arg0);
        }

        public static int ImGuiTabBarGetTabOrder(global::ImGuiSharp.ImGuiTabBar self, global::ImGuiSharp.ImGuiTabItem tab)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = tab is null ? __IntPtr.Zero : tab.__Instance;
            var __ret = __Internal.ImGuiTabBarGetTabOrder(__arg0, __arg1);
            return __ret;
        }

        public static string ImGuiTabBarGetTabName(global::ImGuiSharp.ImGuiTabBar self, global::ImGuiSharp.ImGuiTabItem tab)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = tab is null ? __IntPtr.Zero : tab.__Instance;
            var __ret = __Internal.ImGuiTabBarGetTabName(__arg0, __arg1);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static global::ImGuiSharp.ImGuiTableColumn ImGuiTableColumnImGuiTableColumn()
        {
            var __ret = __Internal.ImGuiTableColumnImGuiTableColumn();
            var __result0 = global::ImGuiSharp.ImGuiTableColumn.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiTableColumn_destroy(global::ImGuiSharp.ImGuiTableColumn self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTableColumn_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImGuiTable ImGuiTableImGuiTable()
        {
            var __ret = __Internal.ImGuiTableImGuiTable();
            var __result0 = global::ImGuiSharp.ImGuiTable.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiTable_destroy(global::ImGuiSharp.ImGuiTable self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTable_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImGuiTableTempData ImGuiTableTempDataImGuiTableTempData()
        {
            var __ret = __Internal.ImGuiTableTempDataImGuiTableTempData();
            var __result0 = global::ImGuiSharp.ImGuiTableTempData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiTableTempData_destroy(global::ImGuiSharp.ImGuiTableTempData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTableTempData_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImGuiTableColumnSettings ImGuiTableColumnSettingsImGuiTableColumnSettings()
        {
            var __ret = __Internal.ImGuiTableColumnSettingsImGuiTableColumnSettings();
            var __result0 = global::ImGuiSharp.ImGuiTableColumnSettings.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiTableColumnSettings_destroy(global::ImGuiSharp.ImGuiTableColumnSettings self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTableColumnSettings_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImGuiTableSettings ImGuiTableSettingsImGuiTableSettings()
        {
            var __ret = __Internal.ImGuiTableSettingsImGuiTableSettings();
            var __result0 = global::ImGuiSharp.ImGuiTableSettings.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiTableSettings_destroy(global::ImGuiSharp.ImGuiTableSettings self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTableSettings_destroy(__arg0);
        }

        public static global::ImGuiSharp.ImGuiTableColumnSettings ImGuiTableSettingsGetColumnSettings(global::ImGuiSharp.ImGuiTableSettings self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTableSettingsGetColumnSettings(__arg0);
            var __result0 = global::ImGuiSharp.ImGuiTableColumnSettings.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::ImGuiSharp.ImGuiWindow GetCurrentWindowRead()
        {
            var __ret = __Internal.GetCurrentWindowRead();
            var __result0 = global::ImGuiSharp.ImGuiWindow.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::ImGuiSharp.ImGuiWindow GetCurrentWindow()
        {
            var __ret = __Internal.GetCurrentWindow();
            var __result0 = global::ImGuiSharp.ImGuiWindow.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::ImGuiSharp.ImGuiWindow FindWindowByID(uint id)
        {
            var __ret = __Internal.FindWindowByID(id);
            var __result0 = global::ImGuiSharp.ImGuiWindow.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::ImGuiSharp.ImGuiWindow FindWindowByName(string name)
        {
            var __ret = __Internal.FindWindowByName(name);
            var __result0 = global::ImGuiSharp.ImGuiWindow.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void UpdateWindowParentAndRootLinks(global::ImGuiSharp.ImGuiWindow window, int flags, global::ImGuiSharp.ImGuiWindow parent_window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg2 = parent_window is null ? __IntPtr.Zero : parent_window.__Instance;
            __Internal.UpdateWindowParentAndRootLinks(__arg0, flags, __arg2);
        }

        public static void CalcWindowNextAutoFitSize(global::ImGuiSharp.ImVec2 pOut, global::ImGuiSharp.ImGuiWindow window)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.CalcWindowNextAutoFitSize(__arg0, __arg1);
        }

        public static bool IsWindowChildOf(global::ImGuiSharp.ImGuiWindow window, global::ImGuiSharp.ImGuiWindow potential_parent, bool popup_hierarchy)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = potential_parent is null ? __IntPtr.Zero : potential_parent.__Instance;
            var __ret = __Internal.IsWindowChildOf(__arg0, __arg1, popup_hierarchy);
            return __ret;
        }

        public static bool IsWindowWithinBeginStackOf(global::ImGuiSharp.ImGuiWindow window, global::ImGuiSharp.ImGuiWindow potential_parent)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = potential_parent is null ? __IntPtr.Zero : potential_parent.__Instance;
            var __ret = __Internal.IsWindowWithinBeginStackOf(__arg0, __arg1);
            return __ret;
        }

        public static bool IsWindowAbove(global::ImGuiSharp.ImGuiWindow potential_above, global::ImGuiSharp.ImGuiWindow potential_below)
        {
            var __arg0 = potential_above is null ? __IntPtr.Zero : potential_above.__Instance;
            var __arg1 = potential_below is null ? __IntPtr.Zero : potential_below.__Instance;
            var __ret = __Internal.IsWindowAbove(__arg0, __arg1);
            return __ret;
        }

        public static bool IsWindowNavFocusable(global::ImGuiSharp.ImGuiWindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __ret = __Internal.IsWindowNavFocusable(__arg0);
            return __ret;
        }

        public static void SetWindowPosWindowPtr(global::ImGuiSharp.ImGuiWindow window, global::ImGuiSharp.ImVec2 pos, int cond)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            __Internal.SetWindowPosWindowPtr(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, cond);
        }

        public static void SetWindowSizeWindowPtr(global::ImGuiSharp.ImGuiWindow window, global::ImGuiSharp.ImVec2 size, int cond)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            __Internal.SetWindowSizeWindowPtr(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, cond);
        }

        public static void SetWindowCollapsedWindowPtr(global::ImGuiSharp.ImGuiWindow window, bool collapsed, int cond)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.SetWindowCollapsedWindowPtr(__arg0, collapsed, cond);
        }

        public static void SetWindowHitTestHole(global::ImGuiSharp.ImGuiWindow window, global::ImGuiSharp.ImVec2 pos, global::ImGuiSharp.ImVec2 size)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg2 = size.__Instance;
            __Internal.SetWindowHitTestHole(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2);
        }

        public static void WindowRectAbsToRel(global::ImGuiSharp.ImRect pOut, global::ImGuiSharp.ImGuiWindow window, global::ImGuiSharp.ImRect r)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = window is null ? __IntPtr.Zero : window.__Instance;
            if (ReferenceEquals(r, null))
                throw new global::System.ArgumentNullException("r", "Cannot be null because it is passed by value.");
            var __arg2 = r.__Instance;
            __Internal.WindowRectAbsToRel(__arg0, __arg1, __arg2);
        }

        public static void WindowRectRelToAbs(global::ImGuiSharp.ImRect pOut, global::ImGuiSharp.ImGuiWindow window, global::ImGuiSharp.ImRect r)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = window is null ? __IntPtr.Zero : window.__Instance;
            if (ReferenceEquals(r, null))
                throw new global::System.ArgumentNullException("r", "Cannot be null because it is passed by value.");
            var __arg2 = r.__Instance;
            __Internal.WindowRectRelToAbs(__arg0, __arg1, __arg2);
        }

        public static void FocusWindow(global::ImGuiSharp.ImGuiWindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.FocusWindow(__arg0);
        }

        public static void FocusTopMostWindowUnderOne(global::ImGuiSharp.ImGuiWindow under_this_window, global::ImGuiSharp.ImGuiWindow ignore_window)
        {
            var __arg0 = under_this_window is null ? __IntPtr.Zero : under_this_window.__Instance;
            var __arg1 = ignore_window is null ? __IntPtr.Zero : ignore_window.__Instance;
            __Internal.FocusTopMostWindowUnderOne(__arg0, __arg1);
        }

        public static void BringWindowToFocusFront(global::ImGuiSharp.ImGuiWindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.BringWindowToFocusFront(__arg0);
        }

        public static void BringWindowToDisplayFront(global::ImGuiSharp.ImGuiWindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.BringWindowToDisplayFront(__arg0);
        }

        public static void BringWindowToDisplayBack(global::ImGuiSharp.ImGuiWindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.BringWindowToDisplayBack(__arg0);
        }

        public static void BringWindowToDisplayBehind(global::ImGuiSharp.ImGuiWindow window, global::ImGuiSharp.ImGuiWindow above_window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = above_window is null ? __IntPtr.Zero : above_window.__Instance;
            __Internal.BringWindowToDisplayBehind(__arg0, __arg1);
        }

        public static int FindWindowDisplayIndex(global::ImGuiSharp.ImGuiWindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __ret = __Internal.FindWindowDisplayIndex(__arg0);
            return __ret;
        }

        public static global::ImGuiSharp.ImGuiWindow FindBottomMostVisibleWindowWithinBeginStack(global::ImGuiSharp.ImGuiWindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __ret = __Internal.FindBottomMostVisibleWindowWithinBeginStack(__arg0);
            var __result0 = global::ImGuiSharp.ImGuiWindow.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void SetCurrentFont(global::ImGuiSharp.ImFont font)
        {
            var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
            __Internal.SetCurrentFont(__arg0);
        }

        public static global::ImGuiSharp.ImFont GetDefaultFont()
        {
            var __ret = __Internal.GetDefaultFont();
            var __result0 = global::ImGuiSharp.ImFont.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::ImGuiSharp.ImDrawList GetForegroundDrawListWindowPtr(global::ImGuiSharp.ImGuiWindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GetForegroundDrawListWindowPtr(__arg0);
            var __result0 = global::ImGuiSharp.ImDrawList.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::ImGuiSharp.ImDrawList GetBackgroundDrawListViewportPtr(global::ImGuiSharp.ImGuiViewport viewport)
        {
            var __arg0 = viewport is null ? __IntPtr.Zero : viewport.__Instance;
            var __ret = __Internal.GetBackgroundDrawListViewportPtr(__arg0);
            var __result0 = global::ImGuiSharp.ImDrawList.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::ImGuiSharp.ImDrawList GetForegroundDrawListViewportPtr(global::ImGuiSharp.ImGuiViewport viewport)
        {
            var __arg0 = viewport is null ? __IntPtr.Zero : viewport.__Instance;
            var __ret = __Internal.GetForegroundDrawListViewportPtr(__arg0);
            var __result0 = global::ImGuiSharp.ImDrawList.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void Initialize(global::ImGuiSharp.ImGuiContext context)
        {
            var __arg0 = context is null ? __IntPtr.Zero : context.__Instance;
            __Internal.Initialize(__arg0);
        }

        public static void Shutdown(global::ImGuiSharp.ImGuiContext context)
        {
            var __arg0 = context is null ? __IntPtr.Zero : context.__Instance;
            __Internal.Shutdown(__arg0);
        }

        public static void UpdateInputEvents(bool trickle_fast_inputs)
        {
            __Internal.UpdateInputEvents(trickle_fast_inputs);
        }

        public static void UpdateHoveredWindowAndCaptureFlags()
        {
            __Internal.UpdateHoveredWindowAndCaptureFlags();
        }

        public static void StartMouseMovingWindow(global::ImGuiSharp.ImGuiWindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.StartMouseMovingWindow(__arg0);
        }

        public static void UpdateMouseMovingWindowNewFrame()
        {
            __Internal.UpdateMouseMovingWindowNewFrame();
        }

        public static void UpdateMouseMovingWindowEndFrame()
        {
            __Internal.UpdateMouseMovingWindowEndFrame();
        }

        public static uint AddContextHook(global::ImGuiSharp.ImGuiContext context, global::ImGuiSharp.ImGuiContextHook hook)
        {
            var __arg0 = context is null ? __IntPtr.Zero : context.__Instance;
            var __arg1 = hook is null ? __IntPtr.Zero : hook.__Instance;
            var __ret = __Internal.AddContextHook(__arg0, __arg1);
            return __ret;
        }

        public static void RemoveContextHook(global::ImGuiSharp.ImGuiContext context, uint hook_to_remove)
        {
            var __arg0 = context is null ? __IntPtr.Zero : context.__Instance;
            __Internal.RemoveContextHook(__arg0, hook_to_remove);
        }

        public static void CallContextHooks(global::ImGuiSharp.ImGuiContext context, global::ImGuiSharp.ImGuiContextHookType type)
        {
            var __arg0 = context is null ? __IntPtr.Zero : context.__Instance;
            __Internal.CallContextHooks(__arg0, type);
        }

        public static void MarkIniSettingsDirtyNil()
        {
            __Internal.MarkIniSettingsDirtyNil();
        }

        public static void MarkIniSettingsDirtyWindowPtr(global::ImGuiSharp.ImGuiWindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.MarkIniSettingsDirtyWindowPtr(__arg0);
        }

        public static void ClearIniSettings()
        {
            __Internal.ClearIniSettings();
        }

        public static global::ImGuiSharp.ImGuiWindowSettings CreateNewWindowSettings(string name)
        {
            var __ret = __Internal.CreateNewWindowSettings(name);
            var __result0 = global::ImGuiSharp.ImGuiWindowSettings.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::ImGuiSharp.ImGuiWindowSettings FindWindowSettings(uint id)
        {
            var __ret = __Internal.FindWindowSettings(id);
            var __result0 = global::ImGuiSharp.ImGuiWindowSettings.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::ImGuiSharp.ImGuiWindowSettings FindOrCreateWindowSettings(string name)
        {
            var __ret = __Internal.FindOrCreateWindowSettings(name);
            var __result0 = global::ImGuiSharp.ImGuiWindowSettings.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::ImGuiSharp.ImGuiSettingsHandler FindSettingsHandler(string type_name)
        {
            var __ret = __Internal.FindSettingsHandler(type_name);
            var __result0 = global::ImGuiSharp.ImGuiSettingsHandler.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void SetNextWindowScroll(global::ImGuiSharp.ImVec2 scroll)
        {
            if (ReferenceEquals(scroll, null))
                throw new global::System.ArgumentNullException("scroll", "Cannot be null because it is passed by value.");
            var __arg0 = scroll.__Instance;
            __Internal.SetNextWindowScroll(*(global::ImGuiSharp.ImVec2.__Internal*) __arg0);
        }

        public static void SetScrollX_WindowPtr(global::ImGuiSharp.ImGuiWindow window, float scroll_x)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.SetScrollX_WindowPtr(__arg0, scroll_x);
        }

        public static void SetScrollY_WindowPtr(global::ImGuiSharp.ImGuiWindow window, float scroll_y)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.SetScrollY_WindowPtr(__arg0, scroll_y);
        }

        public static void SetScrollFromPosX_WindowPtr(global::ImGuiSharp.ImGuiWindow window, float local_x, float center_x_ratio)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.SetScrollFromPosX_WindowPtr(__arg0, local_x, center_x_ratio);
        }

        public static void SetScrollFromPosY_WindowPtr(global::ImGuiSharp.ImGuiWindow window, float local_y, float center_y_ratio)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.SetScrollFromPosY_WindowPtr(__arg0, local_y, center_y_ratio);
        }

        public static void ScrollToItem(int flags)
        {
            __Internal.ScrollToItem(flags);
        }

        public static void ScrollToRect(global::ImGuiSharp.ImGuiWindow window, global::ImGuiSharp.ImRect rect, int flags)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            if (ReferenceEquals(rect, null))
                throw new global::System.ArgumentNullException("rect", "Cannot be null because it is passed by value.");
            var __arg1 = rect.__Instance;
            __Internal.ScrollToRect(__arg0, __arg1, flags);
        }

        public static void ScrollToRectEx(global::ImGuiSharp.ImVec2 pOut, global::ImGuiSharp.ImGuiWindow window, global::ImGuiSharp.ImRect rect, int flags)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = window is null ? __IntPtr.Zero : window.__Instance;
            if (ReferenceEquals(rect, null))
                throw new global::System.ArgumentNullException("rect", "Cannot be null because it is passed by value.");
            var __arg2 = rect.__Instance;
            __Internal.ScrollToRectEx(__arg0, __arg1, __arg2, flags);
        }

        public static void ScrollToBringRectIntoView(global::ImGuiSharp.ImGuiWindow window, global::ImGuiSharp.ImRect rect)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            if (ReferenceEquals(rect, null))
                throw new global::System.ArgumentNullException("rect", "Cannot be null because it is passed by value.");
            var __arg1 = rect.__Instance;
            __Internal.ScrollToBringRectIntoView(__arg0, __arg1);
        }

        public static uint GetItemID()
        {
            var __ret = __Internal.GetItemID();
            return __ret;
        }

        public static int GetItemStatusFlags()
        {
            var __ret = __Internal.GetItemStatusFlags();
            return __ret;
        }

        public static int GetItemFlags()
        {
            var __ret = __Internal.GetItemFlags();
            return __ret;
        }

        public static uint GetActiveID()
        {
            var __ret = __Internal.GetActiveID();
            return __ret;
        }

        public static uint GetFocusID()
        {
            var __ret = __Internal.GetFocusID();
            return __ret;
        }

        public static void SetActiveID(uint id, global::ImGuiSharp.ImGuiWindow window)
        {
            var __arg1 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.SetActiveID(id, __arg1);
        }

        public static void SetFocusID(uint id, global::ImGuiSharp.ImGuiWindow window)
        {
            var __arg1 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.SetFocusID(id, __arg1);
        }

        public static void ClearActiveID()
        {
            __Internal.ClearActiveID();
        }

        public static uint GetHoveredID()
        {
            var __ret = __Internal.GetHoveredID();
            return __ret;
        }

        public static void SetHoveredID(uint id)
        {
            __Internal.SetHoveredID(id);
        }

        public static void KeepAliveID(uint id)
        {
            __Internal.KeepAliveID(id);
        }

        public static void MarkItemEdited(uint id)
        {
            __Internal.MarkItemEdited(id);
        }

        public static void PushOverrideID(uint id)
        {
            __Internal.PushOverrideID(id);
        }

        public static uint GetIDWithSeed(string str_id_begin, string str_id_end, uint seed)
        {
            var __ret = __Internal.GetIDWithSeed(str_id_begin, str_id_end, seed);
            return __ret;
        }

        public static void ItemSizeVec2(global::ImGuiSharp.ImVec2 size, float text_baseline_y)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg0 = size.__Instance;
            __Internal.ItemSizeVec2(*(global::ImGuiSharp.ImVec2.__Internal*) __arg0, text_baseline_y);
        }

        public static void ItemSizeRect(global::ImGuiSharp.ImRect bb, float text_baseline_y)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            __Internal.ItemSizeRect(__arg0, text_baseline_y);
        }

        public static bool ItemAdd(global::ImGuiSharp.ImRect bb, uint id, global::ImGuiSharp.ImRect nav_bb, int extra_flags)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            var __arg2 = nav_bb is null ? __IntPtr.Zero : nav_bb.__Instance;
            var __ret = __Internal.ItemAdd(__arg0, id, __arg2, extra_flags);
            return __ret;
        }

        public static bool ItemHoverable(global::ImGuiSharp.ImRect bb, uint id)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            var __ret = __Internal.ItemHoverable(__arg0, id);
            return __ret;
        }

        public static bool IsClippedEx(global::ImGuiSharp.ImRect bb, uint id)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            var __ret = __Internal.IsClippedEx(__arg0, id);
            return __ret;
        }

        public static void SetLastItemData(uint item_id, int in_flags, int status_flags, global::ImGuiSharp.ImRect item_rect)
        {
            if (ReferenceEquals(item_rect, null))
                throw new global::System.ArgumentNullException("item_rect", "Cannot be null because it is passed by value.");
            var __arg3 = item_rect.__Instance;
            __Internal.SetLastItemData(item_id, in_flags, status_flags, __arg3);
        }

        public static void CalcItemSize(global::ImGuiSharp.ImVec2 pOut, global::ImGuiSharp.ImVec2 size, float default_w, float default_h)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            __Internal.CalcItemSize(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, default_w, default_h);
        }

        public static float CalcWrapWidthForPos(global::ImGuiSharp.ImVec2 pos, float wrap_pos_x)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg0 = pos.__Instance;
            var __ret = __Internal.CalcWrapWidthForPos(*(global::ImGuiSharp.ImVec2.__Internal*) __arg0, wrap_pos_x);
            return __ret;
        }

        public static void PushMultiItemsWidths(int components, float width_full)
        {
            __Internal.PushMultiItemsWidths(components, width_full);
        }

        public static bool IsItemToggledSelection()
        {
            var __ret = __Internal.IsItemToggledSelection();
            return __ret;
        }

        public static void GetContentRegionMaxAbs(global::ImGuiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetContentRegionMaxAbs(__arg0);
        }

        public static void ShrinkWidths(global::ImGuiSharp.ImGuiShrinkWidthItem items, int count, float width_excess)
        {
            var __arg0 = items is null ? __IntPtr.Zero : items.__Instance;
            __Internal.ShrinkWidths(__arg0, count, width_excess);
        }

        public static void PushItemFlag(int option, bool enabled)
        {
            __Internal.PushItemFlag(option, enabled);
        }

        public static void PopItemFlag()
        {
            __Internal.PopItemFlag();
        }

        public static void LogBegin(global::ImGuiSharp.ImGuiLogType type, int auto_open_depth)
        {
            __Internal.LogBegin(type, auto_open_depth);
        }

        public static void LogToBuffer(int auto_open_depth)
        {
            __Internal.LogToBuffer(auto_open_depth);
        }

        public static void LogRenderedText(global::ImGuiSharp.ImVec2 ref_pos, string text, string text_end)
        {
            var __arg0 = ref_pos is null ? __IntPtr.Zero : ref_pos.__Instance;
            __Internal.LogRenderedText(__arg0, text, text_end);
        }

        public static void LogSetNextTextDecoration(string prefix, string suffix)
        {
            __Internal.LogSetNextTextDecoration(prefix, suffix);
        }

        public static bool BeginChildEx(string name, uint id, global::ImGuiSharp.ImVec2 size_arg, bool border, int flags)
        {
            if (ReferenceEquals(size_arg, null))
                throw new global::System.ArgumentNullException("size_arg", "Cannot be null because it is passed by value.");
            var __arg2 = size_arg.__Instance;
            var __ret = __Internal.BeginChildEx(name, id, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, border, flags);
            return __ret;
        }

        public static void OpenPopupEx(uint id, int popup_flags)
        {
            __Internal.OpenPopupEx(id, popup_flags);
        }

        public static void ClosePopupToLevel(int remaining, bool restore_focus_to_window_under_popup)
        {
            __Internal.ClosePopupToLevel(remaining, restore_focus_to_window_under_popup);
        }

        public static void ClosePopupsOverWindow(global::ImGuiSharp.ImGuiWindow ref_window, bool restore_focus_to_window_under_popup)
        {
            var __arg0 = ref_window is null ? __IntPtr.Zero : ref_window.__Instance;
            __Internal.ClosePopupsOverWindow(__arg0, restore_focus_to_window_under_popup);
        }

        public static void ClosePopupsExceptModals()
        {
            __Internal.ClosePopupsExceptModals();
        }

        public static bool IsPopupOpenID(uint id, int popup_flags)
        {
            var __ret = __Internal.IsPopupOpenID(id, popup_flags);
            return __ret;
        }

        public static bool BeginPopupEx(uint id, int extra_flags)
        {
            var __ret = __Internal.BeginPopupEx(id, extra_flags);
            return __ret;
        }

        public static void BeginTooltipEx(int tooltip_flags, int extra_window_flags)
        {
            __Internal.BeginTooltipEx(tooltip_flags, extra_window_flags);
        }

        public static void GetPopupAllowedExtentRect(global::ImGuiSharp.ImRect pOut, global::ImGuiSharp.ImGuiWindow window)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.GetPopupAllowedExtentRect(__arg0, __arg1);
        }

        public static global::ImGuiSharp.ImGuiWindow GetTopMostPopupModal()
        {
            var __ret = __Internal.GetTopMostPopupModal();
            var __result0 = global::ImGuiSharp.ImGuiWindow.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::ImGuiSharp.ImGuiWindow GetTopMostAndVisiblePopupModal()
        {
            var __ret = __Internal.GetTopMostAndVisiblePopupModal();
            var __result0 = global::ImGuiSharp.ImGuiWindow.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void FindBestWindowPosForPopup(global::ImGuiSharp.ImVec2 pOut, global::ImGuiSharp.ImGuiWindow window)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.FindBestWindowPosForPopup(__arg0, __arg1);
        }

        public static void FindBestWindowPosForPopupEx(global::ImGuiSharp.ImVec2 pOut, global::ImGuiSharp.ImVec2 ref_pos, global::ImGuiSharp.ImVec2 size, ref int last_dir, global::ImGuiSharp.ImRect r_outer, global::ImGuiSharp.ImRect r_avoid, global::ImGuiSharp.ImGuiPopupPositionPolicy policy)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(ref_pos, null))
                throw new global::System.ArgumentNullException("ref_pos", "Cannot be null because it is passed by value.");
            var __arg1 = ref_pos.__Instance;
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg2 = size.__Instance;
            fixed (int* __last_dir3 = &last_dir)
            {
                var __arg3 = __last_dir3;
                if (ReferenceEquals(r_outer, null))
                    throw new global::System.ArgumentNullException("r_outer", "Cannot be null because it is passed by value.");
                var __arg4 = r_outer.__Instance;
                if (ReferenceEquals(r_avoid, null))
                    throw new global::System.ArgumentNullException("r_avoid", "Cannot be null because it is passed by value.");
                var __arg5 = r_avoid.__Instance;
                __Internal.FindBestWindowPosForPopupEx(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, __arg3, __arg4, __arg5, policy);
            }
        }

        public static bool BeginViewportSideBar(string name, global::ImGuiSharp.ImGuiViewport viewport, int dir, float size, int window_flags)
        {
            var __arg1 = viewport is null ? __IntPtr.Zero : viewport.__Instance;
            var __ret = __Internal.BeginViewportSideBar(name, __arg1, dir, size, window_flags);
            return __ret;
        }

        public static bool BeginMenuEx(string label, string icon, bool enabled)
        {
            var __ret = __Internal.BeginMenuEx(label, icon, enabled);
            return __ret;
        }

        public static bool MenuItemEx(string label, string icon, string shortcut, bool selected, bool enabled)
        {
            var __ret = __Internal.MenuItemEx(label, icon, shortcut, selected, enabled);
            return __ret;
        }

        public static bool BeginComboPopup(uint popup_id, global::ImGuiSharp.ImRect bb, int flags)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg1 = bb.__Instance;
            var __ret = __Internal.BeginComboPopup(popup_id, __arg1, flags);
            return __ret;
        }

        public static bool BeginComboPreview()
        {
            var __ret = __Internal.BeginComboPreview();
            return __ret;
        }

        public static void EndComboPreview()
        {
            __Internal.EndComboPreview();
        }

        public static void NavInitWindow(global::ImGuiSharp.ImGuiWindow window, bool force_reinit)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.NavInitWindow(__arg0, force_reinit);
        }

        public static void NavInitRequestApplyResult()
        {
            __Internal.NavInitRequestApplyResult();
        }

        public static bool NavMoveRequestButNoResultYet()
        {
            var __ret = __Internal.NavMoveRequestButNoResultYet();
            return __ret;
        }

        public static void NavMoveRequestSubmit(int move_dir, int clip_dir, int move_flags, int scroll_flags)
        {
            __Internal.NavMoveRequestSubmit(move_dir, clip_dir, move_flags, scroll_flags);
        }

        public static void NavMoveRequestForward(int move_dir, int clip_dir, int move_flags, int scroll_flags)
        {
            __Internal.NavMoveRequestForward(move_dir, clip_dir, move_flags, scroll_flags);
        }

        public static void NavMoveRequestResolveWithLastItem(global::ImGuiSharp.ImGuiNavItemData result)
        {
            var __arg0 = result is null ? __IntPtr.Zero : result.__Instance;
            __Internal.NavMoveRequestResolveWithLastItem(__arg0);
        }

        public static void NavMoveRequestCancel()
        {
            __Internal.NavMoveRequestCancel();
        }

        public static void NavMoveRequestApplyResult()
        {
            __Internal.NavMoveRequestApplyResult();
        }

        public static void NavMoveRequestTryWrapping(global::ImGuiSharp.ImGuiWindow window, int move_flags)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.NavMoveRequestTryWrapping(__arg0, move_flags);
        }

        public static string GetNavInputName(int n)
        {
            var __ret = __Internal.GetNavInputName(n);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static float GetNavInputAmount(int n, global::ImGuiSharp.ImGuiInputReadMode mode)
        {
            var __ret = __Internal.GetNavInputAmount(n, mode);
            return __ret;
        }

        public static void GetNavInputAmount2d(global::ImGuiSharp.ImVec2 pOut, int dir_sources, global::ImGuiSharp.ImGuiInputReadMode mode, float slow_factor, float fast_factor)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetNavInputAmount2d(__arg0, dir_sources, mode, slow_factor, fast_factor);
        }

        public static int CalcTypematicRepeatAmount(float t0, float t1, float repeat_delay, float repeat_rate)
        {
            var __ret = __Internal.CalcTypematicRepeatAmount(t0, t1, repeat_delay, repeat_rate);
            return __ret;
        }

        public static void ActivateItem(uint id)
        {
            __Internal.ActivateItem(id);
        }

        public static void SetNavID(uint id, global::ImGuiSharp.ImGuiNavLayer nav_layer, uint focus_scope_id, global::ImGuiSharp.ImRect rect_rel)
        {
            if (ReferenceEquals(rect_rel, null))
                throw new global::System.ArgumentNullException("rect_rel", "Cannot be null because it is passed by value.");
            var __arg3 = rect_rel.__Instance;
            __Internal.SetNavID(id, nav_layer, focus_scope_id, __arg3);
        }

        public static void PushFocusScope(uint id)
        {
            __Internal.PushFocusScope(id);
        }

        public static void PopFocusScope()
        {
            __Internal.PopFocusScope();
        }

        public static uint GetFocusedFocusScope()
        {
            var __ret = __Internal.GetFocusedFocusScope();
            return __ret;
        }

        public static uint GetFocusScope()
        {
            var __ret = __Internal.GetFocusScope();
            return __ret;
        }

        public static bool IsNamedKey(int key)
        {
            var __ret = __Internal.IsNamedKey(key);
            return __ret;
        }

        public static bool IsLegacyKey(int key)
        {
            var __ret = __Internal.IsLegacyKey(key);
            return __ret;
        }

        public static bool IsGamepadKey(int key)
        {
            var __ret = __Internal.IsGamepadKey(key);
            return __ret;
        }

        public static global::ImGuiSharp.ImGuiKeyData GetKeyData(int key)
        {
            var __ret = __Internal.GetKeyData(key);
            var __result0 = global::ImGuiSharp.ImGuiKeyData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void SetItemUsingMouseWheel()
        {
            __Internal.SetItemUsingMouseWheel();
        }

        public static void SetActiveIdUsingNavAndKeys()
        {
            __Internal.SetActiveIdUsingNavAndKeys();
        }

        public static bool IsActiveIdUsingNavDir(int dir)
        {
            var __ret = __Internal.IsActiveIdUsingNavDir(dir);
            return __ret;
        }

        public static bool IsActiveIdUsingNavInput(int input)
        {
            var __ret = __Internal.IsActiveIdUsingNavInput(input);
            return __ret;
        }

        public static bool IsActiveIdUsingKey(int key)
        {
            var __ret = __Internal.IsActiveIdUsingKey(key);
            return __ret;
        }

        public static void SetActiveIdUsingKey(int key)
        {
            __Internal.SetActiveIdUsingKey(key);
        }

        public static bool IsMouseDragPastThreshold(int button, float lock_threshold)
        {
            var __ret = __Internal.IsMouseDragPastThreshold(button, lock_threshold);
            return __ret;
        }

        public static bool IsNavInputDown(int n)
        {
            var __ret = __Internal.IsNavInputDown(n);
            return __ret;
        }

        public static bool IsNavInputTest(int n, global::ImGuiSharp.ImGuiInputReadMode rm)
        {
            var __ret = __Internal.IsNavInputTest(n, rm);
            return __ret;
        }

        public static int GetMergedKeyModFlags()
        {
            var __ret = __Internal.GetMergedKeyModFlags();
            return __ret;
        }

        public static bool IsKeyPressedMap(int key, bool repeat)
        {
            var __ret = __Internal.IsKeyPressedMap(key, repeat);
            return __ret;
        }

        public static bool BeginDragDropTargetCustom(global::ImGuiSharp.ImRect bb, uint id)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            var __ret = __Internal.BeginDragDropTargetCustom(__arg0, id);
            return __ret;
        }

        public static void ClearDragDrop()
        {
            __Internal.ClearDragDrop();
        }

        public static bool IsDragDropPayloadBeingAccepted()
        {
            var __ret = __Internal.IsDragDropPayloadBeingAccepted();
            return __ret;
        }

        public static void SetWindowClipRectBeforeSetChannel(global::ImGuiSharp.ImGuiWindow window, global::ImGuiSharp.ImRect clip_rect)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            if (ReferenceEquals(clip_rect, null))
                throw new global::System.ArgumentNullException("clip_rect", "Cannot be null because it is passed by value.");
            var __arg1 = clip_rect.__Instance;
            __Internal.SetWindowClipRectBeforeSetChannel(__arg0, __arg1);
        }

        public static void BeginColumns(string str_id, int count, int flags)
        {
            __Internal.BeginColumns(str_id, count, flags);
        }

        public static void EndColumns()
        {
            __Internal.EndColumns();
        }

        public static void PushColumnClipRect(int column_index)
        {
            __Internal.PushColumnClipRect(column_index);
        }

        public static void PushColumnsBackground()
        {
            __Internal.PushColumnsBackground();
        }

        public static void PopColumnsBackground()
        {
            __Internal.PopColumnsBackground();
        }

        public static uint GetColumnsID(string str_id, int count)
        {
            var __ret = __Internal.GetColumnsID(str_id, count);
            return __ret;
        }

        public static global::ImGuiSharp.ImGuiOldColumns FindOrCreateColumns(global::ImGuiSharp.ImGuiWindow window, uint id)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __ret = __Internal.FindOrCreateColumns(__arg0, id);
            var __result0 = global::ImGuiSharp.ImGuiOldColumns.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static float GetColumnOffsetFromNorm(global::ImGuiSharp.ImGuiOldColumns columns, float offset_norm)
        {
            var __arg0 = columns is null ? __IntPtr.Zero : columns.__Instance;
            var __ret = __Internal.GetColumnOffsetFromNorm(__arg0, offset_norm);
            return __ret;
        }

        public static float GetColumnNormFromOffset(global::ImGuiSharp.ImGuiOldColumns columns, float offset)
        {
            var __arg0 = columns is null ? __IntPtr.Zero : columns.__Instance;
            var __ret = __Internal.GetColumnNormFromOffset(__arg0, offset);
            return __ret;
        }

        public static void TableOpenContextMenu(int column_n)
        {
            __Internal.TableOpenContextMenu(column_n);
        }

        public static void TableSetColumnWidth(int column_n, float width)
        {
            __Internal.TableSetColumnWidth(column_n, width);
        }

        public static void TableSetColumnSortDirection(int column_n, int sort_direction, bool append_to_sort_specs)
        {
            __Internal.TableSetColumnSortDirection(column_n, sort_direction, append_to_sort_specs);
        }

        public static int TableGetHoveredColumn()
        {
            var __ret = __Internal.TableGetHoveredColumn();
            return __ret;
        }

        public static float TableGetHeaderRowHeight()
        {
            var __ret = __Internal.TableGetHeaderRowHeight();
            return __ret;
        }

        public static void TablePushBackgroundChannel()
        {
            __Internal.TablePushBackgroundChannel();
        }

        public static void TablePopBackgroundChannel()
        {
            __Internal.TablePopBackgroundChannel();
        }

        public static global::ImGuiSharp.ImGuiTable GetCurrentTable()
        {
            var __ret = __Internal.GetCurrentTable();
            var __result0 = global::ImGuiSharp.ImGuiTable.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::ImGuiSharp.ImGuiTable TableFindByID(uint id)
        {
            var __ret = __Internal.TableFindByID(id);
            var __result0 = global::ImGuiSharp.ImGuiTable.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static bool BeginTableEx(string name, uint id, int columns_count, int flags, global::ImGuiSharp.ImVec2 outer_size, float inner_width)
        {
            if (ReferenceEquals(outer_size, null))
                throw new global::System.ArgumentNullException("outer_size", "Cannot be null because it is passed by value.");
            var __arg4 = outer_size.__Instance;
            var __ret = __Internal.BeginTableEx(name, id, columns_count, flags, *(global::ImGuiSharp.ImVec2.__Internal*) __arg4, inner_width);
            return __ret;
        }

        public static void TableBeginInitMemory(global::ImGuiSharp.ImGuiTable table, int columns_count)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableBeginInitMemory(__arg0, columns_count);
        }

        public static void TableBeginApplyRequests(global::ImGuiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableBeginApplyRequests(__arg0);
        }

        public static void TableSetupDrawChannels(global::ImGuiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableSetupDrawChannels(__arg0);
        }

        public static void TableUpdateLayout(global::ImGuiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableUpdateLayout(__arg0);
        }

        public static void TableUpdateBorders(global::ImGuiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableUpdateBorders(__arg0);
        }

        public static void TableUpdateColumnsWeightFromWidth(global::ImGuiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableUpdateColumnsWeightFromWidth(__arg0);
        }

        public static void TableDrawBorders(global::ImGuiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableDrawBorders(__arg0);
        }

        public static void TableDrawContextMenu(global::ImGuiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableDrawContextMenu(__arg0);
        }

        public static void TableMergeDrawChannels(global::ImGuiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableMergeDrawChannels(__arg0);
        }

        public static void TableSortSpecsSanitize(global::ImGuiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableSortSpecsSanitize(__arg0);
        }

        public static void TableSortSpecsBuild(global::ImGuiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableSortSpecsBuild(__arg0);
        }

        public static int TableGetColumnNextSortDirection(global::ImGuiSharp.ImGuiTableColumn column)
        {
            var __arg0 = column is null ? __IntPtr.Zero : column.__Instance;
            var __ret = __Internal.TableGetColumnNextSortDirection(__arg0);
            return __ret;
        }

        public static void TableFixColumnSortDirection(global::ImGuiSharp.ImGuiTable table, global::ImGuiSharp.ImGuiTableColumn column)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            var __arg1 = column is null ? __IntPtr.Zero : column.__Instance;
            __Internal.TableFixColumnSortDirection(__arg0, __arg1);
        }

        public static float TableGetColumnWidthAuto(global::ImGuiSharp.ImGuiTable table, global::ImGuiSharp.ImGuiTableColumn column)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            var __arg1 = column is null ? __IntPtr.Zero : column.__Instance;
            var __ret = __Internal.TableGetColumnWidthAuto(__arg0, __arg1);
            return __ret;
        }

        public static void TableBeginRow(global::ImGuiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableBeginRow(__arg0);
        }

        public static void TableEndRow(global::ImGuiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableEndRow(__arg0);
        }

        public static void TableBeginCell(global::ImGuiSharp.ImGuiTable table, int column_n)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableBeginCell(__arg0, column_n);
        }

        public static void TableEndCell(global::ImGuiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableEndCell(__arg0);
        }

        public static void TableGetCellBgRect(global::ImGuiSharp.ImRect pOut, global::ImGuiSharp.ImGuiTable table, int column_n)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableGetCellBgRect(__arg0, __arg1, column_n);
        }

        public static string TableGetColumnNameTablePtr(global::ImGuiSharp.ImGuiTable table, int column_n)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            var __ret = __Internal.TableGetColumnNameTablePtr(__arg0, column_n);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static uint TableGetColumnResizeID(global::ImGuiSharp.ImGuiTable table, int column_n, int instance_no)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            var __ret = __Internal.TableGetColumnResizeID(__arg0, column_n, instance_no);
            return __ret;
        }

        public static float TableGetMaxColumnWidth(global::ImGuiSharp.ImGuiTable table, int column_n)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            var __ret = __Internal.TableGetMaxColumnWidth(__arg0, column_n);
            return __ret;
        }

        public static void TableSetColumnWidthAutoSingle(global::ImGuiSharp.ImGuiTable table, int column_n)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableSetColumnWidthAutoSingle(__arg0, column_n);
        }

        public static void TableSetColumnWidthAutoAll(global::ImGuiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableSetColumnWidthAutoAll(__arg0);
        }

        public static void TableRemove(global::ImGuiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableRemove(__arg0);
        }

        public static void TableGcCompactTransientBuffersTablePtr(global::ImGuiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableGcCompactTransientBuffersTablePtr(__arg0);
        }

        public static void TableGcCompactTransientBuffersTableTempDataPtr(global::ImGuiSharp.ImGuiTableTempData table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableGcCompactTransientBuffersTableTempDataPtr(__arg0);
        }

        public static void TableGcCompactSettings()
        {
            __Internal.TableGcCompactSettings();
        }

        public static void TableLoadSettings(global::ImGuiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableLoadSettings(__arg0);
        }

        public static void TableSaveSettings(global::ImGuiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableSaveSettings(__arg0);
        }

        public static void TableResetSettings(global::ImGuiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableResetSettings(__arg0);
        }

        public static global::ImGuiSharp.ImGuiTableSettings TableGetBoundSettings(global::ImGuiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            var __ret = __Internal.TableGetBoundSettings(__arg0);
            var __result0 = global::ImGuiSharp.ImGuiTableSettings.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void TableSettingsInstallHandler(global::ImGuiSharp.ImGuiContext context)
        {
            var __arg0 = context is null ? __IntPtr.Zero : context.__Instance;
            __Internal.TableSettingsInstallHandler(__arg0);
        }

        public static global::ImGuiSharp.ImGuiTableSettings TableSettingsCreate(uint id, int columns_count)
        {
            var __ret = __Internal.TableSettingsCreate(id, columns_count);
            var __result0 = global::ImGuiSharp.ImGuiTableSettings.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::ImGuiSharp.ImGuiTableSettings TableSettingsFindByID(uint id)
        {
            var __ret = __Internal.TableSettingsFindByID(id);
            var __result0 = global::ImGuiSharp.ImGuiTableSettings.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static bool BeginTabBarEx(global::ImGuiSharp.ImGuiTabBar tab_bar, global::ImGuiSharp.ImRect bb, int flags)
        {
            var __arg0 = tab_bar is null ? __IntPtr.Zero : tab_bar.__Instance;
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg1 = bb.__Instance;
            var __ret = __Internal.BeginTabBarEx(__arg0, __arg1, flags);
            return __ret;
        }

        public static global::ImGuiSharp.ImGuiTabItem TabBarFindTabByID(global::ImGuiSharp.ImGuiTabBar tab_bar, uint tab_id)
        {
            var __arg0 = tab_bar is null ? __IntPtr.Zero : tab_bar.__Instance;
            var __ret = __Internal.TabBarFindTabByID(__arg0, tab_id);
            var __result0 = global::ImGuiSharp.ImGuiTabItem.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void TabBarRemoveTab(global::ImGuiSharp.ImGuiTabBar tab_bar, uint tab_id)
        {
            var __arg0 = tab_bar is null ? __IntPtr.Zero : tab_bar.__Instance;
            __Internal.TabBarRemoveTab(__arg0, tab_id);
        }

        public static void TabBarCloseTab(global::ImGuiSharp.ImGuiTabBar tab_bar, global::ImGuiSharp.ImGuiTabItem tab)
        {
            var __arg0 = tab_bar is null ? __IntPtr.Zero : tab_bar.__Instance;
            var __arg1 = tab is null ? __IntPtr.Zero : tab.__Instance;
            __Internal.TabBarCloseTab(__arg0, __arg1);
        }

        public static void TabBarQueueReorder(global::ImGuiSharp.ImGuiTabBar tab_bar, global::ImGuiSharp.ImGuiTabItem tab, int offset)
        {
            var __arg0 = tab_bar is null ? __IntPtr.Zero : tab_bar.__Instance;
            var __arg1 = tab is null ? __IntPtr.Zero : tab.__Instance;
            __Internal.TabBarQueueReorder(__arg0, __arg1, offset);
        }

        public static void TabBarQueueReorderFromMousePos(global::ImGuiSharp.ImGuiTabBar tab_bar, global::ImGuiSharp.ImGuiTabItem tab, global::ImGuiSharp.ImVec2 mouse_pos)
        {
            var __arg0 = tab_bar is null ? __IntPtr.Zero : tab_bar.__Instance;
            var __arg1 = tab is null ? __IntPtr.Zero : tab.__Instance;
            if (ReferenceEquals(mouse_pos, null))
                throw new global::System.ArgumentNullException("mouse_pos", "Cannot be null because it is passed by value.");
            var __arg2 = mouse_pos.__Instance;
            __Internal.TabBarQueueReorderFromMousePos(__arg0, __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2);
        }

        public static bool TabBarProcessReorder(global::ImGuiSharp.ImGuiTabBar tab_bar)
        {
            var __arg0 = tab_bar is null ? __IntPtr.Zero : tab_bar.__Instance;
            var __ret = __Internal.TabBarProcessReorder(__arg0);
            return __ret;
        }

        public static bool TabItemEx(global::ImGuiSharp.ImGuiTabBar tab_bar, string label, ref bool p_open, int flags)
        {
            var __arg0 = tab_bar is null ? __IntPtr.Zero : tab_bar.__Instance;
            fixed (bool* __p_open2 = &p_open)
            {
                var __arg2 = __p_open2;
                var __ret = __Internal.TabItemEx(__arg0, label, __arg2, flags);
                return __ret;
            }
        }

        public static void TabItemCalcSize(global::ImGuiSharp.ImVec2 pOut, string label, bool has_close_button)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.TabItemCalcSize(__arg0, label, has_close_button);
        }

        public static void TabItemBackground(global::ImGuiSharp.ImDrawList draw_list, global::ImGuiSharp.ImRect bb, int flags, uint col)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg1 = bb.__Instance;
            __Internal.TabItemBackground(__arg0, __arg1, flags, col);
        }

        public static void TabItemLabelAndCloseButton(global::ImGuiSharp.ImDrawList draw_list, global::ImGuiSharp.ImRect bb, int flags, global::ImGuiSharp.ImVec2 frame_padding, string label, uint tab_id, uint close_button_id, bool is_contents_visible, ref bool out_just_closed, ref bool out_text_clipped)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg1 = bb.__Instance;
            if (ReferenceEquals(frame_padding, null))
                throw new global::System.ArgumentNullException("frame_padding", "Cannot be null because it is passed by value.");
            var __arg3 = frame_padding.__Instance;
            fixed (bool* __out_just_closed8 = &out_just_closed)
            {
                var __arg8 = __out_just_closed8;
                fixed (bool* __out_text_clipped9 = &out_text_clipped)
                {
                    var __arg9 = __out_text_clipped9;
                    __Internal.TabItemLabelAndCloseButton(__arg0, __arg1, flags, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3, label, tab_id, close_button_id, is_contents_visible, __arg8, __arg9);
                }
            }
        }

        public static void RenderText(global::ImGuiSharp.ImVec2 pos, string text, string text_end, bool hide_text_after_hash)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg0 = pos.__Instance;
            __Internal.RenderText(*(global::ImGuiSharp.ImVec2.__Internal*) __arg0, text, text_end, hide_text_after_hash);
        }

        public static void RenderTextWrapped(global::ImGuiSharp.ImVec2 pos, string text, string text_end, float wrap_width)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg0 = pos.__Instance;
            __Internal.RenderTextWrapped(*(global::ImGuiSharp.ImVec2.__Internal*) __arg0, text, text_end, wrap_width);
        }

        public static void RenderTextClipped(global::ImGuiSharp.ImVec2 pos_min, global::ImGuiSharp.ImVec2 pos_max, string text, string text_end, global::ImGuiSharp.ImVec2 text_size_if_known, global::ImGuiSharp.ImVec2 align, global::ImGuiSharp.ImRect clip_rect)
        {
            if (ReferenceEquals(pos_min, null))
                throw new global::System.ArgumentNullException("pos_min", "Cannot be null because it is passed by value.");
            var __arg0 = pos_min.__Instance;
            if (ReferenceEquals(pos_max, null))
                throw new global::System.ArgumentNullException("pos_max", "Cannot be null because it is passed by value.");
            var __arg1 = pos_max.__Instance;
            var __arg4 = text_size_if_known is null ? __IntPtr.Zero : text_size_if_known.__Instance;
            if (ReferenceEquals(align, null))
                throw new global::System.ArgumentNullException("align", "Cannot be null because it is passed by value.");
            var __arg5 = align.__Instance;
            var __arg6 = clip_rect is null ? __IntPtr.Zero : clip_rect.__Instance;
            __Internal.RenderTextClipped(*(global::ImGuiSharp.ImVec2.__Internal*) __arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, text, text_end, __arg4, *(global::ImGuiSharp.ImVec2.__Internal*) __arg5, __arg6);
        }

        public static void RenderTextClippedEx(global::ImGuiSharp.ImDrawList draw_list, global::ImGuiSharp.ImVec2 pos_min, global::ImGuiSharp.ImVec2 pos_max, string text, string text_end, global::ImGuiSharp.ImVec2 text_size_if_known, global::ImGuiSharp.ImVec2 align, global::ImGuiSharp.ImRect clip_rect)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(pos_min, null))
                throw new global::System.ArgumentNullException("pos_min", "Cannot be null because it is passed by value.");
            var __arg1 = pos_min.__Instance;
            if (ReferenceEquals(pos_max, null))
                throw new global::System.ArgumentNullException("pos_max", "Cannot be null because it is passed by value.");
            var __arg2 = pos_max.__Instance;
            var __arg5 = text_size_if_known is null ? __IntPtr.Zero : text_size_if_known.__Instance;
            if (ReferenceEquals(align, null))
                throw new global::System.ArgumentNullException("align", "Cannot be null because it is passed by value.");
            var __arg6 = align.__Instance;
            var __arg7 = clip_rect is null ? __IntPtr.Zero : clip_rect.__Instance;
            __Internal.RenderTextClippedEx(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, text, text_end, __arg5, *(global::ImGuiSharp.ImVec2.__Internal*) __arg6, __arg7);
        }

        public static void RenderTextEllipsis(global::ImGuiSharp.ImDrawList draw_list, global::ImGuiSharp.ImVec2 pos_min, global::ImGuiSharp.ImVec2 pos_max, float clip_max_x, float ellipsis_max_x, string text, string text_end, global::ImGuiSharp.ImVec2 text_size_if_known)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(pos_min, null))
                throw new global::System.ArgumentNullException("pos_min", "Cannot be null because it is passed by value.");
            var __arg1 = pos_min.__Instance;
            if (ReferenceEquals(pos_max, null))
                throw new global::System.ArgumentNullException("pos_max", "Cannot be null because it is passed by value.");
            var __arg2 = pos_max.__Instance;
            var __arg7 = text_size_if_known is null ? __IntPtr.Zero : text_size_if_known.__Instance;
            __Internal.RenderTextEllipsis(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, clip_max_x, ellipsis_max_x, text, text_end, __arg7);
        }

        public static void RenderFrame(global::ImGuiSharp.ImVec2 p_min, global::ImGuiSharp.ImVec2 p_max, uint fill_col, bool border, float rounding)
        {
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is passed by value.");
            var __arg0 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is passed by value.");
            var __arg1 = p_max.__Instance;
            __Internal.RenderFrame(*(global::ImGuiSharp.ImVec2.__Internal*) __arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, fill_col, border, rounding);
        }

        public static void RenderFrameBorder(global::ImGuiSharp.ImVec2 p_min, global::ImGuiSharp.ImVec2 p_max, float rounding)
        {
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is passed by value.");
            var __arg0 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is passed by value.");
            var __arg1 = p_max.__Instance;
            __Internal.RenderFrameBorder(*(global::ImGuiSharp.ImVec2.__Internal*) __arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, rounding);
        }

        public static void RenderColorRectWithAlphaCheckerboard(global::ImGuiSharp.ImDrawList draw_list, global::ImGuiSharp.ImVec2 p_min, global::ImGuiSharp.ImVec2 p_max, uint fill_col, float grid_step, global::ImGuiSharp.ImVec2 grid_off, float rounding, int flags)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is passed by value.");
            var __arg1 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is passed by value.");
            var __arg2 = p_max.__Instance;
            if (ReferenceEquals(grid_off, null))
                throw new global::System.ArgumentNullException("grid_off", "Cannot be null because it is passed by value.");
            var __arg5 = grid_off.__Instance;
            __Internal.RenderColorRectWithAlphaCheckerboard(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, fill_col, grid_step, *(global::ImGuiSharp.ImVec2.__Internal*) __arg5, rounding, flags);
        }

        public static void RenderNavHighlight(global::ImGuiSharp.ImRect bb, uint id, int flags)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            __Internal.RenderNavHighlight(__arg0, id, flags);
        }

        public static string FindRenderedTextEnd(string text, string text_end)
        {
            var __ret = __Internal.FindRenderedTextEnd(text, text_end);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static void RenderArrow(global::ImGuiSharp.ImDrawList draw_list, global::ImGuiSharp.ImVec2 pos, uint col, int dir, float scale)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            __Internal.RenderArrow(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, col, dir, scale);
        }

        public static void RenderBullet(global::ImGuiSharp.ImDrawList draw_list, global::ImGuiSharp.ImVec2 pos, uint col)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            __Internal.RenderBullet(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, col);
        }

        public static void RenderCheckMark(global::ImGuiSharp.ImDrawList draw_list, global::ImGuiSharp.ImVec2 pos, uint col, float sz)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            __Internal.RenderCheckMark(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, col, sz);
        }

        public static void RenderMouseCursor(global::ImGuiSharp.ImDrawList draw_list, global::ImGuiSharp.ImVec2 pos, float scale, int mouse_cursor, uint col_fill, uint col_border, uint col_shadow)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            __Internal.RenderMouseCursor(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, scale, mouse_cursor, col_fill, col_border, col_shadow);
        }

        public static void RenderArrowPointingAt(global::ImGuiSharp.ImDrawList draw_list, global::ImGuiSharp.ImVec2 pos, global::ImGuiSharp.ImVec2 half_sz, int direction, uint col)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            if (ReferenceEquals(half_sz, null))
                throw new global::System.ArgumentNullException("half_sz", "Cannot be null because it is passed by value.");
            var __arg2 = half_sz.__Instance;
            __Internal.RenderArrowPointingAt(__arg0, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, direction, col);
        }

        public static void RenderRectFilledRangeH(global::ImGuiSharp.ImDrawList draw_list, global::ImGuiSharp.ImRect rect, uint col, float x_start_norm, float x_end_norm, float rounding)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(rect, null))
                throw new global::System.ArgumentNullException("rect", "Cannot be null because it is passed by value.");
            var __arg1 = rect.__Instance;
            __Internal.RenderRectFilledRangeH(__arg0, __arg1, col, x_start_norm, x_end_norm, rounding);
        }

        public static void RenderRectFilledWithHole(global::ImGuiSharp.ImDrawList draw_list, global::ImGuiSharp.ImRect outer, global::ImGuiSharp.ImRect inner, uint col, float rounding)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(outer, null))
                throw new global::System.ArgumentNullException("outer", "Cannot be null because it is passed by value.");
            var __arg1 = outer.__Instance;
            if (ReferenceEquals(inner, null))
                throw new global::System.ArgumentNullException("inner", "Cannot be null because it is passed by value.");
            var __arg2 = inner.__Instance;
            __Internal.RenderRectFilledWithHole(__arg0, __arg1, __arg2, col, rounding);
        }

        public static void TextEx(string text, string text_end, int flags)
        {
            __Internal.TextEx(text, text_end, flags);
        }

        public static bool ButtonEx(string label, global::ImGuiSharp.ImVec2 size_arg, int flags)
        {
            if (ReferenceEquals(size_arg, null))
                throw new global::System.ArgumentNullException("size_arg", "Cannot be null because it is passed by value.");
            var __arg1 = size_arg.__Instance;
            var __ret = __Internal.ButtonEx(label, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1, flags);
            return __ret;
        }

        public static bool CloseButton(uint id, global::ImGuiSharp.ImVec2 pos)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            var __ret = __Internal.CloseButton(id, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1);
            return __ret;
        }

        public static bool CollapseButton(uint id, global::ImGuiSharp.ImVec2 pos)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            var __ret = __Internal.CollapseButton(id, *(global::ImGuiSharp.ImVec2.__Internal*) __arg1);
            return __ret;
        }

        public static bool ArrowButtonEx(string str_id, int dir, global::ImGuiSharp.ImVec2 size_arg, int flags)
        {
            if (ReferenceEquals(size_arg, null))
                throw new global::System.ArgumentNullException("size_arg", "Cannot be null because it is passed by value.");
            var __arg2 = size_arg.__Instance;
            var __ret = __Internal.ArrowButtonEx(str_id, dir, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, flags);
            return __ret;
        }

        public static void Scrollbar(global::ImGuiSharp.ImGuiAxis axis)
        {
            __Internal.Scrollbar(axis);
        }

        public static bool ScrollbarEx(global::ImGuiSharp.ImRect bb, uint id, global::ImGuiSharp.ImGuiAxis axis, ref long p_scroll_v, long avail_v, long contents_v, int flags)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            fixed (long* __p_scroll_v3 = &p_scroll_v)
            {
                var __arg3 = __p_scroll_v3;
                var __ret = __Internal.ScrollbarEx(__arg0, id, axis, __arg3, avail_v, contents_v, flags);
                return __ret;
            }
        }

        public static bool ImageButtonEx(uint id, __IntPtr texture_id, global::ImGuiSharp.ImVec2 size, global::ImGuiSharp.ImVec2 uv0, global::ImGuiSharp.ImVec2 uv1, global::ImGuiSharp.ImVec2 padding, global::ImGuiSharp.ImVec4 bg_col, global::ImGuiSharp.ImVec4 tint_col)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg2 = size.__Instance;
            if (ReferenceEquals(uv0, null))
                throw new global::System.ArgumentNullException("uv0", "Cannot be null because it is passed by value.");
            var __arg3 = uv0.__Instance;
            if (ReferenceEquals(uv1, null))
                throw new global::System.ArgumentNullException("uv1", "Cannot be null because it is passed by value.");
            var __arg4 = uv1.__Instance;
            if (ReferenceEquals(padding, null))
                throw new global::System.ArgumentNullException("padding", "Cannot be null because it is passed by value.");
            var __arg5 = padding.__Instance;
            if (ReferenceEquals(bg_col, null))
                throw new global::System.ArgumentNullException("bg_col", "Cannot be null because it is passed by value.");
            var __arg6 = bg_col.__Instance;
            if (ReferenceEquals(tint_col, null))
                throw new global::System.ArgumentNullException("tint_col", "Cannot be null because it is passed by value.");
            var __arg7 = tint_col.__Instance;
            var __ret = __Internal.ImageButtonEx(id, texture_id, *(global::ImGuiSharp.ImVec2.__Internal*) __arg2, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3, *(global::ImGuiSharp.ImVec2.__Internal*) __arg4, *(global::ImGuiSharp.ImVec2.__Internal*) __arg5, *(global::ImGuiSharp.ImVec4.__Internal*) __arg6, *(global::ImGuiSharp.ImVec4.__Internal*) __arg7);
            return __ret;
        }

        public static void GetWindowScrollbarRect(global::ImGuiSharp.ImRect pOut, global::ImGuiSharp.ImGuiWindow window, global::ImGuiSharp.ImGuiAxis axis)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.GetWindowScrollbarRect(__arg0, __arg1, axis);
        }

        public static uint GetWindowScrollbarID(global::ImGuiSharp.ImGuiWindow window, global::ImGuiSharp.ImGuiAxis axis)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GetWindowScrollbarID(__arg0, axis);
            return __ret;
        }

        public static uint GetWindowResizeCornerID(global::ImGuiSharp.ImGuiWindow window, int n)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GetWindowResizeCornerID(__arg0, n);
            return __ret;
        }

        public static uint GetWindowResizeBorderID(global::ImGuiSharp.ImGuiWindow window, int dir)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GetWindowResizeBorderID(__arg0, dir);
            return __ret;
        }

        public static void SeparatorEx(int flags)
        {
            __Internal.SeparatorEx(flags);
        }

        public static bool CheckboxFlagsS64Ptr(string label, ref long flags, long flags_value)
        {
            fixed (long* __flags1 = &flags)
            {
                var __arg1 = __flags1;
                var __ret = __Internal.CheckboxFlagsS64Ptr(label, __arg1, flags_value);
                return __ret;
            }
        }

        public static bool CheckboxFlagsU64Ptr(string label, ref ulong flags, ulong flags_value)
        {
            fixed (ulong* __flags1 = &flags)
            {
                var __arg1 = __flags1;
                var __ret = __Internal.CheckboxFlagsU64Ptr(label, __arg1, flags_value);
                return __ret;
            }
        }

        public static bool ButtonBehavior(global::ImGuiSharp.ImRect bb, uint id, ref bool out_hovered, ref bool out_held, int flags)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            fixed (bool* __out_hovered2 = &out_hovered)
            {
                var __arg2 = __out_hovered2;
                fixed (bool* __out_held3 = &out_held)
                {
                    var __arg3 = __out_held3;
                    var __ret = __Internal.ButtonBehavior(__arg0, id, __arg2, __arg3, flags);
                    return __ret;
                }
            }
        }

        public static bool DragBehavior(uint id, int data_type, __IntPtr p_v, float v_speed, __IntPtr p_min, __IntPtr p_max, string format, int flags)
        {
            var __ret = __Internal.DragBehavior(id, data_type, p_v, v_speed, p_min, p_max, format, flags);
            return __ret;
        }

        public static bool SliderBehavior(global::ImGuiSharp.ImRect bb, uint id, int data_type, __IntPtr p_v, __IntPtr p_min, __IntPtr p_max, string format, int flags, global::ImGuiSharp.ImRect out_grab_bb)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            var __arg8 = out_grab_bb is null ? __IntPtr.Zero : out_grab_bb.__Instance;
            var __ret = __Internal.SliderBehavior(__arg0, id, data_type, p_v, p_min, p_max, format, flags, __arg8);
            return __ret;
        }

        public static bool SplitterBehavior(global::ImGuiSharp.ImRect bb, uint id, global::ImGuiSharp.ImGuiAxis axis, ref float size1, ref float size2, float min_size1, float min_size2, float hover_extend, float hover_visibility_delay)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            fixed (float* __size13 = &size1)
            {
                var __arg3 = __size13;
                fixed (float* __size24 = &size2)
                {
                    var __arg4 = __size24;
                    var __ret = __Internal.SplitterBehavior(__arg0, id, axis, __arg3, __arg4, min_size1, min_size2, hover_extend, hover_visibility_delay);
                    return __ret;
                }
            }
        }

        public static bool TreeNodeBehavior(uint id, int flags, string label, string label_end)
        {
            var __ret = __Internal.TreeNodeBehavior(id, flags, label, label_end);
            return __ret;
        }

        public static bool TreeNodeBehaviorIsOpen(uint id, int flags)
        {
            var __ret = __Internal.TreeNodeBehaviorIsOpen(id, flags);
            return __ret;
        }

        public static void TreePushOverrideID(uint id)
        {
            __Internal.TreePushOverrideID(id);
        }

        public static global::ImGuiSharp.ImGuiDataTypeInfo DataTypeGetInfo(int data_type)
        {
            var __ret = __Internal.DataTypeGetInfo(data_type);
            var __result0 = global::ImGuiSharp.ImGuiDataTypeInfo.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static int DataTypeFormatString(sbyte* buf, int buf_size, int data_type, __IntPtr p_data, string format)
        {
            var __ret = __Internal.DataTypeFormatString(buf, buf_size, data_type, p_data, format);
            return __ret;
        }

        public static void DataTypeApplyOp(int data_type, int op, __IntPtr output, __IntPtr arg_1, __IntPtr arg_2)
        {
            __Internal.DataTypeApplyOp(data_type, op, output, arg_1, arg_2);
        }

        public static bool DataTypeApplyFromText(string buf, int data_type, __IntPtr p_data, string format)
        {
            var __ret = __Internal.DataTypeApplyFromText(buf, data_type, p_data, format);
            return __ret;
        }

        public static int DataTypeCompare(int data_type, __IntPtr arg_1, __IntPtr arg_2)
        {
            var __ret = __Internal.DataTypeCompare(data_type, arg_1, arg_2);
            return __ret;
        }

        public static bool DataTypeClamp(int data_type, __IntPtr p_data, __IntPtr p_min, __IntPtr p_max)
        {
            var __ret = __Internal.DataTypeClamp(data_type, p_data, p_min, p_max);
            return __ret;
        }

        public static bool InputTextEx(string label, string hint, sbyte* buf, int buf_size, global::ImGuiSharp.ImVec2 size_arg, int flags, global::ImGuiSharp.ImGuiInputTextCallback callback, __IntPtr user_data)
        {
            if (ReferenceEquals(size_arg, null))
                throw new global::System.ArgumentNullException("size_arg", "Cannot be null because it is passed by value.");
            var __arg4 = size_arg.__Instance;
            var __arg6 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.InputTextEx(label, hint, buf, buf_size, *(global::ImGuiSharp.ImVec2.__Internal*) __arg4, flags, __arg6, user_data);
            return __ret;
        }

        public static bool TempInputText(global::ImGuiSharp.ImRect bb, uint id, string label, sbyte* buf, int buf_size, int flags)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            var __ret = __Internal.TempInputText(__arg0, id, label, buf, buf_size, flags);
            return __ret;
        }

        public static bool TempInputScalar(global::ImGuiSharp.ImRect bb, uint id, string label, int data_type, __IntPtr p_data, string format, __IntPtr p_clamp_min, __IntPtr p_clamp_max)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            var __ret = __Internal.TempInputScalar(__arg0, id, label, data_type, p_data, format, p_clamp_min, p_clamp_max);
            return __ret;
        }

        public static bool TempInputIsActive(uint id)
        {
            var __ret = __Internal.TempInputIsActive(id);
            return __ret;
        }

        public static global::ImGuiSharp.ImGuiInputTextState GetInputTextState(uint id)
        {
            var __ret = __Internal.GetInputTextState(id);
            var __result0 = global::ImGuiSharp.ImGuiInputTextState.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ColorTooltip(string text, ref float col, int flags)
        {
            fixed (float* __col1 = &col)
            {
                var __arg1 = __col1;
                __Internal.ColorTooltip(text, __arg1, flags);
            }
        }

        public static void ColorEditOptionsPopup(ref float col, int flags)
        {
            fixed (float* __col0 = &col)
            {
                var __arg0 = __col0;
                __Internal.ColorEditOptionsPopup(__arg0, flags);
            }
        }

        public static void ColorPickerOptionsPopup(ref float ref_col, int flags)
        {
            fixed (float* __ref_col0 = &ref_col)
            {
                var __arg0 = __ref_col0;
                __Internal.ColorPickerOptionsPopup(__arg0, flags);
            }
        }

        public static int PlotEx(global::ImGuiSharp.ImGuiPlotType plot_type, string label, global::ImGuiSharp.Delegates.Func_float___IntPtr_int values_getter, __IntPtr data, int values_count, int values_offset, string overlay_text, float scale_min, float scale_max, global::ImGuiSharp.ImVec2 frame_size)
        {
            var __arg2 = values_getter == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(values_getter);
            if (ReferenceEquals(frame_size, null))
                throw new global::System.ArgumentNullException("frame_size", "Cannot be null because it is passed by value.");
            var __arg9 = frame_size.__Instance;
            var __ret = __Internal.PlotEx(plot_type, label, __arg2, data, values_count, values_offset, overlay_text, scale_min, scale_max, *(global::ImGuiSharp.ImVec2.__Internal*) __arg9);
            return __ret;
        }

        public static void ShadeVertsLinearColorGradientKeepAlpha(global::ImGuiSharp.ImDrawList draw_list, int vert_start_idx, int vert_end_idx, global::ImGuiSharp.ImVec2 gradient_p0, global::ImGuiSharp.ImVec2 gradient_p1, uint col0, uint col1)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(gradient_p0, null))
                throw new global::System.ArgumentNullException("gradient_p0", "Cannot be null because it is passed by value.");
            var __arg3 = gradient_p0.__Instance;
            if (ReferenceEquals(gradient_p1, null))
                throw new global::System.ArgumentNullException("gradient_p1", "Cannot be null because it is passed by value.");
            var __arg4 = gradient_p1.__Instance;
            __Internal.ShadeVertsLinearColorGradientKeepAlpha(__arg0, vert_start_idx, vert_end_idx, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3, *(global::ImGuiSharp.ImVec2.__Internal*) __arg4, col0, col1);
        }

        public static void ShadeVertsLinearUV(global::ImGuiSharp.ImDrawList draw_list, int vert_start_idx, int vert_end_idx, global::ImGuiSharp.ImVec2 a, global::ImGuiSharp.ImVec2 b, global::ImGuiSharp.ImVec2 uv_a, global::ImGuiSharp.ImVec2 uv_b, bool clamp)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg3 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg4 = b.__Instance;
            if (ReferenceEquals(uv_a, null))
                throw new global::System.ArgumentNullException("uv_a", "Cannot be null because it is passed by value.");
            var __arg5 = uv_a.__Instance;
            if (ReferenceEquals(uv_b, null))
                throw new global::System.ArgumentNullException("uv_b", "Cannot be null because it is passed by value.");
            var __arg6 = uv_b.__Instance;
            __Internal.ShadeVertsLinearUV(__arg0, vert_start_idx, vert_end_idx, *(global::ImGuiSharp.ImVec2.__Internal*) __arg3, *(global::ImGuiSharp.ImVec2.__Internal*) __arg4, *(global::ImGuiSharp.ImVec2.__Internal*) __arg5, *(global::ImGuiSharp.ImVec2.__Internal*) __arg6, clamp);
        }

        public static void GcCompactTransientMiscBuffers()
        {
            __Internal.GcCompactTransientMiscBuffers();
        }

        public static void GcCompactTransientWindowBuffers(global::ImGuiSharp.ImGuiWindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.GcCompactTransientWindowBuffers(__arg0);
        }

        public static void GcAwakeTransientWindowBuffers(global::ImGuiSharp.ImGuiWindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.GcAwakeTransientWindowBuffers(__arg0);
        }

        public static void ErrorCheckEndFrameRecover(global::ImGuiSharp.ImGuiErrorLogCallback log_callback, __IntPtr user_data)
        {
            var __arg0 = log_callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(log_callback);
            __Internal.ErrorCheckEndFrameRecover(__arg0, user_data);
        }

        public static void ErrorCheckEndWindowRecover(global::ImGuiSharp.ImGuiErrorLogCallback log_callback, __IntPtr user_data)
        {
            var __arg0 = log_callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(log_callback);
            __Internal.ErrorCheckEndWindowRecover(__arg0, user_data);
        }

        public static void DebugDrawItemRect(uint col)
        {
            __Internal.DebugDrawItemRect(col);
        }

        public static void DebugStartItemPicker()
        {
            __Internal.DebugStartItemPicker();
        }

        public static void ShowFontAtlas(global::ImGuiSharp.ImFontAtlas atlas)
        {
            var __arg0 = atlas is null ? __IntPtr.Zero : atlas.__Instance;
            __Internal.ShowFontAtlas(__arg0);
        }

        public static void DebugHookIdInfo(uint id, int data_type, __IntPtr data_id, __IntPtr data_id_end)
        {
            __Internal.DebugHookIdInfo(id, data_type, data_id, data_id_end);
        }

        public static void DebugNodeColumns(global::ImGuiSharp.ImGuiOldColumns columns)
        {
            var __arg0 = columns is null ? __IntPtr.Zero : columns.__Instance;
            __Internal.DebugNodeColumns(__arg0);
        }

        public static void DebugNodeDrawList(global::ImGuiSharp.ImGuiWindow window, global::ImGuiSharp.ImDrawList draw_list, string label)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            __Internal.DebugNodeDrawList(__arg0, __arg1, label);
        }

        public static void DebugNodeDrawCmdShowMeshAndBoundingBox(global::ImGuiSharp.ImDrawList out_draw_list, global::ImGuiSharp.ImDrawList draw_list, global::ImGuiSharp.ImDrawCmd draw_cmd, bool show_mesh, bool show_aabb)
        {
            var __arg0 = out_draw_list is null ? __IntPtr.Zero : out_draw_list.__Instance;
            var __arg1 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            var __arg2 = draw_cmd is null ? __IntPtr.Zero : draw_cmd.__Instance;
            __Internal.DebugNodeDrawCmdShowMeshAndBoundingBox(__arg0, __arg1, __arg2, show_mesh, show_aabb);
        }

        public static void DebugNodeFont(global::ImGuiSharp.ImFont font)
        {
            var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
            __Internal.DebugNodeFont(__arg0);
        }

        public static void DebugNodeStorage(global::ImGuiSharp.ImGuiStorage storage, string label)
        {
            var __arg0 = storage is null ? __IntPtr.Zero : storage.__Instance;
            __Internal.DebugNodeStorage(__arg0, label);
        }

        public static void DebugNodeTabBar(global::ImGuiSharp.ImGuiTabBar tab_bar, string label)
        {
            var __arg0 = tab_bar is null ? __IntPtr.Zero : tab_bar.__Instance;
            __Internal.DebugNodeTabBar(__arg0, label);
        }

        public static void DebugNodeTable(global::ImGuiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.DebugNodeTable(__arg0);
        }

        public static void DebugNodeTableSettings(global::ImGuiSharp.ImGuiTableSettings settings)
        {
            var __arg0 = settings is null ? __IntPtr.Zero : settings.__Instance;
            __Internal.DebugNodeTableSettings(__arg0);
        }

        public static void DebugNodeWindow(global::ImGuiSharp.ImGuiWindow window, string label)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.DebugNodeWindow(__arg0, label);
        }

        public static void DebugNodeWindowSettings(global::ImGuiSharp.ImGuiWindowSettings settings)
        {
            var __arg0 = settings is null ? __IntPtr.Zero : settings.__Instance;
            __Internal.DebugNodeWindowSettings(__arg0);
        }

        public static void DebugNodeWindowsList(global::ImGuiSharp.ImVectorImGuiWindowPtr windows, string label)
        {
            var __arg0 = windows is null ? __IntPtr.Zero : windows.__Instance;
            __Internal.DebugNodeWindowsList(__arg0, label);
        }

        public static void DebugNodeWindowsListByBeginStackParent(global::ImGuiSharp.ImGuiWindow windows, int windows_size, global::ImGuiSharp.ImGuiWindow parent_in_begin_stack)
        {
            var ____arg0 = windows is null ? __IntPtr.Zero : windows.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            var __arg2 = parent_in_begin_stack is null ? __IntPtr.Zero : parent_in_begin_stack.__Instance;
            __Internal.DebugNodeWindowsListByBeginStackParent(__arg0, windows_size, __arg2);
        }

        public static void DebugNodeViewport(global::ImGuiSharp.ImGuiViewportP viewport)
        {
            var __arg0 = viewport is null ? __IntPtr.Zero : viewport.__Instance;
            __Internal.DebugNodeViewport(__arg0);
        }

        public static void DebugRenderViewportThumbnail(global::ImGuiSharp.ImDrawList draw_list, global::ImGuiSharp.ImGuiViewportP viewport, global::ImGuiSharp.ImRect bb)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            var __arg1 = viewport is null ? __IntPtr.Zero : viewport.__Instance;
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg2 = bb.__Instance;
            __Internal.DebugRenderViewportThumbnail(__arg0, __arg1, __arg2);
        }

        public static global::ImGuiSharp.ImFontBuilderIO ImFontAtlasGetBuilderForStbTruetype()
        {
            var __ret = __Internal.ImFontAtlasGetBuilderForStbTruetype();
            var __result0 = global::ImGuiSharp.ImFontBuilderIO.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImFontAtlasBuildInit(global::ImGuiSharp.ImFontAtlas atlas)
        {
            var __arg0 = atlas is null ? __IntPtr.Zero : atlas.__Instance;
            __Internal.ImFontAtlasBuildInit(__arg0);
        }

        public static void ImFontAtlasBuildSetupFont(global::ImGuiSharp.ImFontAtlas atlas, global::ImGuiSharp.ImFont font, global::ImGuiSharp.ImFontConfig font_config, float ascent, float descent)
        {
            var __arg0 = atlas is null ? __IntPtr.Zero : atlas.__Instance;
            var __arg1 = font is null ? __IntPtr.Zero : font.__Instance;
            var __arg2 = font_config is null ? __IntPtr.Zero : font_config.__Instance;
            __Internal.ImFontAtlasBuildSetupFont(__arg0, __arg1, __arg2, ascent, descent);
        }

        public static void ImFontAtlasBuildPackCustomRects(global::ImGuiSharp.ImFontAtlas atlas, __IntPtr stbrp_context_opaque)
        {
            var __arg0 = atlas is null ? __IntPtr.Zero : atlas.__Instance;
            __Internal.ImFontAtlasBuildPackCustomRects(__arg0, stbrp_context_opaque);
        }

        public static void ImFontAtlasBuildFinish(global::ImGuiSharp.ImFontAtlas atlas)
        {
            var __arg0 = atlas is null ? __IntPtr.Zero : atlas.__Instance;
            __Internal.ImFontAtlasBuildFinish(__arg0);
        }

        public static void ImFontAtlasBuildRender8bppRectFromString(global::ImGuiSharp.ImFontAtlas atlas, int x, int y, int w, int h, string in_str, sbyte in_marker_char, byte in_marker_pixel_value)
        {
            var __arg0 = atlas is null ? __IntPtr.Zero : atlas.__Instance;
            __Internal.ImFontAtlasBuildRender8bppRectFromString(__arg0, x, y, w, h, in_str, in_marker_char, in_marker_pixel_value);
        }

        public static void ImFontAtlasBuildRender32bppRectFromString(global::ImGuiSharp.ImFontAtlas atlas, int x, int y, int w, int h, string in_str, sbyte in_marker_char, uint in_marker_pixel_value)
        {
            var __arg0 = atlas is null ? __IntPtr.Zero : atlas.__Instance;
            __Internal.ImFontAtlasBuildRender32bppRectFromString(__arg0, x, y, w, h, in_str, in_marker_char, in_marker_pixel_value);
        }

        public static void ImFontAtlasBuildMultiplyCalcLookupTable(byte[] out_table, float in_multiply_factor)
        {
            if (out_table == null || out_table.Length != 256)
                throw new ArgumentOutOfRangeException("out_table", "The dimensions of the provided array don't match the required size.");
            __Internal.ImFontAtlasBuildMultiplyCalcLookupTable(out_table, in_multiply_factor);
        }

        public static void ImFontAtlasBuildMultiplyRectAlpha8(byte[] table, byte* pixels, int x, int y, int w, int h, int stride)
        {
            if (table == null || table.Length != 256)
                throw new ArgumentOutOfRangeException("table", "The dimensions of the provided array don't match the required size.");
            __Internal.ImFontAtlasBuildMultiplyRectAlpha8(table, pixels, x, y, w, h, stride);
        }

        /// <summary>//////////////////////hand written functions</summary>
        public static void LogText(string fmt)
        {
            __Internal.LogText(fmt);
        }

        public static float GET_FLT_MAX()
        {
            var __ret = __Internal.GET_FLT_MAX();
            return __ret;
        }

        public static float GET_FLT_MIN()
        {
            var __ret = __Internal.GET_FLT_MIN();
            return __ret;
        }

        public static global::ImGuiSharp.ImVectorImWchar ImVectorImWchar_create()
        {
            var __ret = __Internal.ImVectorImWchar_create();
            var __result0 = global::ImGuiSharp.ImVectorImWchar.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImVectorImWchar_destroy(global::ImGuiSharp.ImVectorImWchar self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImVectorImWchar_destroy(__arg0);
        }

        public static void ImVectorImWcharInit(global::ImGuiSharp.ImVectorImWchar p)
        {
            var __arg0 = p is null ? __IntPtr.Zero : p.__Instance;
            __Internal.ImVectorImWcharInit(__arg0);
        }

        public static void ImVectorImWcharUnInit(global::ImGuiSharp.ImVectorImWchar p)
        {
            var __arg0 = p is null ? __IntPtr.Zero : p.__Instance;
            __Internal.ImVectorImWcharUnInit(__arg0);
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        public unsafe delegate bool Func_bool___IntPtr(__IntPtr atlas);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate __IntPtr Func___IntPtr___IntPtr(__IntPtr user_data);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr_string8(__IntPtr user_data, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr___IntPtr(__IntPtr viewport, __IntPtr data);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate __IntPtr Func___IntPtr___IntPtr___IntPtr_string8(__IntPtr ctx, __IntPtr handler, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr___IntPtr___IntPtr_string8(__IntPtr ctx, __IntPtr handler, __IntPtr entry, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string line);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr___IntPtr___IntPtr(__IntPtr ctx, __IntPtr handler, __IntPtr out_buf);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        public unsafe delegate bool Func_bool___IntPtr_int_sbytePtrPtr(__IntPtr data, int idx, sbyte** out_text);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate float Func_float___IntPtr_int(__IntPtr data, int idx);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate int Func_int___IntPtr___IntPtr(__IntPtr __0, __IntPtr __1);
    }
}
